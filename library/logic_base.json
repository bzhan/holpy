[
    {
        "unicode_op": "∧",
        "T": "bool => bool => bool",
        "ty": "def.ax",
        "name": "conj",
        "ascii_op": "&"
    },
    {
        "unicode_op": "∨",
        "T": "bool => bool => bool",
        "ty": "def.ax",
        "name": "disj",
        "ascii_op": "|"
    },
    {
        "unicode_op": "¬",
        "T": "bool => bool",
        "ty": "def.ax",
        "name": "neg",
        "ascii_op": "~"
    },
    {
        "T": "bool",
        "ty": "def.ax",
        "name": "true"
    },
    {
        "T": "bool",
        "ty": "def.ax",
        "name": "false"
    },
    {
        "T": "('a => bool) => bool",
        "ty": "def.ax",
        "name": "exists"
    },
    {
        "prop": "A --> B --> A & B",
        "ty": "thm",
        "vars": {
            "B": "bool",
            "A": "bool"
        },
        "name": "conjI"
    },
    {
        "prop": "A & B --> A",
        "ty": "thm",
        "vars": {
            "B": "bool",
            "A": "bool"
        },
        "name": "conjD1"
    },
    {
        "prop": "A & B --> B",
        "ty": "thm",
        "vars": {
            "B": "bool",
            "A": "bool"
        },
        "name": "conjD2"
    },
    {
        "prop": "A --> A | B",
        "ty": "thm",
        "vars": {
            "B": "bool",
            "A": "bool"
        },
        "name": "disjI1"
    },
    {
        "prop": "B --> A | B",
        "ty": "thm",
        "vars": {
            "B": "bool",
            "A": "bool"
        },
        "name": "disjI2"
    },
    {
        "prop": "A | B --> (A --> C) --> (B --> C) --> C",
        "ty": "thm",
        "vars": {
            "C": "bool",
            "B": "bool",
            "A": "bool"
        },
        "name": "disjE"
    },
    {
        "prop": "(A --> false) --> ~A",
        "ty": "thm",
        "vars": {
            "A": "bool"
        },
        "name": "negI"
    },
    {
        "prop": "~A --> A --> false",
        "ty": "thm",
        "vars": {
            "A": "bool"
        },
        "name": "negE"
    },
    {
        "prop": "true",
        "ty": "thm",
        "vars": {},
        "name": "trueI"
    },
    {
        "prop": "false --> A",
        "ty": "thm",
        "vars": {
            "A": "bool"
        },
        "name": "falseE"
    },
    {
        "prop": "P a --> ?a::'a. P a",
        "ty": "thm",
        "vars": {
            "a": "'a",
            "P": "'a => bool"
        },
        "name": "exI"
    },
    {
        "prop": "(?a::'a. P a) --> (!a::'a. P a --> C) --> C",
        "ty": "thm",
        "vars": {
            "a": "'a",
            "P": "'a => bool",
            "C": "bool"
        },
        "name": "exE"
    },
    {
        "prop": "A | ~A",
        "ty": "thm",
        "vars": {
            "A": "bool"
        },
        "name": "classical"
    },
    {
        "args": [],
        "ty": "type.ind",
        "name": "nat",
        "constrs": [
            {
                "args": [],
                "type": "nat",
                "name": "zero"
            },
            {
                "args": [
                    "n"
                ],
                "type": "nat => nat",
                "name": "Suc"
            }
        ]
    },
    {
        "ascii_op": "+",
        "ty": "def.ind",
        "name": "plus",
        "type": "nat => nat => nat",
        "rules": [
            {
                "vars": {
                    "n": "nat"
                },
                "prop": "0 + n = n"
            },
            {
                "vars": {
                    "m": "nat",
                    "n": "nat"
                },
                "prop": "Suc m + n = Suc (m + n)"
            }
        ]
    },
    {
        "ascii_op": "*",
        "ty": "def.ind",
        "name": "times",
        "type": "nat => nat => nat",
        "rules": [
            {
                "vars": {
                    "n": "nat"
                },
                "prop": "0 * n = 0"
            },
            {
                "vars": {
                    "m": "nat",
                    "n": "nat"
                },
                "prop": "Suc m * n = n + m * n"
            }
        ]
    },
    {
        "args": [
            "a"
        ],
        "ty": "type.ind",
        "name": "list",
        "constrs": [
            {
                "args": [],
                "type": "'a list",
                "name": "nil"
            },
            {
                "args": [
                    "x",
                    "xs"
                ],
                "type": "'a => 'a list => 'a list",
                "name": "cons"
            }
        ]
    },
    {
        "ascii_op": "@",
        "ty": "def.ind",
        "name": "append",
        "type": "'a list => 'a list => 'a list",
        "rules": [
            {
                "vars": {
                    "xs": "'a list"
                },
                "prop": "nil @ xs = xs"
            },
            {
                "vars": {
                    "xs": "'a list",
                    "x": "'a",
                    "ys": "'a list"
                },
                "prop": "cons x xs @ ys = cons x (xs @ ys)"
            }
        ]
    },
    {
        "rules": [
            {
                "vars": {},
                "prop": "rev nil = nil"
            },
            {
                "vars": {
                    "xs": "'a list",
                    "x": "'a"
                },
                "prop": "rev (cons x xs) = rev xs @ cons x nil"
            }
        ],
        "ty": "def.ind",
        "name": "rev",
        "type": "'a list => 'a list"
    },
    {
        "ty": "thm",
        "name": "conjI",
        "vars": {
            "A": "bool",
            "B": "bool"
        },
        "prop": " A ⟶ B ⟶ A ∧ B",
        "proof": [
            {
                "args": "A",
                "id": "A1",
                "prevs": [],
                "rule": "assume",
                "th": "A ⊢ A"
            },
            {
                "args": "B",
                "id": "A2",
                "prevs": [],
                "rule": "assume",
                "th": "B ⊢ B"
            },
            {
                "args": "",
                "id": "S1",
                "prevs": [],
                "rule": "sorry",
                "th": "A, B ⊢ A ∧ B"
            },
            {
                "args": "B",
                "id": "S2",
                "prevs": [
                    "S1"
                ],
                "rule": "implies_intr",
                "th": "A ⊢ B ⟶ A ∧ B"
            },
            {
                "args": "A",
                "id": "S3",
                "prevs": [
                    "S2"
                ],
                "rule": "implies_intr",
                "th": "⊢ A ⟶ B ⟶ A ∧ B"
            }
        ],
        "num_gaps": 1
    },
    {
        "ty": "def.ax",
        "name": "conjI",
        "T": "bool"
    },
    {
        "ty": "thm",
        "name": "falseE",
        "vars": {
            "A": "bool",
            "B": "bool"
        },
        "prop": "false ⟶ A"
    }
]