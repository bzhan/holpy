{
    "content": [
        {
            "name": "nat_interval",
            "prop": "nat_interval m n = {p. less_eq m p & less_eq p n}",
            "ty": "def",
            "type": "nat ⇒ nat ⇒ nat set"
        },
        {
            "name": "finite_numseg",
            "prop": "finite {m..n}",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [],
            "name": "numseg_combine_r",
            "prop": "m <= p + 1 & p <= n --> (union {m..p} {(p + 1)..n} = {m..n})",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat",
                "p": "nat"
            }
        },
        {
            "attributes": [],
            "name": "numseg_combine_l",
            "prop": "m <= p & p <= n + 1 --> (union {m..(minus p 1)} {p..n} = {m..n})",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat",
                "p": "nat"
            }
        },
        {
            "attributes": [],
            "name": "numseg_lrec",
            "prop": "m <= n --> {m..n} = insert m {(m+1)..n}",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "numseg_rrec",
            "prop": "m <= n + 1 --> (insert (n + 1) {m..n} = {m..(n + 1)})",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "numseg_rec",
            "prop": "m <= Suc n --> ({m..(Suc n)} = insert (Suc n) {m..n})",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "member_numseg",
            "prop": "member p {m..n} = (m <= p & p <= n)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat",
                "p": "nat"
            }
        },
        {
            "name": "member_numseg_0",
            "prop": "member p {0..n} = (p <= n)",
            "ty": "thm",
            "vars": {
                "n": "nat",
                "p": "nat"
            }
        },
        {
            "name": "numseg_empty",
            "prop": "({m..n} = empty_set) = (n < m)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [],
            "name": "numseg_emptyI",
            "prop": "n < m --> {m..n} = empty_set",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "numseg_sing",
            "prop": "{n..n} = {n}",
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "name": "inter_numseg",
            "prop": "inter {m..n} {p..q} = {(max m p)..(min n q)}",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat",
                "p": "nat",
                "q": "nat"
            }
        },
        {
            "name": "numseg_add_split",
            "prop": "m <= n + 1 --> {m..(n + p)} = union {m..n} {(n + 1)..(p + 1)}",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat",
                "p": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "hint_backward": "true",
            "name": "neutral",
            "prop": "neutral op ⟷ THE x. (∀y. op x y = y ∧ op y x = y)",
            "ty": "def",
            "type": "('a ⇒ 'a ⇒ 'a) ⇒ 'a"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "monoidal",
            "prop": [
                "monoidal op ⟷ ((∀x. ∀y. op x y = op y x) ∧ ",
                "(∀x. ∀y. ∀z. op x (op y z) = op (op x y) z) ∧ (∀x. op (neutral op) x = x))"
            ],
            "ty": "def",
            "type": "('a ⇒ 'a ⇒ 'a) ⇒ bool"
        },
        {
            "attributes": [
                "hint_backward",
                "hint_forward"
            ],
            "name": "monoidal_ac",
            "num_gaps": 2,
            "proof": [
                {
                    "args": "monoidal op",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "monoidal op ⊢ monoidal op"
                },
                {
                    "args": "monoidal_def",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_fact",
                    "th": "monoidal op ⊢ (∀x. ∀y. op x y = op y x) ∧ (∀x. ∀y. ∀z. op x (op y z) = op (op x y) z) ∧ (∀x. op (neutral op) x = x)"
                },
                {
                    "args": "conjD1, {}, {A: ∀a. ∀b. op a b = op b a, B: (∀x. ∀y. ∀z. op x (op y z) = op (op x y) z) ∧ (∀x. op (neutral op) x = x)}",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "monoidal op ⊢ ∀a. ∀b. op a b = op b a"
                },
                {
                    "args": "conjD2, {}, {A: ∀a. ∀b. op a b = op b a, B: (∀x. ∀y. ∀z. op x (op y z) = op (op x y) z) ∧ (∀x. op (neutral op) x = x)}",
                    "id": "3",
                    "prevs": [
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "monoidal op ⊢ (∀x. ∀y. ∀z. op x (op y z) = op (op x y) z) ∧ (∀x. op (neutral op) x = x)"
                },
                {
                    "args": "conjD2",
                    "id": "4",
                    "prevs": [
                        "3"
                    ],
                    "rule": "apply_theorem",
                    "th": "monoidal op ⊢ ∀x. op (neutral op) x = x"
                },
                {
                    "args": "",
                    "id": "5",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "monoidal op ⊢ ∀a. op a (neutral op) = a"
                },
                {
                    "args": "a, 'a",
                    "id": "5.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR a"
                },
                {
                    "args": "a",
                    "id": "5.1",
                    "prevs": [
                        "2"
                    ],
                    "rule": "forall_elim",
                    "th": "monoidal op ⊢ ∀y. op a y = op y a"
                },
                {
                    "args": "neutral op",
                    "id": "5.2",
                    "prevs": [
                        "5.1"
                    ],
                    "rule": "forall_elim",
                    "th": "monoidal op ⊢ op a (neutral op) = op (neutral op) a"
                },
                {
                    "args": "a",
                    "id": "5.3",
                    "prevs": [
                        "4"
                    ],
                    "rule": "apply_fact_for",
                    "th": "monoidal op ⊢ op (neutral op) a = a"
                },
                {
                    "args": "op a (neutral op) = a",
                    "id": "5.4",
                    "prevs": [
                        "5.2",
                        "5.3"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "monoidal op ⊢ op a (neutral op) = a"
                },
                {
                    "args": "",
                    "id": "5.5",
                    "prevs": [
                        "5.0",
                        "5.4"
                    ],
                    "rule": "intros",
                    "th": "monoidal op ⊢ ∀a. op a (neutral op) = a"
                },
                {
                    "args": "",
                    "id": "6",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "monoidal op ⊢ ∀a. ∀b. ∀c. op (op a b) c = op a (op b c)"
                },
                {
                    "args": "a, 'a",
                    "id": "6.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR a"
                },
                {
                    "args": "b, 'a",
                    "id": "6.1",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR b"
                },
                {
                    "args": "c, 'a",
                    "id": "6.2",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR c"
                },
                {
                    "args": "",
                    "id": "6.3",
                    "prevs": [],
                    "rule": "sorry",
                    "th": "monoidal op ⊢ op a (op b c) = op (op a b) c"
                },
                {
                    "args": "eq_sym_eq, op (op a b) c = op a (op b c)",
                    "id": "6.4",
                    "prevs": [
                        "6.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "monoidal op ⊢ op (op a b) c = op a (op b c)"
                },
                {
                    "args": "",
                    "id": "6.5",
                    "prevs": [
                        "6.0",
                        "6.1",
                        "6.2",
                        "6.4"
                    ],
                    "rule": "intros",
                    "th": "monoidal op ⊢ ∀a. ∀b. ∀c. op (op a b) c = op a (op b c)"
                },
                {
                    "args": "",
                    "id": "7",
                    "prevs": [],
                    "rule": "sorry",
                    "th": "monoidal op ⊢ ∀a. ∀b. ∀c. op a (op b c) = op b (op a c)"
                },
                {
                    "args": "conjI",
                    "id": "8",
                    "prevs": [
                        "6",
                        "7"
                    ],
                    "rule": "apply_theorem",
                    "th": "monoidal op ⊢ (∀a. ∀b. ∀c. op (op a b) c = op a (op b c)) ∧ (∀a. ∀b. ∀c. op a (op b c) = op b (op a c))"
                },
                {
                    "args": "conjI",
                    "id": "9",
                    "prevs": [
                        "2",
                        "8"
                    ],
                    "rule": "apply_theorem",
                    "th": "monoidal op ⊢ (∀a. ∀b. op a b = op b a) ∧ (∀a. ∀b. ∀c. op (op a b) c = op a (op b c)) ∧ (∀a. ∀b. ∀c. op a (op b c) = op b (op a c))"
                },
                {
                    "args": "conjI",
                    "id": "10",
                    "prevs": [
                        "5",
                        "9"
                    ],
                    "rule": "apply_theorem",
                    "th": "monoidal op ⊢ (∀a. op a (neutral op) = a) ∧ (∀a. ∀b. op a b = op b a) ∧ (∀a. ∀b. ∀c. op (op a b) c = op a (op b c)) ∧ (∀a. ∀b. ∀c. op a (op b c) = op b (op a c))"
                },
                {
                    "args": "conjI",
                    "id": "11",
                    "prevs": [
                        "4",
                        "10"
                    ],
                    "rule": "apply_theorem",
                    "th": "monoidal op ⊢ (∀a. op (neutral op) a = a) ∧ (∀a. op a (neutral op) = a) ∧ (∀a. ∀b. op a b = op b a) ∧ (∀a. ∀b. ∀c. op (op a b) c = op a (op b c)) ∧ (∀a. ∀b. ∀c. op a (op b c) = op b (op a c))"
                },
                {
                    "args": "",
                    "id": "12",
                    "prevs": [
                        "0",
                        "11"
                    ],
                    "rule": "intros",
                    "th": "⊢ monoidal op ⟶ (∀a. op (neutral op) a = a) ∧ (∀a. op a (neutral op) = a) ∧ (∀a. ∀b. op a b = op b a) ∧ (∀a. ∀b. ∀c. op (op a b) c = op a (op b c)) ∧ (∀a. ∀b. ∀c. op a (op b c) = op b (op a c))"
                }
            ],
            "prop": [
                "monoidal op",
                "--> (!a. op (neutral op) a = a) &",
                "(!a. op a (neutral op) = a) &",
                "(!a. !b. op a b = op b a) &",
                "(!a. !b. !c. op (op a b) c = op a (op b c)) &",
                "(!a. !b. !c. op a (op b c) = op b (op a c))"
            ],
            "steps": [
                {
                    "fact_ids": [
                        "0"
                    ],
                    "goal_id": "1",
                    "method_name": "rewrite_fact",
                    "theorem": "monoidal_def"
                },
                {
                    "goal_id": "2",
                    "method_name": "apply_backward_step",
                    "theorem": "conjI"
                },
                {
                    "fact_ids": [
                        "1"
                    ],
                    "goal_id": "2",
                    "method_name": "apply_forward_step",
                    "theorem": "conjD1"
                },
                {
                    "fact_ids": [
                        "1"
                    ],
                    "goal_id": "3",
                    "method_name": "apply_forward_step",
                    "theorem": "conjD2"
                },
                {
                    "fact_ids": [
                        "3"
                    ],
                    "goal_id": "4",
                    "method_name": "apply_backward_step",
                    "theorem": "conjD2"
                },
                {
                    "goal_id": "5",
                    "method_name": "apply_backward_step",
                    "theorem": "conjI"
                },
                {
                    "goal_id": "5",
                    "method_name": "introduction",
                    "names": "a"
                },
                {
                    "fact_ids": [
                        "2"
                    ],
                    "goal_id": "5.1",
                    "method_name": "forall_elim",
                    "s": "a"
                },
                {
                    "fact_ids": [
                        "5.1"
                    ],
                    "goal_id": "5.2",
                    "method_name": "forall_elim",
                    "s": "(neutral op)"
                },
                {
                    "fact_ids": [
                        "5.2"
                    ],
                    "goal_id": "5.3",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "fact_ids": [
                        "4"
                    ],
                    "goal_id": "5.3",
                    "method_name": "apply_prev"
                },
                {
                    "goal_id": "6",
                    "method_name": "apply_backward_step",
                    "theorem": "conjI"
                },
                {
                    "goal_id": "6",
                    "method_name": "apply_backward_step",
                    "theorem": "conjI"
                },
                {
                    "goal_id": "6",
                    "method_name": "introduction",
                    "names": "a,b,c"
                },
                {
                    "goal_id": "6.3",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "eq_sym_eq"
                }
            ],
            "ty": "thm",
            "vars": {
                "op": "'a => 'a => 'a"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "support",
            "prop": "support op f s = {x. x ∈ s & ~(f x = neutral op)}",
            "ty": "def",
            "type": "('a ⇒ 'a ⇒ 'a) ⇒ ('b ⇒ 'a) ⇒ 'b set ⇒ 'b set"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "iterate",
            "prop": [
                "iterate op s f =",
                "if finite (support op f s)",
                "then itset (%x. %a. op (f x) a) (support op f s) (neutral op)",
                "else neutral op"
            ],
            "ty": "def",
            "type": "('a ⇒ 'a ⇒ 'a) ⇒ 'b set ⇒ ('b ⇒ 'a) ⇒ 'a"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "sum",
            "prop": "sum = iterate (plus)",
            "ty": "def",
            "type": "'a set ⇒ ('a ⇒ real) ⇒ real"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "product",
            "prop": "product = iterate (times)",
            "ty": "def",
            "type": "'a set ⇒ ('a ⇒ real) ⇒ real"
        },
        {
            "attributes": [],
            "name": "polynomial_function",
            "prop": "polynomial_function p ⟷ (∃m. ∃c. ∀x. p x = sum ({0..m}) (λi. c i * x ^ i))",
            "ty": "def",
            "type": "(real ⇒ real) ⇒ bool"
        }
    ],
    "description": "Basic results about iterate.",
    "imports": [
        "set",
        "real"
    ],
    "name": "iterate"
}