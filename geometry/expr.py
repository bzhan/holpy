"""Expressions in geometry prover."""

import itertools, copy
from pstats import Stats
import cProfile
from typing import Tuple, Sequence, Optional, List, Dict

POINT, LINE, PonL, SEG, TRI, CIRC, CYCL, MIDP = range(8)


class Fact:
    """Represent a fact in geometry prover, e.g.:

    coll(A, C, B) is Fact("coll", ["A", "C", "B"]).

    updated: Whether this fact is generated by prover or not.
    lemma: An integer that record which rule is it required to obtain this fact (its place in ruleset).
            None represents no requirement.
    cond: A list of integers that record what facts (their place in fact list) are required to obtain this fact.
            Use "default" when initializing.
            number -1 represents no requirement.
    """

    def __init__(self, pred_name: str, args: Sequence[str], *, updated=False, lemma=None, cond=None, negation=False,
                 tail=False):
        self.pred_name = pred_name
        self.args = args

        self.updated = updated
        self.lemma = lemma
        if cond is None:
            cond = []
        self.cond = cond

        # Whether this is a negation fact. e.g.: ¬coll(O, A, B)
        self.negation = negation

        # Whether a fact is shadowed by another
        self.shadowed = False

        # For facts combined from other facts, mapping from indices in self
        # to indices to the left / right condition.
        self.left_map = None
        self.right_map = None

        # Whether the fact in the tail of a rule,
        # and its pred_name is "coll", "cyclic" or "circle".
        # In this case, this fact will be matched passively,
        # which match_expr() will only check the inst and to
        # see if exists an order of arguments conforms to inst.
        # e.g.:
        # inst = {A: E, B: F, C: G}, pat = [A, B, C], f = [G, F, E]
        # tail = True  -> Successfully matched with new_inst = {A: E, B: F, C: G}.
        # tail = False -> Match failed.
        self.tail = False

    def __hash__(self):
        return hash(("Fact", self.pred_name, tuple(self.args)))

    def __eq__(self, other):
        if isinstance(other, Fact) and self.pred_name == other.pred_name:
            if self.pred_name == 'circle':
                return self.args[0] == other.args[0] and set(self.args[1:]) == set(other.args[1:])
            elif self.pred_name in ('coll', 'cyclic'):
                return set(self.args) == set(other.args)
            else:
                return self.args == other.args

    def __str__(self):
        if self.negation:
            pre = "¬"
        else:
            pre = ""
        if self.pred_name == 'eqangle' and self.args[0].isupper():
            return pre + " = ".join(
                "∠[%s%s,%s%s]" % tuple(self.args[4 * i:4 * i + 4]) for i in range(len(self.args) // 4))
        elif self.pred_name == 'contri':
            return pre + " ≌ ".join("△%s%s%s" % tuple(self.args[3 * i:3 * i + 3]) for i in range(len(self.args) // 3))
        elif self.pred_name == 'simtri':
            return pre + " ∽ ".join("△%s%s%s" % tuple(self.args[3 * i:3 * i + 3]) for i in range(len(self.args) // 3))
        else:
            return pre + "%s(%s)" % (self.pred_name, ",".join(self.args))

    def __repr__(self):
        return str(self)

    def get_subfact(self, indices):
        if self.lemma != 'combine':
            return self
        # return self

        if all(i in self.left_map for i in indices):
            new_indices = list(self.left_map[i] for i in indices)
            return self.cond[0].get_subfact(new_indices)
        elif all(i in self.right_map for i in indices):
            new_indices = list(self.right_map[i] for i in indices)
            return self.cond[1].get_subfact(new_indices)
        else:
            return self

    def get_arg_type(self):
        """Obtain the type of arguments for the given fact.

        This is determined by the pred_name of the fact, as well as
        upper/lower case of the arguments.

        Return the argument type.

        """
        pred_name = self.pred_name

        if pred_name in ("para", "perp", "eqangle", "eqratio"):
            if self.args[0].isupper():
                return PonL
            else:
                return LINE
        elif pred_name == "coll":
            return POINT
        elif pred_name == "cong":
            return SEG
        elif pred_name == "cyclic":
            return CYCL
        elif pred_name == "circle":
            return CIRC
        elif pred_name in ("simtri", "contri"):
            return TRI
        elif pred_name == "midp":
            return MIDP
        else:
            raise NotImplementedError


class Line:
    """Represent a line contains more than one point."""

    def __init__(self, args: Sequence[str]):
        assert len(args) > 1
        self.args = set(args)

    def __hash__(self):
        return hash(("line", tuple(sorted(self.args))))

    def __eq__(self, other):
        return isinstance(other, Line) and self.args == other.args

    def __str__(self):
        return "Line(%s)" % (",".join(self.args))

    def __repr__(self):
        return str(self)

    def is_same_line(self, other):
        # Two lines are same if they have at least 2 identical points.
        return isinstance(other, Line) and len(self.args.intersection(other.args)) >= 2

    def combine(self, other):
        # If the other line refers to the same line of this line,
        # add the points of other line that are not in this line.
        assert self.is_same_line(other), "combine line"
        if self.args != other.args:
            self.args = self.args.union(other.args)


class Circle:
    """Represent a circle."""

    def __init__(self, args: Sequence[str], center=None):
        self.args = set(args)
        self.center = center

    def __hash__(self):
        return hash(("circle", self.center, tuple(sorted(self.args))))

    def __eq__(self, other):
        if self.center and other.center and self.center != other.center:
            return False
        return isinstance(other, Circle) and self.args == other.args

    def __str__(self):
        return "Circle(%s,%s)" % (self.center, ",".join(self.args))

    def __repr__(self):
        return str(self)

    def is_same_circle(self, other):
        """Two circles are the same if they have 3 or more identical points.
        If both circles have center and they have 3 or more identical points
        then two centers must be the same.
        """
        if isinstance(other, Circle) and len(self.args.intersection(other.args)) >= 3:
            if self.center and other.center:
                return self.center == other.center
            else:
                return True
        else:
            return False

    def combine(self, other):
        # If the other circle refers to the same as this circle,
        # add the points of other circle that are not in this circle.
        assert self.is_same_circle(other), "combine circle"
        if self.args != other.args:
            self.args = self.args.union(other.args)
        if other.center and not self.center:
            self.center = other.center


class Rule:
    """Represent a rule in geometry prover, e.g.:

    coll(A, C, B) :- coll(A, B, C) is
    Rule([coll(A, B, C)], coll(A, C, B))

    """

    def __init__(self, assums: Sequence[Fact], concl: Fact):
        self.assums = assums
        self.assums_pos = [a for a in self.assums if not a.negation]
        for i in range(len(self.assums_pos) - 1):
            self.assums_pos[i].tail = self.check_tail_condition(self.assums_pos[i])\
                                      and self.check_tail_condition(self.assums_pos[i + 1])
        self.assums_pos[-1].tail = self.check_tail_condition(self.assums_pos[-1])
        self.assums_neg = [a for a in self.assums if a.negation]
        self.concl = concl

    def __eq__(self, other):
        return isinstance(other, Rule) and self.assums == other.assums and self.concl == other.concl

    def __str__(self):
        return "%s :- %s" % (str(self.concl), ", ".join(str(assum) for assum in self.assums))

    def check_tail_condition(self, fact):
        return fact.pred_name in ('coll')


def make_pairs(args, pair_len=2):
    """Divide input list args into groups of length pair_len (default 2)."""
    assert len(args) % pair_len == 0
    return [tuple(args[pair_len * i: pair_len * (i + 1)]) for i in range(len(args) // pair_len)]


class Prover:
    def __init__(self, ruleset: Dict, hyps: Optional[List[Fact]] = None, concl: Fact = None, lines=None, circles=None):
        self.ruleset = ruleset
        if hyps is None:
            hyps = []
        self.hyps = hyps
        self.classfied_hyps = {"para": [], "coll": [], "cong": [], "midp": [], "perp": [],
                               "eqangle": [], "eqratio": [], "cyclic": [], "circle": [], "simtri": [], "contri": []}
        for hyp in hyps:
            self.classfied_hyps[hyp.pred_name].append(hyp)
        self.concl = concl
        if lines is None:
            lines = []
        self.lines = lines
        if circles is None:
            circles = []
        self.circles = circles

    def equal_pair(self, p1, p2) -> bool:
        return p1 == p2 or p1 == (p2[1], p2[0])

    def equal_line(self, p1, p2) -> bool:
        return self.get_line(p1) == self.get_line(p2)

    def equal_angle(self, a1, a2) -> bool:
        p1, p2 = a1[0:2], a1[2:4]
        q1, q2 = a2[0:2], a2[2:4]
        return self.get_line(p1) == self.get_line(q1) and self.get_line(p2) == self.get_line(q2)

    def equal_triangle(self, t1, t2) -> bool:
        return set(t1) == set(t2)

    def get_line(self, pair: Tuple[str]) -> Line:
        """Return a line from lines containing the given pair of points, if
        it exists. Otherwise return a line containing the pair.
        
        Examples:

        get_line([Line(P,Q,R)], (P, Q)) -> Line(P,Q,R)
        get_line([Line(P,Q,R)], (O, P)) -> Line(O,P)

        """
        assert len(pair) == 2

        new_line = Line(list(pair))
        for line in self.lines:
            if line.is_same_line(new_line):
                return line

        return new_line

    def get_circle(self, points: Sequence[str], center: Optional[str] = None) -> Circle:
        """Return a circle from circles containing the given points and center (optional),
        if it exists. Otherwise return a circle containing the points and center (optional).

        """
        new_circle = Circle(points, center=center)
        for circle in self.circles:
            if new_circle.is_same_circle(circle):
                return circle

        return new_circle

    def match_expr(self, pat: Fact, f: Fact, inst) -> List[Tuple[Dict, Fact]]:
        """Match pattern with f, return a list of result(s).

        inst is a dictionary that assigns point variables to points,
        and line variables to pairs of points.

        lines: list of currently known lines.

        Multiple results will be generated if a line and two points on it
        need to be matched simultaneously.

        Example:

        match(coll(A, B, C), coll(P, Q, R), {}) -> [{A: P, B: Q, C: R}].
        match(coll(A, B, C), coll(P, Q, R), {A: P}) -> [{A: P, B: Q, C: R}].
        match(coll(A, B, C), coll(P, Q, R), {A: Q}) -> [].
        match(coll(A, B, C), para(P, Q, R, S), {}) -> [].

        match(perp(l, m), perp(P, Q, R, S), {}) -> [{l: (P, Q), m: (R, S)}]
        match(perp(l, m), perp(P, Q, R, S), {l: (Q, P)}) -> [{l: (Q, P), m: (R, S)}]
        match(perp(l, m), perp(P, Q, R, S), {l: (O, P)}, lines=[Line(O, P, Q)]) -> [{l: (O, P), m: (R, S)}]
        match(perp(l, m), perp(P, Q, R, S), {l: (O, P)}) -> [].

        """

        def match_PonL(cs):
            t_insts = [inst]
            i = 0
            while i < len(pat.args) // 2:
                ts = []
                for t_inst in t_insts:
                    l = self.get_line(cs[i])
                    pat_a, pat_b = pat.args[i * 2: i * 2 + 2]
                    if pat_a in t_inst:
                        if t_inst[pat_a] in l.args:
                            a = [t_inst[pat_a]]
                        else:
                            a = []
                    else:
                        a = list(l.args)
                    if pat_b in t_inst:
                        if t_inst[pat_b] in l.args:
                            b = [t_inst[pat_b]]
                        else:
                            b = []
                    else:
                        b = list(l.args)
                    perms = [[x, y] for x in a for y in b if x != y]
                    for a, b in perms:
                        t = copy.copy(t_inst)  # t is one result
                        t[pat_a], t[pat_b] = a, b
                        ts.append(t)
                i += 1
                t_insts = ts
            return t_insts

        def match_circle_post(pat_args, f_args, c_args, flag):
            """Identical part of the processing for circ and cycl cases.
            
            flag -- whether the matching has already failed.

            """
            fixed = []  # arguments in pattern that are also in inst.
            same_args = list(set(pat_args).intersection(set(inst.keys())))
            for same_arg in same_args:
                if inst[same_arg] in c_args:
                    fixed.append(same_arg)
                else:
                    flag = True
            if not flag:  # start matching
                for_comb = sorted(list(c_args - set(inst.values())))
                if len(f_args) - len(fixed) > 0:
                    # Order is not considered.
                    comb = itertools.permutations(range(len(for_comb)), len(f_args) - len(fixed))
                    for c_nums in comb:
                        item = [for_comb[num] for num in c_nums]
                        p = 0
                        for i in range(len(pat_args)):
                            if pat_args[i] in fixed:
                                continue
                            inst[pat_args[i]] = item[p]
                            p += 1
                        new_insts.append((copy.copy(inst), f))
                else:  # remain previous insts and sources
                    new_insts.append((inst, f))

        def can_assign(pat, arg):
            # For case MIDP and case SEG.
            return pat not in t_inst or t_inst[pat] == arg

        if pat.pred_name != f.pred_name:
            return []

        if pat.tail:
            # Get matching result from inst directly.
            if not all(p in inst.keys() for p in pat.args):
                return []
            else:
                return [(inst, f.get_subfact([0]))]

        arg_ty = pat.get_arg_type()
        new_insts = []

        if arg_ty == POINT:
            # coll or midp case
            # Generating all possible combinations from long fact:
            comb = itertools.combinations(range(len(f.args)), len(pat.args))
            for c_nums in comb:
                c = [f.args[num] for num in c_nums]
                t_inst = copy.copy(inst)
                flag = False
                for p_arg, t_arg in zip(pat.args, c):
                    if p_arg in t_inst:
                        if t_arg != t_inst[p_arg]:
                            flag = True
                    else:
                        t_inst[p_arg] = t_arg
                if not flag:
                    new_insts.append((t_inst, f.get_subfact(c_nums)))

        elif arg_ty == MIDP:
            # match point in the middle (exchange is no possible)
            t_inst = copy.copy(inst)
            flag = False
            if pat.args[0] in t_inst:
                if f.args[0] != t_inst[pat.args[0]]:
                    flag = True
            else:
                t_inst[pat.args[0]] = f.args[0]
            # match other points, which are two sides of a segment (exchange available)
            if not flag:
                # case: not exchange
                if can_assign(pat.args[1], f.args[1]) and can_assign(pat.args[2], f.args[2]):
                    t = copy.copy(t_inst)
                    t[pat.args[1]] = f.args[1]
                    t[pat.args[2]] = f.args[2]
                    new_insts.append((t, f.get_subfact([0])))
                # case: exchange
                if can_assign(pat.args[1], f.args[2]) and can_assign(pat.args[2], f.args[1]):
                    t = copy.copy(t_inst)
                    t[pat.args[1]] = f.args[2]
                    t[pat.args[2]] = f.args[1]
                    new_insts.append((t, f.get_subfact([0])))

        elif arg_ty == LINE:
            # para, perp, eqangle or eqratio case, matching lines
            if f.pred_name in ("eqangle", "eqratio"):
                groups = make_pairs(f.args, pair_len=4)
                comb = itertools.combinations(range(len(groups)), len(pat.args) // 2)  # all possibilities
            else:
                groups = make_pairs(f.args)
                comb = itertools.permutations(range(len(groups)), len(pat.args))

            for c_nums in comb:
                if f.pred_name in ("eqangle", "eqratio"):
                    cs = [groups[c_nums[0]][0:2], groups[c_nums[0]][2:4], groups[c_nums[1]][0:2],
                          groups[c_nums[1]][2:4]]
                else:
                    cs = [groups[num] for num in c_nums]
                t_inst = copy.copy(inst)
                flag = False
                for p_arg, t_args in zip(pat.args, cs):
                    if p_arg in t_inst:
                        l1 = self.get_line(t_inst[p_arg])
                        l2 = self.get_line(t_args)
                        if l1 != l2:
                            flag = True
                    else:
                        t_inst[p_arg] = t_args
                if not flag:
                    new_insts.append((t_inst, f.get_subfact(c_nums)))

        elif arg_ty == SEG:
            # eqratio or cong case
            # Possible to assign t_inst[pat] to arg

            new_insts = []
            groups = make_pairs(f.args)
            comb = itertools.combinations(range(len(groups)), len(pat.args) // 2)
            for c_nums in comb:
                c = [groups[num] for num in c_nums]
                t_insts = [inst]
                for i in range(len(pat.args) // 2):
                    ts = []
                    for t_inst in t_insts:
                        pat_a, pat_b = pat.args[2 * i: 2 * i + 2]
                        if can_assign(pat_a, c[i][0]) and can_assign(pat_b, c[i][1]):
                            t = copy.copy(t_inst)
                            t[pat_a] = c[i][0]
                            t[pat_b] = c[i][1]
                            ts.append(t)
                        if can_assign(pat_a, c[i][1]) and can_assign(pat_b, c[i][0]):
                            t = copy.copy(t_inst)
                            t[pat_a] = c[i][1]
                            t[pat_b] = c[i][0]
                            ts.append(t)
                    t_insts = ts
                if t_insts:
                    subfact = f.get_subfact(c_nums)
                for t_inst in t_insts:
                    new_insts.append((t_inst, subfact))

        elif arg_ty == TRI:
            # contri and simtri case
            groups = make_pairs(f.args, pair_len=3)
            comb = itertools.combinations(range(len(groups)), len(pat.args) // 3)
            # indices: assign which char in the group to assign to pattern.
            # E.g.
            # indices:  0,  2,  1
            # pat.args: A,  B,  C
            #           ↓    ↙ ↘ 　
            # group:    E,  F,  G
            # matched:  {A: E, B: F, C: G}
            #
            indices_list = [[0, 1, 2], [0, 2, 1], [1, 2, 0]]
            new_insts = []
            for c_nums in comb:
                cs = [groups[num] for num in c_nums]

                for indices in indices_list:
                    flag = False
                    t_inst = copy.copy(inst)
                    for i in range(len(cs)):
                        for j in range(3):
                            if pat.args[i * 3 + j] in t_inst:
                                if cs[i][indices[j]] != t_inst[pat.args[i * 3 + j]]:
                                    flag = True
                            else:
                                t_inst[pat.args[i * 3 + j]] = cs[i][indices[j]]
                    if not flag:
                        new_insts.append((t_inst, f.get_subfact(c_nums)))

        elif arg_ty == PonL:
            # para, perp, or eqangle, matching points

            # Generate possible lines selections (two lines in one selection).
            if f.pred_name == "eqangle":
                groups = make_pairs(f.args, pair_len=4)
                comb = itertools.combinations(range(len(groups)), len(pat.args) // 4)
            else:
                groups = make_pairs(f.args)
                comb = itertools.combinations(range(len(groups)), len(pat.args) // 2)

            for c_nums in comb:
                if f.pred_name == "eqangle":
                    cs = [groups[c_nums[0]][0:2], groups[c_nums[0]][2:4], groups[c_nums[1]][0:2],
                          groups[c_nums[1]][2:4]]
                else:
                    cs = [groups[num] for num in c_nums]

                t_insts = match_PonL(cs)

                if t_insts:
                    subfact = f.get_subfact(c_nums)
                for t_inst in t_insts:
                    new_insts.append((t_inst, subfact))

        elif arg_ty == CYCL:
            circle = self.get_circle(list(f.args))
            flag = False
            match_circle_post(pat.args, f.args, circle.args, flag)

        elif arg_ty == CIRC:
            circle = self.get_circle(f.args[1:], f.args[0])
            flag = False
            if pat.args[0] in inst and inst[pat.args[0]] != f.args[0]:
                flag = True
            else:
                inst[pat.args[0]] = f.args[0]
            match_circle_post(pat.args[1:], f.args[1:], circle.args, flag)
        else:
            raise NotImplementedError

        return new_insts

    def get_appliable_facts(self, rule: Rule) -> List[Fact]:
        def pick_appliable_facts_step(rule: Rule, facts: List[Fact]) -> None:
            if len(facts) < len(rule.assums_pos):
                for fact in self.classfied_hyps[rule.assums[len(facts)].pred_name]:
                    if fact in facts or fact.shadowed:
                        continue
                    new_facts = copy.copy(facts)
                    new_facts.append(fact)
                    pick_appliable_facts_step(rule, new_facts)
            else:
                picked.append(facts)

        picked = []
        pick_appliable_facts_step(rule, [])
        return picked

    def set_classfied_hyps_foreach(self, fun, *args):
        for item in self.classfied_hyps.values():
            for i in item:
                fun(i, *args)

    def check_classfied_hyps_foreach(self, fun, *args) -> bool:
        ''' Return false if exists one or more hyp in all hyps
        that is not satisfied the given function.
        '''
        for item in self.classfied_hyps.values():
            for i in item:
                if not fun(i, *args):
                    return False
        return True

    def check_redundant(self, hyp, fact) -> bool:
        return not(not hyp.shadowed and self.check_imply(hyp, fact))

    def check_imply_reverse(self, goal, fact) -> bool:
        return not self.check_imply(fact, goal)

    def set_shadow_fact(self, target, fact, new_facts):
        if not target.shadowed and self.check_imply(fact, target):
            target.shadowed = True

        if not target.shadowed:
            new_fact = self.combine_facts(fact, target)
            if new_fact:
                fact.shadowed = True
                target.shadowed = True
                fact = new_fact
                new_facts.append(new_fact)

    def apply_rule(self, rule_name: str, facts: Sequence[Fact]) -> None:
        # pr = cProfile.Profile()
        # pr.enable()
        """Apply given rule to the list of facts.

        If param facts is a list of integers: these integers represents the positions in hyps. In this case,
        hyps must be a list of facts. The new facts generated by this function will combine to hyps
        automatically. Function returns nothing.

        If param facts is a list of facts: New facts will be returned.

        Example:
        apply_rule(
            Rule([para(A, B, C, D), para(C, D, E, F)], para(A, B, E, F)),
                [para(P, Q, R, S), para(R, S, U, V)])
        -> para(P, Q, U, V).

        apply_rule(
            Rule([coll(A, B, C)], coll(A, C, B)),
                [para(A, B, D, C)])
        -> [].
        """
        rule = self.ruleset[rule_name]
        assert len(facts) == len(rule.assums_pos)
        # print("try", rule, facts)

        # When trying to obtain contri or simtri from eqangles,
        # There exists the scenario that we need to "flip" one triangle to make its shape as same as
        # another triangle. But the full-angle of the triangle will be changed when "flipping".
        # (The general type angle will not be changed after "flipping")
        # E.g.
        # Original: eqangle(A, B, C, D, E, F, G, H)
        # Flipped:  eqangle(C, D, A, B, E, F, G, H)

        # Match positive facts. Save matching result in insts.
        insts = [(dict(), [])]  # type: List[Tuple[Dict, List[Fact]]]
        for i, (assum, fact) in enumerate(zip(rule.assums_pos, facts)):  # match the arguments recursively
            new_insts = []
            # flip = fact.pred_name == 'eqangle' and rule.concl.pred_name in ('simtri', 'contri')
            for inst, subfacts in insts:
                news = self.match_expr(assum, fact, inst)
                for i, subfact in news:
                    new_insts.append((i, subfacts + [subfact]))
            insts = new_insts

        # Rule D40 requires more points in conclusion than in assumption. Add points from lines as supplement.
        if rule_name in ("D40", "D90") and insts:
            prev_insts = copy.copy(insts)
            insts = []
            if any(i not in prev_insts[0][0].keys() for i in rule.concl.args):
                for inst, subfacts in prev_insts:
                    not_match = set(rule.concl.args) - set(inst.keys())
                    for line in self.lines:
                        extended_t_inst = copy.copy(inst)
                        for i, ch in enumerate(not_match):
                            extended_t_inst[ch] = (list(line.args)[i], list(line.args)[i + 1])
                        insts.append((extended_t_inst, subfacts))

        # Get new facts, according to insts
        for inst, subfacts in insts:
            # Get correct form of arguments in a fact
            if rule.concl.args[0].islower():
                concl_args = []  # type: List[str]
                for i in rule.concl.args:
                    concl_args.extend((inst[i][0], inst[i][1]))
            else:
                concl_args = [inst[i] for i in rule.concl.args]

            # Generate new fact
            fact = Fact(rule.concl.pred_name, concl_args, updated=True, lemma=rule_name, cond=subfacts)

            if self.check_trivial(fact):
                continue

            if self.check_irrational(fact):
                continue

            if not self.check_classfied_hyps_foreach(self.check_redundant, fact):
                continue

            # Check if those assums with negation are satisfied.
            # If not satisfied, all of the post processes will not be conducted.
            fact_valid = True
            if len(rule.assums_neg) > 0:
                for assum in rule.assums_neg:
                    # Get a fact from assum.
                    if assum.args[0].islower():
                        tmp_args = []  # type: List[str]
                        for i in assum.args:
                            tmp_args.append(inst[i][0])
                    else:
                        tmp_args = [inst[i][0] for i in assum.args]
                    tmp_fact = Fact(assum.pred_name, tmp_args, negation=True)
                    # Check if exist a fact that can imply the negation assum.
                    fact_valid = self.check_classfied_hyps_foreach(self.check_imply_reverse, tmp_fact)

            if not fact_valid:
                continue

            new_facts = [fact]
            for target in self.classfied_hyps[fact.pred_name]:
                    if not target.shadowed and self.check_imply(fact, target):
                        target.shadowed = True
                    if not target.shadowed:
                        new_fact = self.combine_facts(fact, target)
                        if new_fact:
                            fact.shadowed = True
                            target.shadowed = True
                            fact = new_fact
                            new_facts.append(new_fact)
            self.hyps.extend(new_facts)
            for new_fact in new_facts:
                # if new_fact.pred_name in ('simtri', 'contri', 'eqangle'):
                #     print("new fact:", new_fact, rule, facts)
                self.classfied_hyps[new_fact.pred_name].append(new_fact)
        # p = Stats(pr)
        # p.strip_dirs()
        # p.sort_stats('cumtime')
        # p.print_stats()

    def compute_lines(self):
        self.lines = []
        for hyp in self.classfied_hyps['coll']:
            if not hyp.shadowed:
                self.lines.append(Line(hyp.args))

    def compute_circles(self):
        self.circles = []
        for hyp in self.classfied_hyps['cyclic']:
            if not hyp.shadowed:
                self.circles.append(Circle(hyp.args))
        for hyp in self.classfied_hyps['circle']:
            if not hyp.shadowed:
                self.circles.append(Circle(hyp.args[1:], center=hyp.args[0]))

    def compute_angles(self):
        pass

    def search_step(self, only_updated=False) -> None:
        """One step of searching fixpoint.

        Apply given ruleset to a list of hypotheses to obtain new facts.
        If collinear facts are included in hypotheses, new lines can be
        automatically generated, these new lines might be used when
        applying rules to hypotheses.

        """
        self.compute_lines()
        self.compute_circles()

        avail_hyps = [hyp for hyp in self.hyps if not hyp.shadowed]
        for rule_name, rule in self.ruleset.items():
            # print("getting...")
            appliable_facts_list = self.get_appliable_facts(rule)
            # print(rule, appliable_facts_list)
            # print("applying...")
            for facts in appliable_facts_list:
                if any(fact.shadowed for fact in facts):
                    continue
                if only_updated and all(not fact.updated for fact in facts):
                    continue
                # print("applying...")
                self.apply_rule(rule_name, facts)
            # for facts in itertools.permutations(avail_hyps, len(rule.assums_pos)):
            #     if any(fact.shadowed for fact in facts):
            #         continue
            #     if only_updated and all(not fact.updated for fact in facts):
            #         continue
            #     self.apply_rule(rule_name, facts)

    def search_fixpoint(self) -> Optional[Fact]:
        """Recursively apply given ruleset to a list of hypotheses to
        obtain new facts. Recursion exits when new fact is not able
        to be generated, or conclusion is in the list of facts.
        Return the list of facts.
        """
        prev_len = len(self.hyps)
        self.search_step()
        steps = 0
        self.print_hyps(only_not_shadowed=True)
        print(self.lines)
        while steps < 5:
            steps += 1
            print("Step", steps)
            # print(list(hyp for hyp in hyps if not hyp.shadowed))
            prev_len = len(self.hyps)
            self.search_step(only_updated=True)

            for item in self.classfied_hyps.values():
                for i in item:
                    if self.check_imply(i, self.concl):
                        self.print_hyps(only_not_shadowed=True)
                        return i
            self.print_hyps(only_not_shadowed=True)
            print(self.lines)

        return False

    def combine_facts(self, fact, goal) -> Optional[Fact]:
        """
        Combine this fact to other fact.
        Return a combined long fact if succeed.

        """
        if fact.pred_name != goal.pred_name:
            return None

        def get_indices(l, l_comb, comp=None):
            res = dict()
            for i, p in enumerate(l):
                found = False
                for j, q in enumerate(l_comb):
                    if (comp is None and p == q) or (comp is not None and comp(p, q)):
                        res[j] = i
                        found = True
                        break
                assert found
            return res

        if fact.pred_name == 'perp':
            # No combination
            return None

        elif fact.pred_name == 'coll':
            l1, l2 = Line(fact.args), Line(goal.args)
            if l1.is_same_line(l2):
                l1.combine(l2)
                f = Fact('coll', list(l1.args), updated=True, lemma='combine', cond=[fact, goal])
                f.left_map = get_indices(l1.args, f.args)
                f.right_map = get_indices(l2.args, f.args)
                return f
            else:
                return None

        elif fact.pred_name == 'circle':
            c1, c2 = Circle(fact.args[1:], center=fact.args[0]), Circle(goal.args[1:], center=fact.args[0])

            if c1.is_same_circle(c2):
                c1.combine(c2)
                f = Fact('circle', [c1.center] + list(c1.args), updated=True, lemma='combine', cond=[fact, goal])
                f.left_map = get_indices(c1.args, f.args)
                f.right_map = get_indices(c2.args, f.args)
                return f
            else:
                return None

        elif fact.pred_name == 'cyclic':
            c1, c2 = Circle(fact.args), Circle(goal.args)

            if c1.is_same_circle(c2):
                c1.combine(c2)
                f = Fact('cyclic', list(c1.args), updated=True, lemma='combine', cond=[fact, goal])
                f.left_map = get_indices(c1.args, f.args)
                f.right_map = get_indices(c2.args, f.args)
                return f
            else:
                return None

        elif fact.pred_name == 'cong':
            # Check if any pair of points in fact and goal are the same
            # (exchange is allowed)
            can_combine = False
            f_pairs = make_pairs(fact.args)
            g_pairs = make_pairs(goal.args)
            if any(self.equal_pair(p1, p2) for p1 in f_pairs for p2 in g_pairs):
                new_args = []  # type: List[str]
                for p1 in f_pairs:
                    new_args.extend(p1)
                for p2 in g_pairs:
                    if not any(self.equal_pair(p1, p2) for p1 in f_pairs):
                        new_args.extend(p2)
                f = Fact('cong', new_args, updated=True, lemma="combine", cond=[fact, goal])
                p_comb = make_pairs(new_args)
                f.left_map = get_indices(f_pairs, p_comb, self.equal_pair)
                f.right_map = get_indices(g_pairs, p_comb, self.equal_pair)
                return f
            else:
                return None

        elif fact.pred_name == 'para':
            # Check if any pair of points in fact and goal denote the same line
            can_combine = False
            f_pairs = make_pairs(fact.args)
            g_pairs = make_pairs(goal.args)
            if any(self.equal_line(p1, p2) for p1 in f_pairs for p2 in g_pairs):
                new_args = []
                for p1 in f_pairs:
                    new_args.extend(p1)
                for p2 in g_pairs:
                    if not any(self.equal_line(p1, p2) for p1 in f_pairs):
                        new_args.extend(p2)
                f = Fact('para', new_args, updated=True, lemma="combine", cond=[fact, goal])
                p_comb = make_pairs(new_args)
                f.left_map = get_indices(f_pairs, p_comb, self.equal_line)
                f.right_map = get_indices(g_pairs, p_comb, self.equal_line)
                return f
            else:
                return None

        elif fact.pred_name in ('eqangle', 'eqratio'):
            # Check if any 4-tuple of points in fact and goal denote the same angle
            can_combine = False
            f_angles = make_pairs(fact.args, pair_len=4)
            g_angles = make_pairs(goal.args, pair_len=4)
            if any(self.equal_angle(a1, a2) for a1 in f_angles for a2 in g_angles):
                new_args = []
                for a1 in f_angles:
                    new_args.extend(a1)
                for a2 in g_angles:
                    if not any(self.equal_angle(a1, a2) for a1 in f_angles):
                        new_args.extend(a2)
                f = Fact(fact.pred_name, new_args, updated=True, lemma="combine", cond=[fact, goal])
                p_comb = make_pairs(new_args, pair_len=4)
                f.left_map = get_indices(f_angles, p_comb, self.equal_angle)
                f.right_map = get_indices(g_angles, p_comb, self.equal_angle)
                return f
            else:
                return None

        elif fact.pred_name in ('simtri', 'contri'):
            f_tris = make_pairs(fact.args, pair_len=3)
            g_tris = make_pairs(goal.args, pair_len=3)
            for t1 in f_tris:
                for t2 in g_tris:
                    if set(t1) == set(t2):
                        order = []
                        for i in range(0, 3):
                            for j in range(0, 3):
                                if t1[i] == t2[j]:
                                    order.append(j)
                                    break
                        new_args = []
                        for t1 in f_tris:
                            new_args.extend(t1)
                        for t2 in g_tris:
                            if not any(set(t1) == set(t2) for t1 in f_tris):
                                for i in range(0, 3):
                                    # print(order)
                                    new_args.append(t2[order[i]])
                        f = Fact(fact.pred_name, new_args, updated=True, lemma="combine", cond=[fact, goal])
                        p_comb = make_pairs(new_args, pair_len=3)
                        f.left_map = get_indices(f_tris, p_comb, self.equal_triangle)
                        f.right_map = get_indices(g_tris, p_comb, self.equal_triangle)
                        # print("-----".join(["combined: ", str(fact), str(goal), str(f)]))
                        return f
            return None

        elif fact.pred_name == 'midp':
            return None

        else:
            raise NotImplementedError

    def check_trivial(self, fact) -> bool:
        """Check whether the given fact is trivial."""
        if fact.pred_name == 'cong':
            pairs = make_pairs(fact.args)
            for p1, p2 in itertools.permutations(pairs, 2):
                if self.equal_pair(p1, p2):
                    return True
            return False

        elif fact.pred_name == 'para':
            pairs = make_pairs(fact.args)
            for p1, p2 in itertools.permutations(pairs, 2):
                if self.equal_line(p1, p2):
                    return True
            return False

        elif fact.pred_name in ('eqangle', 'eqratio'):
            angles = make_pairs(fact.args, pair_len=4)
            for a1, a2 in itertools.permutations(angles, 2):
                if self.equal_angle(a1, a2):
                    return True
            return False

        return False

    def check_irrational(self, fact) -> bool:
        if fact.pred_name in ("circle", "cyclic"):
            return len(set(fact.args)) < 4
        if fact.pred_name in ("para", "cong", "perp"):
            args = fact.args
            return args[0] == args[1] or args[2] == args[3] or (args[0] + args[1] == args[2] + args[3])
        if fact.pred_name in ("eqangle", "eqratio"):
            args = fact.args
            groups = make_pairs(args)
            for g in groups:
                if g[0] == g[1]:
                    return False
            return args[0] + args[1] == args[2] + args[3] or args[4] + args[5] == args[6] + args[7] \
                or (args[0] + args[1] == args[6] + args[7] and args[2] + args[3] == args[4] + args[5])
        if fact.pred_name in ("simtri", "contri"):
            return len(set(fact.args[0:3])) < 3 or len(set(fact.args[3:6])) < 3
        return False

    def check_imply(self, fact, goal) -> bool:
        """Check whether the given fact is able to imply the given goal."""
        if fact.pred_name != goal.pred_name:
            return False

        if fact.pred_name == "perp":
            # Check the two lines are the same
            f1, f2 = make_pairs(fact.args)
            g1, g2 = make_pairs(goal.args)
            return self.equal_line(f1, g1) and self.equal_line(f2, g2)

        elif fact.pred_name == 'coll':
            # Whether points in goal is a subset of points in fact
            return set(goal.args).issubset(set(fact.args))

        elif fact.pred_name == 'circle':
            # Whether the centers are the same, and other points in goal
            # is a subset of points in fact
            return fact.args[0] == goal.args[0] and set(goal.args[1:]).issubset(set(fact.args[1:]))

        elif fact.pred_name == 'cyclic':
            # Whether points in goal is a subset of points in fact
            return set(goal.args).issubset(set(fact.args))

        elif fact.pred_name == 'cong':
            # Check whether both segments in goal are in fact.
            f_pairs = make_pairs(fact.args)
            g_pairs = make_pairs(goal.args)
            return all(any(self.equal_pair(f, g) for f in f_pairs) for g in g_pairs)

        elif fact.pred_name == 'para':
            # Check whether both lines in goal are in fact.
            f_pairs = make_pairs(fact.args)
            g_pairs = make_pairs(goal.args)
            return all(any(self.equal_line(f, g) for f in f_pairs) for g in g_pairs)

        elif fact.pred_name in ("eqangle", "eqratio"):
            # Check whether both angles in goal are in fact.
            f_angles = make_pairs(fact.args, pair_len=4)
            g_angles = make_pairs(goal.args, pair_len=4)
            return all(any(self.equal_angle(f, g) for f in f_angles) for g in g_angles)

        elif fact.pred_name in ("simtri", "contri"):
            # Check whether both triangles in goal are in fact.
            f_tris = make_pairs(fact.args, pair_len=3)
            g_tris = make_pairs(goal.args, pair_len=3)
            return all(any(self.equal_triangle(f, g) for f in f_tris) for g in g_tris)

        elif fact.pred_name == "midp":
            return fact.args[0] == goal.args[0] and set(fact.args[1:]) == set(goal.args[1:])

        else:
            print(fact.pred_name)
            raise NotImplementedError

    def print_hyps(self, only_not_shadowed=False) -> None:
        s = ""
        count = 0
        for category in self.classfied_hyps.values():
            if len(category) == 0:
                continue
            for fact in category:
                if only_not_shadowed and fact.shadowed:
                    continue
                s = s + str(fact) + " ||| "
                count += 1
        if only_not_shadowed:
            print("Current not shadowed hyps (" + str(count) + "): ")
        else:
            print("Current all hyps (" + str(count) + "): ")
        lines = len(s) // 200
        if lines > 0:
            for line in range(0, lines):
                print(s[line * 200: line * 200 + 200])
            print(s[lines * 200:-5])
        else:
            print(s[:-5])

    def print_search(self, res) -> None:
        """Print the process of searching fixpoint.
        The given list of facts must contains all the deduce procedures
        (as parameters of facts in the list). Using a given ruleset to
        find out the name of rules used in deduce procedures.

        """
        print_list = []  # type: List[Fact]

        def rec(fact):
            if fact in print_list:
                return

            for cond in fact.cond:
                rec(cond)
            print_list.append(fact)

        rec(res)

        for fact in print_list:
            if fact.lemma == 'combine':
                print('combine', fact)
            elif fact.lemma:
                print('(' + str(self.ruleset[fact.lemma]) + ')', fact, ':-', ', '.join(str(cond) for cond in fact.cond))
