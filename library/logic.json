[
    {
        "proof": [
            {
                "prevs": [],
                "args": "A ∧ B",
                "rule": "assume",
                "id": "A1",
                "th": "A ∧ B ⊢ A ∧ B"
            },
            {
                "prevs": [
                    "A1"
                ],
                "args": "conjD2, {A: A, B: B}",
                "rule": "apply_theorem_for",
                "id": "S1",
                "th": "A ∧ B ⊢ B"
            },
            {
                "prevs": [
                    "A1"
                ],
                "args": "conjD1, {A: A, B: B}",
                "rule": "apply_theorem_for",
                "id": "S2",
                "th": "A ∧ B ⊢ A"
            },
            {
                "prevs": [
                    "S1",
                    "S2"
                ],
                "args": "conjI, {A: B, B: A}",
                "rule": "apply_theorem_for",
                "id": "S3",
                "th": "A ∧ B ⊢ B ∧ A"
            },
            {
                "prevs": [
                    "S3"
                ],
                "args": "A ∧ B",
                "rule": "implies_intr",
                "id": "S4",
                "th": "⊢ A ∧ B ⟶ B ∧ A"
            }
        ],
        "num_gaps": 0,
        "prop": "A & B --> B & A",
        "instructions": [
            "Select S1 as goal, use Ctrl+B with conjI",
            "Select S1 as goal and A1 as fact, use Ctrl+B with conjD2.",
            "Select S2 as goal and A1 as fact, use Ctrl+B with conjD1."
        ],
        "ty": "thm",
        "vars": {
            "B": "bool",
            "A": "bool"
        },
        "name": "conj_comm"
    },
    {
        "proof": [
            {
                "prevs": [],
                "args": "A ∨ B",
                "rule": "assume",
                "id": "A1",
                "th": "A ∨ B ⊢ A ∨ B"
            },
            {
                "prevs": [],
                "args": "A",
                "rule": "assume",
                "id": "S1",
                "th": "A ⊢ A"
            },
            {
                "prevs": [
                    "S1"
                ],
                "args": "disjI2, {A: B, B: A}",
                "rule": "apply_theorem_for",
                "id": "S2",
                "th": "A ⊢ B ∨ A"
            },
            {
                "prevs": [
                    "S2"
                ],
                "args": "A",
                "rule": "implies_intr",
                "id": "S3",
                "th": "A ∨ B ⊢ A ⟶ B ∨ A"
            },
            {
                "prevs": [],
                "args": "B",
                "rule": "assume",
                "id": "S4",
                "th": "B ⊢ B"
            },
            {
                "prevs": [
                    "S4"
                ],
                "args": "disjI1, {A: B, B: A}",
                "rule": "apply_theorem_for",
                "id": "S5",
                "th": "B ⊢ B ∨ A"
            },
            {
                "prevs": [
                    "S5"
                ],
                "args": "B",
                "rule": "implies_intr",
                "id": "S6",
                "th": "A ∨ B ⊢ B ⟶ B ∨ A"
            },
            {
                "prevs": [
                    "A1",
                    "S3",
                    "S6"
                ],
                "args": "disjE, {A: A, B: B, C: B ∨ A}",
                "rule": "apply_theorem_for",
                "id": "S7",
                "th": "A ∨ B ⊢ B ∨ A"
            },
            {
                "prevs": [
                    "S7"
                ],
                "args": "A ∨ B",
                "rule": "implies_intr",
                "id": "S8",
                "th": "⊢ A ∨ B ⟶ B ∨ A"
            }
        ],
        "num_gaps": 0,
        "prop": "A | B --> B | A",
        "name": "disj_comm",
        "ty": "thm",
        "vars": {
            "B": "bool",
            "A": "bool"
        },
        "instructions": [
            "Select S1 as goal and A1 as fact, use Ctrl+B with disjE.",
            "Select S1 as goal, use Ctrl+I.",
            "Select S2 as goal and S1 as fact, use Ctrl+B with disjI2.",
            "Select S4 as goal, use Ctrl+I.",
            "Select S5 as goal and S4 as fact, use Ctrl+B with disjI1."
        ]
    },
    {
        "proof": [
            {
                "prevs": [],
                "args": "¬¬A",
                "rule": "assume",
                "id": "A1",
                "th": "¬¬A ⊢ ¬¬A"
            },
            {
                "prevs": [],
                "args": "classical",
                "rule": "theorem",
                "id": "S1",
                "th": "⊢ A ∨ ¬A"
            },
            {
                "prevs": [],
                "args": "A",
                "rule": "assume",
                "id": "S2",
                "th": "A ⊢ A"
            },
            {
                "prevs": [
                    "S2"
                ],
                "args": "A",
                "rule": "implies_intr",
                "id": "S3",
                "th": "¬¬A ⊢ A ⟶ A"
            },
            {
                "prevs": [],
                "args": "¬A",
                "rule": "assume",
                "id": "S4",
                "th": "¬A ⊢ ¬A"
            },
            {
                "prevs": [
                    "A1",
                    "S4"
                ],
                "args": "negE, {A: ¬A}",
                "rule": "apply_theorem_for",
                "id": "S5",
                "th": "¬A, ¬¬A ⊢ false"
            },
            {
                "prevs": [
                    "S5"
                ],
                "args": "falseE, {A: A}",
                "rule": "apply_theorem_for",
                "id": "S6",
                "th": "¬A, ¬¬A ⊢ A"
            },
            {
                "prevs": [
                    "S6"
                ],
                "args": "¬A",
                "rule": "implies_intr",
                "id": "S7",
                "th": "¬¬A ⊢ ¬A ⟶ A"
            },
            {
                "prevs": [
                    "S1",
                    "S3",
                    "S7"
                ],
                "args": "disjE, {A: A, B: ¬A, C: A}",
                "rule": "apply_theorem_for",
                "id": "S8",
                "th": "¬¬A ⊢ A"
            },
            {
                "prevs": [
                    "S8"
                ],
                "args": "¬¬A",
                "rule": "implies_intr",
                "id": "S9",
                "th": "⊢ ¬¬A ⟶ A"
            }
        ],
        "num_gaps": 0,
        "prop": "~~A --> A",
        "instructions": [
            "Add line 'theorem classical' after A1.",
            "Select S2 as goal and S1 as fact, use Ctrl+B with disjE.",
            "Select S2 as goal, use Ctrl+I.",
            "Select S4 as goal, use Ctrl+I.",
            "Select S5 as goal, use Ctrl+B with falseE.",
            "Select S5 as goal and A1 as fact, use Ctrl+B with negE."
        ],
        "ty": "thm",
        "vars": {
            "A": "bool"
        },
        "name": "double_neg"
    },
    {
        "proof": [
            {
                "prevs": [],
                "args": "∃x::'a. A x ∧ B x",
                "rule": "assume",
                "id": "A1",
                "th": "∃x::'a. A x ∧ B x ⊢ ∃x::'a. A x ∧ B x"
            },
            {
                "prevs": [],
                "args": "A x ∧ B x",
                "rule": "assume",
                "id": "S1",
                "th": "A x ∧ B x ⊢ A x ∧ B x"
            },
            {
                "prevs": [
                    "S1"
                ],
                "args": "conjD1",
                "rule": "apply_theorem",
                "id": "S2",
                "th": "A x ∧ B x ⊢ A x"
            },
            {
                "prevs": [
                    "S2"
                ],
                "args": "exI, {P: A, a: x}",
                "rule": "apply_theorem_for",
                "id": "S3",
                "th": "A x ∧ B x ⊢ ∃a::'a. A a"
            },
            {
                "prevs": [
                    "S1"
                ],
                "args": "conjD2",
                "rule": "apply_theorem",
                "id": "S4",
                "th": "A x ∧ B x ⊢ B x"
            },
            {
                "prevs": [
                    "S4"
                ],
                "args": "exI, {P: B, a: x}",
                "rule": "apply_theorem_for",
                "id": "S5",
                "th": "A x ∧ B x ⊢ ∃a::'a. B a"
            },
            {
                "prevs": [
                    "S3",
                    "S5"
                ],
                "args": "conjI, {A: ∃x::'a. A x, B: ∃x::'a. B x}",
                "rule": "apply_theorem_for",
                "id": "S6",
                "th": "A x ∧ B x, ∃x::'a. A x ∧ B x ⊢ (∃x::'a. A x) ∧ (∃x::'a. B x)"
            },
            {
                "prevs": [
                    "S6"
                ],
                "args": "A x ∧ B x",
                "rule": "implies_intr",
                "id": "S7",
                "th": "∃x::'a. A x ∧ B x ⊢ A x ∧ B x ⟶ (∃x::'a. A x) ∧ (∃x::'a. B x)"
            },
            {
                "prevs": [
                    "S7"
                ],
                "args": "x",
                "rule": "forall_intr",
                "id": "S8",
                "th": "∃x::'a. A x ∧ B x ⊢ ∀x::'a. A x ∧ B x ⟶ (∃x::'a. A x) ∧ (∃x::'a. B x)"
            },
            {
                "prevs": [
                    "A1",
                    "S8"
                ],
                "args": "exE, {C: (∃x::'a. A x) ∧ (∃x::'a. B x), P: λx::'a. A x ∧ B x}",
                "rule": "apply_theorem_for",
                "id": "S9",
                "th": "∃x::'a. A x ∧ B x ⊢ (∃x::'a. A x) ∧ (∃x::'a. B x)"
            },
            {
                "prevs": [
                    "S9"
                ],
                "args": "∃x::'a. A x ∧ B x",
                "rule": "implies_intr",
                "id": "S10",
                "th": "⊢ (∃x::'a. A x ∧ B x) ⟶ (∃x::'a. A x) ∧ (∃x::'a. B x)"
            }
        ],
        "num_gaps": 0,
        "prop": "(?x::'a. A x & B x) --> (?x::'a. A x) & (?x::'a. B x)",
        "name": "ex_conj_distrib",
        "ty": "thm",
        "vars": {
            "B": "'a => bool",
            "A": "'a => bool",
            "x": "'a"
        },
        "instructions": [
            "Select S1 as goal and A1 as fact, use Ctrl+B with exE.",
            "Select S1 as goal, use Ctrl+I with x as variable name.",
            "Select S2 as goal, use Ctrl+B with conjI.",
            "Add line 'apply_theorem conjD1 from S1' after S1.",
            "Select S3 as goal and S2 as fact, use Ctrl+B with exI.",
            "Add line 'apply_theorem conjD2 from S1' after S3.",
            "Select S5 as goal and S4 as fact, use Ctrl+B with exI."
        ]
    },
    {
        "proof": [
            {
                "prevs": [],
                "args": "∀x::'a. A x ∧ B x",
                "rule": "assume",
                "id": "A1",
                "th": "∀x::'a. A x ∧ B x ⊢ ∀x::'a. A x ∧ B x"
            },
            {
                "prevs": [
                    "A1"
                ],
                "args": "x",
                "rule": "forall_elim",
                "id": "S1",
                "th": "∀x::'a. A x ∧ B x ⊢ A x ∧ B x"
            },
            {
                "prevs": [
                    "S1"
                ],
                "args": "conjD1, {A: A x, B: B x}",
                "rule": "apply_theorem_for",
                "id": "S2",
                "th": "∀x::'a. A x ∧ B x ⊢ A x"
            },
            {
                "prevs": [
                    "S2"
                ],
                "args": "x",
                "rule": "forall_intr",
                "id": "S3",
                "th": "∀x::'a. A x ∧ B x ⊢ ∀x::'a. A x"
            },
            {
                "prevs": [
                    "S1"
                ],
                "args": "conjD2, {A: A x, B: B x}",
                "rule": "apply_theorem_for",
                "id": "S4",
                "th": "∀x::'a. A x ∧ B x ⊢ B x"
            },
            {
                "prevs": [
                    "S4"
                ],
                "args": "x",
                "rule": "forall_intr",
                "id": "S5",
                "th": "∀x::'a. A x ∧ B x ⊢ ∀x::'a. B x"
            },
            {
                "prevs": [
                    "S3",
                    "S5"
                ],
                "args": "conjI, {A: ∀x::'a. A x, B: ∀x::'a. B x}",
                "rule": "apply_theorem_for",
                "id": "S6",
                "th": "∀x::'a. A x ∧ B x ⊢ (∀x::'a. A x) ∧ (∀x::'a. B x)"
            },
            {
                "prevs": [
                    "S6"
                ],
                "args": "∀x::'a. A x ∧ B x",
                "rule": "implies_intr",
                "id": "S7",
                "th": "⊢ (∀x::'a. A x ∧ B x) ⟶ (∀x::'a. A x) ∧ (∀x::'a. B x)"
            }
        ],
        "num_gaps": 0,
        "prop": "(!x::'a. A x & B x) --> (!x::'a. A x) & (!x::'a. B x)",
        "instructions": [
            "Select S1 as goal, use Ctrl+B with conjI.",
            "Select S1 as goal, use Ctrl+I with x as variable name.",
            "Add line 'forall_elim x from A1' after A1.",
            "Select S2 as goal and S1 as fact, use Ctrl+B with conjD1.",
            "Select S4 as goal, use Ctrl+I with x as variable name.",
            "Select S4 as goal and S1 as fact, use Ctrl+B with conjD2."
        ],
        "ty": "thm",
        "vars": {
            "B": "'a => bool",
            "A": "'a => bool",
            "x": "'a"
        },
        "name": "all_conj_distrib"
    },
    {
        "proof": [
            {
                "prevs": [],
                "args": "0",
                "rule": "reflexive",
                "id": "S1",
                "th": "⊢ 0 = 0"
            },
            {
                "prevs": [
                    "S1"
                ],
                "args": "plus_def_1, 0 + 0 = 0",
                "rule": "rewrite_goal",
                "id": "S2",
                "th": "⊢ 0 + 0 = 0"
            },
            {
                "prevs": [],
                "args": "n + 0 = n",
                "rule": "assume",
                "id": "S3",
                "th": "n + 0 = n ⊢ n + 0 = n"
            },
            {
                "prevs": [
                    "S3"
                ],
                "args": "Suc",
                "rule": "arg_combination",
                "id": "S4",
                "th": "n + 0 = n ⊢ Suc (n + 0) = Suc n"
            },
            {
                "prevs": [
                    "S4"
                ],
                "args": "plus_def_2, Suc n + 0 = Suc n",
                "rule": "rewrite_goal",
                "id": "S5",
                "th": "n + 0 = n ⊢ Suc n + 0 = Suc n"
            },
            {
                "prevs": [
                    "S5"
                ],
                "args": "n + 0 = n",
                "rule": "implies_intr",
                "id": "S6",
                "th": "⊢ n + 0 = n ⟶ Suc n + 0 = Suc n"
            },
            {
                "prevs": [
                    "S6"
                ],
                "args": "n",
                "rule": "forall_intr",
                "id": "S7",
                "th": "⊢ ∀n::nat. n + 0 = n ⟶ Suc n + 0 = Suc n"
            },
            {
                "prevs": [
                    "S2",
                    "S7"
                ],
                "args": "nat_induct, {P: λn::nat. n + 0 = n, x: n}",
                "rule": "apply_theorem_for",
                "id": "S8",
                "th": "⊢ n + 0 = n"
            }
        ],
        "num_gaps": 0,
        "prop": "n + 0 = n",
        "name": "nat.add_0_right",
        "ty": "thm",
        "vars": {
            "n": "nat"
        },
        "instructions": [
            "Select S1 as goal, choose 'apply induction' from menu, then enter 'nat_induct,n'.",
            "Select S1 as goal, use Ctrl+R with plus_def_1.",
            "Set sorry on S1 to reflexive 0.",
            "Select S3 as goal, use Ctrl+I with n as variable name.",
            "Select S4 as goal, use Ctrl+R with plus_def_2.",
            "Set sorry on S4 to arg_combination Suc from S3."
        ]
    },
    {
        "proof": [
            {
                "prevs": [],
                "args": "0",
                "rule": "reflexive",
                "id": "S1",
                "th": "⊢ 0 = 0"
            },
            {
                "prevs": [
                    "S1"
                ],
                "args": "times_def_1, 0 * 0 = 0",
                "rule": "rewrite_goal",
                "id": "S2",
                "th": "⊢ 0 * 0 = 0"
            },
            {
                "prevs": [],
                "args": "n * 0 = 0",
                "rule": "assume",
                "id": "S3",
                "th": "n * 0 = 0 ⊢ n * 0 = 0"
            },
            {
                "prevs": [
                    "S3"
                ],
                "args": "plus_def_1, 0 + n * 0 = 0",
                "rule": "rewrite_goal",
                "id": "S4",
                "th": "n * 0 = 0 ⊢ 0 + n * 0 = 0"
            },
            {
                "prevs": [
                    "S4"
                ],
                "args": "times_def_2, Suc n * 0 = 0",
                "rule": "rewrite_goal",
                "id": "S5",
                "th": "n * 0 = 0 ⊢ Suc n * 0 = 0"
            },
            {
                "prevs": [
                    "S5"
                ],
                "args": "n * 0 = 0",
                "rule": "implies_intr",
                "id": "S6",
                "th": "⊢ n * 0 = 0 ⟶ Suc n * 0 = 0"
            },
            {
                "prevs": [
                    "S6"
                ],
                "args": "n",
                "rule": "forall_intr",
                "id": "S7",
                "th": "⊢ ∀n::nat. n * 0 = 0 ⟶ Suc n * 0 = 0"
            },
            {
                "prevs": [
                    "S2",
                    "S7"
                ],
                "args": "nat_induct, {P: λn::nat. n * 0 = 0, x: n}",
                "rule": "apply_theorem_for",
                "id": "S8",
                "th": "⊢ n * 0 = 0"
            }
        ],
        "num_gaps": 0,
        "prop": "n * 0 = 0",
        "instructions": [
            "Select S1 as goal, choose 'apply induction' from menu, then enter 'nat_induct,n'.",
            "Select S1 as goal, use Ctrl+R with times_def_1.",
            "Set sorry on S1 to reflexive 0.",
            "Select S3 as goal, use Ctrl+I with n as variable name.",
            "Select S4 as goal, use Ctrl+R with times_def_2.",
            "Select S4 as goal, use Ctrl+R with plus_def_1"
        ],
        "ty": "thm",
        "vars": {
            "n": "nat"
        },
        "name": "nat.mult_0_right"
    },
    {
        "name": "conj_disj_distribL1",
        "ty": "thm",
        "vars": {
            "C": "bool",
            "B": "bool",
            "A": "bool"
        },
        "prop": "A & (B | C) --> (A & B) | (A & C)"
    },
    {
        "name": "conj_disj_distribL1",
        "ty": "thm",
        "vars": {
            "C": "bool",
            "B": "bool",
            "A": "bool"
        },
        "prop": "(A & B) | (A & C) --> A & (B | C)"
    },
    {
        "proof": [
            {
                "prevs": [],
                "args": "nil",
                "rule": "reflexive",
                "id": "S1",
                "th": "⊢ nil = nil"
            },
            {
                "prevs": [
                    "S1"
                ],
                "args": "append_def_1, nil @ nil = nil",
                "rule": "rewrite_goal",
                "id": "S2",
                "th": "⊢ nil @ nil = nil"
            },
            {
                "prevs": [],
                "args": "xs @ nil = xs",
                "rule": "assume",
                "id": "S3",
                "th": "xs @ nil = xs ⊢ xs @ nil = xs"
            },
            {
                "prevs": [
                    "S3"
                ],
                "args": "cons x",
                "rule": "arg_combination",
                "id": "S4",
                "th": "xs @ nil = xs ⊢ cons x (xs @ nil) = cons x xs"
            },
            {
                "prevs": [
                    "S4"
                ],
                "args": "append_def_2, cons x xs @ nil = cons x xs",
                "rule": "rewrite_goal",
                "id": "S5",
                "th": "xs @ nil = xs ⊢ cons x xs @ nil = cons x xs"
            },
            {
                "prevs": [
                    "S5"
                ],
                "args": "xs @ nil = xs",
                "rule": "implies_intr",
                "id": "S6",
                "th": "⊢ xs @ nil = xs ⟶ cons x xs @ nil = cons x xs"
            },
            {
                "prevs": [
                    "S6"
                ],
                "args": "xs",
                "rule": "forall_intr",
                "id": "S7",
                "th": "⊢ ∀xs::'a list. xs @ nil = xs ⟶ cons x xs @ nil = cons x xs"
            },
            {
                "prevs": [
                    "S7"
                ],
                "args": "x",
                "rule": "forall_intr",
                "id": "S8",
                "th": "⊢ ∀x::'a. ∀xs::'a list. xs @ nil = xs ⟶ cons x xs @ nil = cons x xs"
            },
            {
                "prevs": [
                    "S2",
                    "S8"
                ],
                "args": "list_induct, {P: λxs::'a list. xs @ nil = xs, x: xs}",
                "rule": "apply_theorem_for",
                "id": "S9",
                "th": "⊢ xs @ nil = xs"
            }
        ],
        "num_gaps": 0,
        "prop": "xs @ nil = xs",
        "name": "list.append_right_neutral",
        "ty": "thm",
        "vars": {
            "xs": "'a list",
            "x": "'a"
        },
        "instructions": [
            "Select S1 as goal, choose 'apply induction' from menu, then enter 'list_induct,xs'.",
            "Select S1 as goal, use Ctrl+R with append_def_1.",
            "Set sorry on S1 to reflexive nil.",
            "Select S3 as goal, use Ctrl+I with x,xs as variable name.",
            "Select S4 as goal, use Ctrl+R with append_def_2.",
            "Set sorry on S4 to arg_combination cons x from S3."
        ]
    },
    {
        "proof": [
            {
                "prevs": [],
                "args": "ys @ zs",
                "rule": "reflexive",
                "id": "S1",
                "th": "⊢ ys @ zs = ys @ zs"
            },
            {
                "prevs": [
                    "S1"
                ],
                "args": "append_def_1, (nil @ ys) @ zs = nil @ ys @ zs",
                "rule": "rewrite_goal",
                "id": "S2",
                "th": "⊢ (nil @ ys) @ zs = nil @ ys @ zs"
            },
            {
                "prevs": [],
                "args": "(xs @ ys) @ zs = xs @ ys @ zs",
                "rule": "assume",
                "id": "S3",
                "th": "(xs @ ys) @ zs = xs @ ys @ zs ⊢ (xs @ ys) @ zs = xs @ ys @ zs"
            },
            {
                "prevs": [
                    "S3"
                ],
                "args": "cons x",
                "rule": "arg_combination",
                "id": "S4",
                "th": "(xs @ ys) @ zs = xs @ ys @ zs ⊢ cons x ((xs @ ys) @ zs) = cons x (xs @ ys @ zs)"
            },
            {
                "prevs": [
                    "S4"
                ],
                "args": "append_def_2, cons x (xs @ ys) @ zs = cons x (xs @ ys @ zs)",
                "rule": "rewrite_goal",
                "id": "S5",
                "th": "(xs @ ys) @ zs = xs @ ys @ zs ⊢ cons x (xs @ ys) @ zs = cons x (xs @ ys @ zs)"
            },
            {
                "prevs": [
                    "S5"
                ],
                "args": "append_def_2, (cons x xs @ ys) @ zs = cons x xs @ ys @ zs",
                "rule": "rewrite_goal",
                "id": "S6",
                "th": "(xs @ ys) @ zs = xs @ ys @ zs ⊢ (cons x xs @ ys) @ zs = cons x xs @ ys @ zs"
            },
            {
                "prevs": [
                    "S6"
                ],
                "args": "(xs @ ys) @ zs = xs @ ys @ zs",
                "rule": "implies_intr",
                "id": "S7",
                "th": "⊢ (xs @ ys) @ zs = xs @ ys @ zs ⟶ (cons x xs @ ys) @ zs = cons x xs @ ys @ zs"
            },
            {
                "prevs": [
                    "S7"
                ],
                "args": "xs",
                "rule": "forall_intr",
                "id": "S8",
                "th": "⊢ ∀xs::'a list. (xs @ ys) @ zs = xs @ ys @ zs ⟶ (cons x xs @ ys) @ zs = cons x xs @ ys @ zs"
            },
            {
                "prevs": [
                    "S8"
                ],
                "args": "x",
                "rule": "forall_intr",
                "id": "S9",
                "th": "⊢ ∀x::'a. ∀xs::'a list. (xs @ ys) @ zs = xs @ ys @ zs ⟶ (cons x xs @ ys) @ zs = cons x xs @ ys @ zs"
            },
            {
                "prevs": [
                    "S2",
                    "S9"
                ],
                "args": "list_induct, {P: λxs::'a list. (xs @ ys) @ zs = xs @ ys @ zs, x: xs}",
                "rule": "apply_theorem_for",
                "id": "S10",
                "th": "⊢ (xs @ ys) @ zs = xs @ ys @ zs"
            }
        ],
        "num_gaps": 0,
        "prop": "(xs @ ys) @ zs = xs @ ys @ zs",
        "instructions": [
            "Select S1 as goal, choose 'apply induction' from menu, then enter 'list_induct,xs'.",
            "Select S1 as goal, use Ctrl+R with append_def_1.",
            "Set sorry on S1 to reflexive ys @ zs.",
            "Select S3 as goal, use Ctrl+I with x,xs as variable name.",
            "Select S4 as goal, use Ctrl+R with append_def_2.",
            "Select S4 as goal, use Ctrl+R with append_def_2.",
            "Set sorry on S4 to arg_combination cons x from S3."
        ],
        "ty": "thm",
        "vars": {
            "zs": "'a list",
            "xs": "'a list",
            "ys": "'a list",
            "x": "'a"
        },
        "name": "list.append_assoc"
    }
]