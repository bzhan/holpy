{
    "content": [
        {
            "depth": 0,
            "name": "Basic operators in logic",
            "ty": "header"
        },
        {
            "ascii_op": "&",
            "name": "conj",
            "ty": "def.ax",
            "type": "bool ⇒ bool ⇒ bool",
            "unicode_op": "∧"
        },
        {
            "ascii_op": "|",
            "name": "disj",
            "ty": "def.ax",
            "type": "bool => bool => bool",
            "unicode_op": "∨"
        },
        {
            "ascii_op": "~",
            "name": "neg",
            "ty": "def.ax",
            "type": "bool => bool",
            "unicode_op": "¬"
        },
        {
            "name": "true",
            "ty": "def.ax",
            "type": "bool"
        },
        {
            "name": "false",
            "ty": "def.ax",
            "type": "bool"
        },
        {
            "name": "exists",
            "ty": "def.ax",
            "type": "('a => bool) => bool"
        },
        {
            "name": "IF",
            "ty": "def.ax",
            "type": "bool => 'a => 'a => 'a"
        },
        {
            "name": "The",
            "ty": "def.ax",
            "type": "('a => bool) => 'a"
        },
        {
            "attributes": [],
            "name": "exists1",
            "prop": "exists1 P <--> ((∃x. P x) ∧ (∀y. P y ⟶ y = x))",
            "ty": "def",
            "type": "('a ⇒ bool) ⇒ bool"
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "conjI",
            "prop": "A ⟶ B ⟶ A ∧ B",
            "ty": "thm.ax",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward1",
                "hint_forward"
            ],
            "name": "conjD1",
            "prop": "A ∧ B ⟶ A",
            "ty": "thm.ax",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward1",
                "hint_forward"
            ],
            "name": "conjD2",
            "prop": "A & B --> B",
            "ty": "thm.ax",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "disjI1",
            "prop": "A --> A | B",
            "ty": "thm.ax",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "disjI2",
            "prop": "B --> A | B",
            "ty": "thm.ax",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward1"
            ],
            "name": "disjE",
            "prop": "A | B --> (A --> C) --> (B --> C) --> C",
            "ty": "thm.ax",
            "vars": {
                "A": "bool",
                "B": "bool",
                "C": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "negI",
            "prop": "(A --> false) --> ~A",
            "ty": "thm.ax",
            "vars": {
                "A": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "negE",
            "prop": "~A --> A --> false",
            "ty": "thm.ax",
            "vars": {
                "A": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward",
                "hint_resolve"
            ],
            "name": "trueI",
            "prop": "true",
            "ty": "thm.ax",
            "vars": {}
        },
        {
            "name": "falseE",
            "prop": "false --> A",
            "ty": "thm.ax",
            "vars": {
                "A": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "exI",
            "prop": "P a --> ?a. P a",
            "ty": "thm.ax",
            "vars": {
                "P": "'a => bool",
                "a": "'a"
            }
        },
        {
            "attributes": [],
            "name": "exE",
            "prop": "(?a. P a) --> (!a. P a --> C) --> C",
            "ty": "thm.ax",
            "vars": {
                "C": "bool",
                "P": "'a => bool",
                "a": "'a"
            }
        },
        {
            "name": "classical",
            "prop": "A | ~A",
            "ty": "thm.ax",
            "vars": {
                "A": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "extension",
            "prop": "(!x. f x = g x) --> f = g",
            "ty": "thm.ax",
            "vars": {
                "f": "'a => 'b",
                "g": "'a => 'b"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "if_P",
            "prop": "P ⟶ (if P then x else y) = x",
            "ty": "thm.ax",
            "vars": {
                "P": "bool",
                "x": "'a",
                "y": "'a"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "if_not_P",
            "prop": "¬P ⟶ (if P then x else y) = y",
            "ty": "thm.ax",
            "vars": {
                "P": "bool",
                "x": "'a",
                "y": "'a"
            }
        },
        {
            "attributes": [],
            "name": "the_equality",
            "prop": "P a ⟶ (∀x. P x ⟶ x = a) ⟶ The (λx. P x) = a",
            "ty": "thm.ax",
            "vars": {
                "P": "'a => bool",
                "a": "'a"
            }
        },
        {
            "depth": 0,
            "name": "Definitions for internal use",
            "ty": "header"
        },
        {
            "name": "_VAR",
            "ty": "def.ax",
            "type": "'a => bool"
        },
        {
            "name": "beta_norm",
            "ty": "macro"
        },
        {
            "name": "intros",
            "ty": "macro"
        },
        {
            "name": "apply_theorem",
            "ty": "macro"
        },
        {
            "name": "apply_theorem_for",
            "ty": "macro"
        },
        {
            "name": "resolve_theorem",
            "ty": "macro"
        },
        {
            "name": "apply_fact",
            "ty": "macro"
        },
        {
            "name": "apply_fact_for",
            "ty": "macro"
        },
        {
            "name": "rewrite_goal",
            "ty": "macro"
        },
        {
            "name": "rewrite_goal_sym",
            "ty": "macro"
        },
        {
            "name": "rewrite_goal_with_prev",
            "ty": "macro"
        },
        {
            "name": "rewrite_goal_with_prev_sym",
            "ty": "macro"
        },
        {
            "name": "rewrite_fact",
            "ty": "macro"
        },
        {
            "name": "rewrite_fact_with_prev",
            "ty": "macro"
        },
        {
            "name": "trivial",
            "ty": "macro"
        },
        {
            "name": "cut",
            "ty": "method"
        },
        {
            "name": "cases",
            "ty": "method"
        },
        {
            "name": "apply_prev",
            "ty": "method"
        },
        {
            "name": "rewrite_goal_with_prev",
            "ty": "method"
        },
        {
            "name": "rewrite_goal",
            "ty": "method"
        },
        {
            "name": "rewrite_fact",
            "ty": "method"
        },
        {
            "name": "rewrite_fact_with_prev",
            "ty": "method"
        },
        {
            "name": "apply_forward_step",
            "ty": "method"
        },
        {
            "name": "apply_backward_step",
            "ty": "method"
        },
        {
            "name": "apply_resolve_step",
            "ty": "method"
        },
        {
            "name": "apply_fact",
            "ty": "method"
        },
        {
            "name": "introduction",
            "ty": "method"
        },
        {
            "name": "forall_elim",
            "ty": "method"
        },
        {
            "name": "inst_exists_goal",
            "ty": "method"
        },
        {
            "name": "exists_elim",
            "ty": "method"
        },
        {
            "name": "induction",
            "ty": "method"
        },
        {
            "name": "new_var",
            "ty": "method"
        },
        {
            "name": "z3",
            "ty": "macro"
        },
        {
            "name": "z3",
            "ty": "method"
        },
        {
            "depth": 0,
            "name": "Some simple results",
            "ty": "header"
        },
        {
            "attributes": [
                "hint_resolve"
            ],
            "name": "not_false_res",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "false ⟶ false",
                    "id": "0",
                    "prevs": [],
                    "rule": "trivial",
                    "th": "⊢ false ⟶ false"
                },
                {
                    "args": "negI",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "apply_theorem",
                    "th": "⊢ ¬false"
                }
            ],
            "prop": "¬false",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "apply_backward_step",
                    "theorem": "negI"
                }
            ],
            "ty": "thm",
            "vars": {}
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "eq_refl",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "x",
                    "id": "0",
                    "prevs": [],
                    "rule": "reflexive",
                    "th": "⊢ x = x"
                }
            ],
            "prop": "x = x",
            "steps": [],
            "ty": "thm",
            "vars": {
                "x": "'a"
            }
        },
        {
            "name": "classical_cases",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "A ⟶ C",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "A ⟶ C ⊢ A ⟶ C"
                },
                {
                    "args": "¬A ⟶ C",
                    "id": "1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "¬A ⟶ C ⊢ ¬A ⟶ C"
                },
                {
                    "args": "classical",
                    "id": "2",
                    "prevs": [],
                    "rule": "theorem",
                    "th": "⊢ A ∨ ¬A"
                },
                {
                    "args": "disjE",
                    "id": "3",
                    "prevs": [
                        "2",
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem",
                    "th": "A ⟶ C, ¬A ⟶ C ⊢ C"
                },
                {
                    "args": "",
                    "id": "4",
                    "prevs": [
                        "0",
                        "1",
                        "3"
                    ],
                    "rule": "intros",
                    "th": "⊢ (A ⟶ C) ⟶ (¬A ⟶ C) ⟶ C"
                }
            ],
            "prop": "(A --> C) --> (~A --> C) --> C",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "C": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward1"
            ],
            "name": "negE_gen",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "¬A",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "¬A ⊢ ¬A"
                },
                {
                    "args": "A",
                    "id": "1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "A ⊢ A"
                },
                {
                    "args": "negE",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem",
                    "th": "¬A, A ⊢ false"
                },
                {
                    "args": "falseE, {}, {A: C}",
                    "id": "3",
                    "prevs": [
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "¬A, A ⊢ C"
                },
                {
                    "args": "",
                    "id": "4",
                    "prevs": [
                        "0",
                        "1",
                        "3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ¬A ⟶ A ⟶ C"
                }
            ],
            "prop": "~A --> A --> C",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "C": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "iffI",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "A ⟶ B",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "A ⟶ B ⊢ A ⟶ B"
                },
                {
                    "args": "B ⟶ A",
                    "id": "1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "B ⟶ A ⊢ B ⟶ A"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "equal_intr",
                    "th": "A ⟶ B, B ⟶ A ⊢ A = B"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [
                        "0",
                        "1",
                        "2"
                    ],
                    "rule": "intros",
                    "th": "⊢ (A ⟶ B) ⟶ (B ⟶ A) ⟶ A = B"
                }
            ],
            "prop": "(A --> B) --> (B --> A) --> (A = B)",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "ineq_sym",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "¬x = y",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "¬x = y ⊢ ¬x = y"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "¬x = y ⊢ y = x ⟶ false"
                },
                {
                    "args": "y = x",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "y = x ⊢ y = x"
                },
                {
                    "args": "",
                    "id": "1.1",
                    "prevs": [
                        "1.0",
                        "0"
                    ],
                    "rule": "rewrite_fact_with_prev",
                    "th": "y = x, ¬x = y ⊢ ¬x = x"
                },
                {
                    "args": "eq_refl, {a: 'a}, {x: x}",
                    "id": "1.2",
                    "prevs": [],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x = x"
                },
                {
                    "args": "negE",
                    "id": "1.3",
                    "prevs": [
                        "1.1",
                        "1.2"
                    ],
                    "rule": "apply_theorem",
                    "th": "y = x, ¬x = y ⊢ false"
                },
                {
                    "args": "",
                    "id": "1.4",
                    "prevs": [
                        "1.0",
                        "1.3"
                    ],
                    "rule": "intros",
                    "th": "¬x = y ⊢ y = x ⟶ false"
                },
                {
                    "args": "negI",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "apply_theorem",
                    "th": "¬x = y ⊢ ¬y = x"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [
                        "0",
                        "2"
                    ],
                    "rule": "intros",
                    "th": "⊢ ¬x = y ⟶ ¬y = x"
                }
            ],
            "prop": "~(x = y) --> ~(y = x)",
            "steps": [
                {
                    "goal_id": "1",
                    "method_name": "apply_backward_step",
                    "theorem": "negI"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction",
                    "names": ""
                },
                {
                    "fact_ids": [
                        "1.0",
                        "0"
                    ],
                    "goal_id": "1.1",
                    "method_name": "rewrite_fact_with_prev"
                },
                {
                    "fact_ids": [
                        "1.1"
                    ],
                    "goal_id": "1.2",
                    "method_name": "apply_backward_step",
                    "theorem": "negE"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "apply_backward_step",
                    "theorem": "eq_refl"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "'a",
                "y": "'a"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "eq_sym_eq",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "",
                    "id": "0",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ x = y ⟶ y = x"
                },
                {
                    "args": "x = y",
                    "id": "0.0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "x = y ⊢ x = y"
                },
                {
                    "args": "y = x",
                    "id": "0.1",
                    "prevs": [
                        "0.0"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "x = y ⊢ y = x"
                },
                {
                    "args": "",
                    "id": "0.2",
                    "prevs": [
                        "0.0",
                        "0.1"
                    ],
                    "rule": "intros",
                    "th": "⊢ x = y ⟶ y = x"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ y = x ⟶ x = y"
                },
                {
                    "args": "y = x",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "y = x ⊢ y = x"
                },
                {
                    "args": "x = y",
                    "id": "1.1",
                    "prevs": [
                        "1.0"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "y = x ⊢ x = y"
                },
                {
                    "args": "",
                    "id": "1.2",
                    "prevs": [
                        "1.0",
                        "1.1"
                    ],
                    "rule": "intros",
                    "th": "⊢ y = x ⟶ x = y"
                },
                {
                    "args": "iffI",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem",
                    "th": "⊢ x = y ⟷ y = x"
                }
            ],
            "prop": "x = y <--> y = x",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "apply_backward_step",
                    "theorem": "iffI"
                },
                {
                    "goal_id": "0",
                    "method_name": "introduction"
                },
                {
                    "fact_ids": [
                        "0.0"
                    ],
                    "goal_id": "0.1",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction"
                },
                {
                    "fact_ids": [
                        "1.0"
                    ],
                    "goal_id": "1.1",
                    "method_name": "rewrite_goal_with_prev"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "'a",
                "y": "'a"
            }
        },
        {
            "attributes": [],
            "name": "theI",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "P a",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "P a ⊢ P a"
                },
                {
                    "args": "∀x. P x ⟶ x = a",
                    "id": "1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "∀x. P x ⟶ x = a ⊢ ∀x. P x ⟶ x = a"
                },
                {
                    "args": "the_equality, {a: 'a}, {P: P, a: a}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "P a, ∀x. P x ⟶ x = a ⊢ (THE x. P x) = a"
                },
                {
                    "args": "P (THE x. P x)",
                    "id": "3",
                    "prevs": [
                        "2",
                        "0",
                        "0",
                        "1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "P a, ∀x. P x ⟶ x = a ⊢ P (THE x. P x)"
                },
                {
                    "args": "",
                    "id": "4",
                    "prevs": [
                        "0",
                        "1",
                        "3"
                    ],
                    "rule": "intros",
                    "th": "⊢ P a ⟶ (∀x. P x ⟶ x = a) ⟶ P (THE x. P x)"
                }
            ],
            "prop": "P a ⟶ (∀x. P x ⟶ x = a) ⟶ P (The (λx. P x))",
            "steps": [
                {
                    "goal": "(THE x. P x) = a",
                    "goal_id": "2",
                    "method_name": "cut"
                },
                {
                    "goal_id": "2",
                    "method_name": "apply_backward_step",
                    "theorem": "the_equality"
                },
                {
                    "fact_ids": [
                        "2"
                    ],
                    "goal_id": "3",
                    "method_name": "rewrite_goal_with_prev"
                }
            ],
            "ty": "thm",
            "vars": {
                "P": "'a => bool",
                "a": "'a"
            }
        },
        {
            "attributes": [],
            "name": "theI'",
            "prop": "(∃!x. P x) ⟶ P (THE x. P x)",
            "ty": "thm",
            "vars": {
                "P": "'a => bool"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "eta_conversion",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "",
                    "id": "0",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀x. f x = f x"
                },
                {
                    "args": "x, 'a",
                    "id": "0.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR x"
                },
                {
                    "args": "eq_refl, {a: 'b}, {x: f x}",
                    "id": "0.1",
                    "prevs": [],
                    "rule": "apply_theorem_for",
                    "th": "⊢ f x = f x"
                },
                {
                    "args": "",
                    "id": "0.2",
                    "prevs": [
                        "0.0",
                        "0.1"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀x. f x = f x"
                },
                {
                    "args": "extension",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "apply_theorem",
                    "th": "⊢ f = f"
                }
            ],
            "prop": "(λx. f x) = f",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "apply_backward_step",
                    "theorem": "extension"
                },
                {
                    "goal_id": "0",
                    "method_name": "introduction",
                    "names": "x"
                },
                {
                    "goal_id": "0.1",
                    "method_name": "apply_backward_step",
                    "theorem": "eq_refl"
                }
            ],
            "ty": "thm",
            "vars": {
                "f": "'a => 'b"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "if_true",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "trueI",
                    "id": "0",
                    "prevs": [],
                    "rule": "apply_theorem",
                    "th": "⊢ true"
                },
                {
                    "args": "if_P, (if true then a else b) = a",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ (if true then a else b) = a"
                }
            ],
            "prop": "(if true then a else b) = a",
            "steps": [
                {
                    "goal": "true",
                    "goal_id": "0",
                    "method_name": "cut"
                },
                {
                    "goal_id": "0",
                    "method_name": "apply_backward_step",
                    "theorem": "trueI"
                },
                {
                    "fact_ids": [
                        "0"
                    ],
                    "goal_id": "1",
                    "method_name": "rewrite_goal",
                    "theorem": "if_P"
                }
            ],
            "ty": "thm",
            "vars": {
                "a": "'a",
                "b": "'a"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "if_false",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "false ⟶ false",
                    "id": "0",
                    "prevs": [],
                    "rule": "trivial",
                    "th": "⊢ false ⟶ false"
                },
                {
                    "args": "negI",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "apply_theorem",
                    "th": "⊢ ¬false"
                },
                {
                    "args": "if_not_P, (if false then a else b) = b",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ (if false then a else b) = b"
                }
            ],
            "prop": "(if false then a else b) = b",
            "steps": [
                {
                    "goal": "~false",
                    "goal_id": "0",
                    "method_name": "cut"
                },
                {
                    "goal_id": "0",
                    "method_name": "apply_backward_step",
                    "theorem": "negI"
                },
                {
                    "fact_ids": [
                        "1"
                    ],
                    "goal_id": "2",
                    "method_name": "rewrite_goal",
                    "theorem": "if_not_P"
                }
            ],
            "ty": "thm",
            "vars": {
                "a": "'a",
                "b": "'a"
            }
        }
    ],
    "description": "Foundation of higher-order logic",
    "imports": [],
    "name": "logic_base"
}