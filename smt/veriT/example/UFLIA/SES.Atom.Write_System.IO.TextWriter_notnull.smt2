(set-info :smt-lib-version 2.6)
(set-logic UFLIA)
(set-info :source |
  This benchmark originally named "SExpressionSimplifier.Atom.Write$System.IO.TextWriter$notnull.smt2"

  This benchmark was translated by Michal Moskal.
|)
(set-info :category "industrial")
(set-info :status unsat)
(declare-fun stringLiteral14_ () Int)
(declare-fun System.Console.get_In_ (Int) Int)
(declare-fun System.UInt16 () Int)
(declare-fun stringLiteral29_ () Int)
(declare-fun System.String.GetEnumerator_ (Int Int) Int)
(declare-fun divide (Int Int) Int)
(declare-fun System.Reflection.MemberInfo () Int)
(declare-fun SExpressionSimplifier.Sx.get_IsTrue_ (Int Int) Int)
(declare-fun System.MarshalByRefObject () Int)
(declare-fun divides (Int Int) Int)
(declare-fun or_ (Int Int) Int)
(declare-fun SExpressionSimplifier.PrettySx () Int)
(declare-fun block27608_correct () Int)
(declare-fun DimLength_ (Int Int) Int)
(declare-fun is (Int Int) Int)
(declare-fun stringLiteral15_ () Int)
(declare-fun IsNotNull_ (Int Int) Int)
(declare-fun RefArray (Int Int) Int)
(declare-fun NonNullFieldsAreInitialized_ () Int)
(declare-fun System.String.Equals_System.String_System.String_ (Int Int Int) Int)
(declare-fun System.String.get_Chars_System.Int32_ (Int Int Int) Int)
(declare-fun SExpressionSimplifier.Sx.get_IsFalse_.1 (Int) Int)
(declare-fun System.ICloneable () Int)
(declare-fun Unbox (Int) Int)
(declare-fun SExpressionSimplifier.Atom () Int)
(declare-fun System.SByte () Int)
(declare-fun RefArraySet (Int Int Int) Int)
(declare-fun Smt.true () Int)
(declare-fun System.UInt32 () Int)
(declare-fun System.IO.TextReader () Int)
(declare-fun ownerFrame_ () Int)
(declare-fun stringLiteral16_ () Int)
(declare-fun System.IO.TextWriter () Int)
(declare-fun entry_correct () Int)
(declare-fun SExpressionSimplifier.Nary.F () Int)
(declare-fun AsMutable_ (Int) Int)
(declare-fun modulo (Int Int) Int)
(declare-fun boolNot (Int) Int)
(declare-fun boolOr (Int Int) Int)
(declare-fun Rank_ (Int) Int)
(declare-fun SExpressionSimplifier.Sx.get_IsFalse_ (Int Int) Int)
(declare-fun System.Collections.IEnumerable () Int)
(declare-fun IsAllocated (Int Int) Int)
(declare-fun System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.get_Count_ (Int Int) Int)
(declare-fun System.Text.StringBuilder () Int)
(declare-fun System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator () Int)
(declare-fun SExpressionSimplifier.Sx.get_False_ (Int) Int)
(declare-fun anyEqual (Int Int) Int)
(declare-fun stringLiteral17_ () Int)
(declare-fun StructSet_ (Int Int Int) Int)
(declare-fun intLess (Int Int) Int)
(declare-fun Length_ (Int) Int)
(declare-fun AsNonNullRefField (Int Int) Int)
(declare-fun System.Byte () Int)
(declare-fun LBound_ (Int Int) Int)
(declare-fun TypeObject (Int) Int)
(declare-fun ReallyLastGeneratedExit_correct () Int)
(declare-fun ArrayCategoryValue_ () Int)
(declare-fun System.IConvertible () Int)
(declare-fun ValueArraySet (Int Int Int) Int)
(declare-fun select1 (Int Int) Int)
(declare-fun select2 (Int Int Int) Int)
(declare-fun stringLiteral30_ () Int)
(declare-fun System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator.get_Current_.1 (Int) Int)
(declare-fun AsOwner (Int Int) Int)
(declare-fun SExpressionSimplifier.Sx () Int)
(declare-fun Box (Int Int) Int)
(declare-fun System.String.Concat_System.String_System.String_ (Int Int Int) Int)
(declare-fun IsValueType_ (Int) Int)
(declare-fun System.Text.StringBuilder.ToString_.1 (Int) Int)
(declare-fun System.UInt64 () Int)
(declare-fun stringLiteral19_ () Int)
(declare-fun System.Char.IsWhiteSpace_System.Char_ (Int Int) Int)
(declare-fun AsRangeField (Int Int) Int)
(declare-fun System.CharEnumerator () Int)
(declare-fun ArrayCategoryNonNullRef_ () Int)
(declare-fun intAtLeast (Int Int) Int)
(declare-fun System.Char () Int)
(declare-fun SExpressionSimplifier.Nary.Args_ (Int) Int)
(declare-fun System.Reflection.IReflect () Int)
(declare-fun IntToInt_ (Int Int Int) Int)
(declare-fun System.String.get_Chars_System.Int32_.1 (Int Int) Int)
(declare-fun StructGet_ (Int Int) Int)
(declare-fun shl_ (Int Int) Int)
(declare-fun System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.GetEnumerator_ (Int Int) Int)
(declare-fun System.UIntPtr () Int)
(declare-fun System.Collections.IEnumerator () Int)
(declare-fun System.CharEnumerator.get_Current_.1 (Int) Int)
(declare-fun IsHeap (Int) Int)
(declare-fun int_9223372036854775807 () Int)
(declare-fun StringLength_ (Int) Int)
(declare-fun allocated_ () Int)
(declare-fun InRange (Int Int) Bool)
(declare-fun stringLiteral33_ () Int)
(declare-fun RefArrayGet (Int Int) Int)
(declare-fun System.IComparable () Int)
(declare-fun wr_in () Int)
(declare-fun ownerRef_ () Int)
(declare-fun multiply (Int Int) Int)
(declare-fun inv_ () Int)
(declare-fun IfThenElse_ (Int Int Int) Int)
(declare-fun elements_ () Int)
(declare-fun int_18446744073709551615 () Int)
(declare-fun System.IEquatable_1...System.String () Int)
(declare-fun System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator.get_Current_ (Int Int) Int)
(declare-fun int_4294967295 () Int)
(declare-fun AsImmutable_ (Int) Int)
(declare-fun System.Runtime.InteropServices._MemberInfo () Int)
(declare-fun localinv_ () Int)
(declare-fun SharingMode_Unshared_ () Int)
(declare-fun FieldDependsOnFCO_ (Int Int Int) Int)
(declare-fun System.Text.StringBuilder.get_Length_ (Int Int) Int)
(declare-fun System.Collections.Generic.IList_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx () Int)
(declare-fun UBound_ (Int Int) Int)
(declare-fun System.Runtime.InteropServices._Type () Int)
(declare-fun System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.get_Item_System.Int32_ (Int Int Int) Int)
(declare-fun stringLiteral35_ () Int)
(declare-fun typeof_ (Int) Int)
(declare-fun block27506_correct () Int)
(declare-fun ValueArrayGet (Int Int) Int)
(declare-fun Is_ (Int Int) Int)
(declare-fun AsRepField (Int Int) Int)
(declare-fun System.Collections.IList () Int)
(declare-fun SharingMode_LockProtected_ () Int)
(declare-fun and_ (Int Int) Int)
(declare-fun intAtMost (Int Int) Int)
(declare-fun System.Collections.Generic.IEnumerable_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx () Int)
(declare-fun stringLiteral21_ () Int)
(declare-fun StringEquals_ (Int Int) Int)
(declare-fun int_2147483647 () Int)
(declare-fun ClassRepr (Int) Int)
(declare-fun System.CharEnumerator.get_Current_ (Int Int) Int)
(declare-fun stringLiteral36_ () Int)
(declare-fun sharingMode_ () Int)
(declare-fun TypeName (Int) Int)
(declare-fun AsRefField (Int Int) Int)
(declare-fun SExpressionSimplifier.PrettySx.Token () Int)
(declare-fun anyNeq (Int Int) Int)
(declare-fun System.Runtime.Serialization.ISerializable () Int)
(declare-fun stringLiteral3_ () Int)
(declare-fun PeerGroupPlaceholder_ () Int)
(declare-fun stringLiteral22_ () Int)
(declare-fun System.IntPtr () Int)
(declare-fun stringLiteral37_ () Int)
(declare-fun System.Collections.Generic.IEnumerable_1...System.Char () Int)
(declare-fun boolAnd (Int Int) Int)
(declare-fun boolImplies (Int Int) Int)
(declare-fun int_m2147483648 () Int)
(declare-fun IsStaticField (Int) Int)
(declare-fun AsPureObject_ (Int) Int)
(declare-fun SExpressionSimplifier.Atom.S () Int)
(declare-fun System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx () Int)
(declare-fun Heap_ () Int)
(declare-fun SExpressionSimplifier.Sx.get_IsTrue_.1 (Int) Int)
(declare-fun stringLiteral4_ () Int)
(declare-fun System.Collections.Generic.ICollection_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx () Int)
(declare-fun stringLiteral23_ () Int)
(declare-fun ArrayCategoryRef_ () Int)
(declare-fun shr_ (Int Int) Int)
(declare-fun System.Type () Int)
(declare-fun FirstConsistentOwner_ () Int)
(declare-fun System.Text.StringBuilder.get_Length_.1 (Int) Int)
(declare-fun exposeVersion_ () Int)
(declare-fun SExpressionSimplifier.Nary.F_ (Int) Int)
(declare-fun IsDirectlyModifiableField (Int) Int)
(declare-fun this () Int)
(declare-fun As_ (Int Int) Int)
(declare-fun System.Int16 () Int)
(declare-fun stringLiteral5_ () Int)
(declare-fun Heap_0_ () Int)
(declare-fun stringLiteral24_ () Int)
(declare-fun System.Char.IsLetterOrDigit_System.Char_ (Int Int) Int)
(declare-fun BaseClass_ (Int) Int)
(declare-fun System.Object () Int)
(declare-fun stack0o_0 () Int)
(declare-fun SExpressionSimplifier.Sx.get_True_ (Int) Int)
(declare-fun ArrayIndex (Int Int Int Int) Int)
(declare-fun OneClassDown (Int Int) Int)
(declare-fun System.Console.get_Out_ (Int) Int)
(declare-fun UnboxedType (Int) Int)
(declare-fun SExpressionSimplifier.PrettySx.currentTokenString () Int)
(declare-fun stringLiteral6_ () Int)
(declare-fun stringLiteral10_ () Int)
(declare-fun stringLiteral25_ () Int)
(declare-fun System.Collections.Generic.IEnumerator_1...System.Char () Int)
(declare-fun System.Array () Int)
(declare-fun IncludedInModifiesStar_ (Int) Int)
(declare-fun nullObject () Int)
(declare-fun SExpressionSimplifier.Nary () Int)
(declare-fun subtypes (Int Int) Bool)
(declare-fun AsDirectSubClass (Int Int) Int)
(declare-fun SExpressionSimplifier.PrettySx.currentToken () Int)
(declare-fun UnknownRef_ () Int)
(declare-fun BoxTester (Int Int) Int)
(declare-fun System.Int32 () Int)
(declare-fun stringLiteral7_ () Int)
(declare-fun stringLiteral11_ () Int)
(declare-fun intGreater (Int Int) Int)
(declare-fun stringLiteral26_ () Int)
(declare-fun BeingConstructed_ () Int)
(declare-fun IsMemberlessType_ (Int) Int)
(declare-fun System.Reflection.ICustomAttributeProvider () Int)
(declare-fun DeclType (Int) Int)
(declare-fun stringLiteral8_ () Int)
(declare-fun System.String.Substring_System.Int32_System.Int32_ (Int Int Int Int) Int)
(declare-fun IsImmutable_ (Int) Int)
(declare-fun System.Text.StringBuilder.ToString_ (Int Int) Int)
(declare-fun stringLiteral12_ () Int)
(declare-fun System.Collections.ICollection () Int)
(declare-fun AsPeerField (Int) Int)
(declare-fun NonNullRefArray (Int Int) Int)
(declare-fun store1 (Int Int Int) Int)
(declare-fun Smt.false () Int)
(declare-fun store2 (Int Int Int Int) Int)
(declare-fun System.IComparable_1...System.String () Int)
(declare-fun System.String () Int)
(declare-fun CONCVARSYM (Int) Int)
(declare-fun stringLiteral9_ () Int)
(declare-fun System.Boolean () Int)
(declare-fun stringLiteral28_ () Int)
(declare-fun int_m9223372036854775808 () Int)
(declare-fun ClassReprInv (Int) Int)
(declare-fun System.IDisposable () Int)
(declare-fun SExpressionSimplifier.Nary.Args () Int)
(declare-fun System.String.Substring_System.Int32_System.Int32_.1 (Int Int Int) Int)
(declare-fun System.String.Equals_System.String_ (Int Int Int) Int)
(declare-fun ValueArray (Int Int) Int)
(declare-fun boolIff (Int Int) Int)
(declare-fun SExpressionSimplifier.Atom.S_ (Int) Int)
(declare-fun System.String.IsInterned_System.String_notnull_ (Int Int) Int)
(declare-fun ArrayCategory_ (Int) Int)
(declare-fun System.Int64 () Int)
(declare-fun ElementType_ (Int) Int)
(assert (distinct allocated_ elements_ inv_ localinv_ exposeVersion_ sharingMode_ SharingMode_Unshared_ SharingMode_LockProtected_ ownerRef_ ownerFrame_ PeerGroupPlaceholder_ ArrayCategoryValue_ ArrayCategoryRef_ ArrayCategoryNonNullRef_ System.Array System.Object System.Type BeingConstructed_ NonNullFieldsAreInitialized_ System.String FirstConsistentOwner_ System.SByte System.Byte System.Int16 System.UInt16 System.Int32 System.UInt32 System.Int64 System.UInt64 System.Char System.UIntPtr System.IntPtr int_m2147483648 int_2147483647 int_4294967295 int_m9223372036854775808 int_9223372036854775807 int_18446744073709551615 UnknownRef_ SExpressionSimplifier.Atom.S SExpressionSimplifier.PrettySx.currentToken SExpressionSimplifier.PrettySx.currentTokenString SExpressionSimplifier.Nary.F SExpressionSimplifier.Nary.Args System.Reflection.MemberInfo System.Collections.IEnumerator System.Text.StringBuilder System.IComparable System.Collections.Generic.IEnumerable_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.Generic.IEnumerable_1...System.Char System.CharEnumerator System.Collections.Generic.ICollection_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.ICollection System.IDisposable System.Runtime.InteropServices._Type System.Collections.IEnumerable SExpressionSimplifier.Atom System.Collections.Generic.IList_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.ICloneable SExpressionSimplifier.Sx System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.IComparable_1...System.String System.Runtime.Serialization.ISerializable System.IO.TextReader System.Collections.IList System.IEquatable_1...System.String System.Boolean SExpressionSimplifier.Nary System.MarshalByRefObject System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator System.Collections.Generic.IEnumerator_1...System.Char SExpressionSimplifier.PrettySx.Token SExpressionSimplifier.PrettySx System.IO.TextWriter System.Reflection.ICustomAttributeProvider System.IConvertible System.Reflection.IReflect System.Runtime.InteropServices._MemberInfo stringLiteral3_ stringLiteral4_ stringLiteral5_ stringLiteral6_ stringLiteral7_ stringLiteral8_ stringLiteral9_ stringLiteral10_ stringLiteral11_ stringLiteral12_ stringLiteral14_ stringLiteral15_ stringLiteral16_ stringLiteral17_ stringLiteral19_ stringLiteral21_ stringLiteral22_ stringLiteral23_ stringLiteral24_ stringLiteral25_ stringLiteral26_ stringLiteral28_ stringLiteral29_ stringLiteral30_ stringLiteral33_ stringLiteral35_ stringLiteral36_ stringLiteral37_))
(assert (= (DeclType exposeVersion_) System.Object))
(assert (forall ((?c Int)) (! (= (ClassReprInv (ClassRepr ?c)) ?c) :pattern ((ClassRepr ?c)) )))
(assert (forall ((?T Int)) (not (subtypes (typeof_ (ClassRepr ?T)) System.Object))))
(assert (forall ((?T Int)) (not (= (ClassRepr ?T) nullObject))))
(assert (forall ((?T Int) (?h Int)) (! (=> (= (IsHeap ?h) Smt.true) (= (select2 ?h (ClassRepr ?T) ownerFrame_) PeerGroupPlaceholder_)) :pattern ((select2 ?h (ClassRepr ?T) ownerFrame_)) )))
(assert (not (= (IsDirectlyModifiableField allocated_) Smt.true)))
(assert (= (IsDirectlyModifiableField elements_) Smt.true))
(assert (not (= (IsDirectlyModifiableField inv_) Smt.true)))
(assert (not (= (IsDirectlyModifiableField localinv_) Smt.true)))
(assert (not (= (IsDirectlyModifiableField ownerRef_) Smt.true)))
(assert (not (= (IsDirectlyModifiableField ownerFrame_) Smt.true)))
(assert (not (= (IsDirectlyModifiableField exposeVersion_) Smt.true)))
(assert (not (= (IsStaticField allocated_) Smt.true)))
(assert (not (= (IsStaticField elements_) Smt.true)))
(assert (not (= (IsStaticField inv_) Smt.true)))
(assert (not (= (IsStaticField localinv_) Smt.true)))
(assert (not (= (IsStaticField exposeVersion_) Smt.true)))
(assert (not (= (IncludedInModifiesStar_ ownerRef_) Smt.true)))
(assert (not (= (IncludedInModifiesStar_ ownerFrame_) Smt.true)))
(assert (= (IncludedInModifiesStar_ exposeVersion_) Smt.true))
(assert (= (IncludedInModifiesStar_ elements_) Smt.true))
(assert (forall ((?A Int) (?i Int) (?x Int)) (= (ValueArrayGet (ValueArraySet ?A ?i ?x) ?i) ?x)))
(assert (forall ((?A Int) (?i Int) (?j Int) (?x Int)) (=> (not (= ?i ?j)) (= (ValueArrayGet (ValueArraySet ?A ?i ?x) ?j) (ValueArrayGet ?A ?j)))))
(assert (forall ((?A Int) (?i Int) (?x Int)) (= (RefArrayGet (RefArraySet ?A ?i ?x) ?i) ?x)))
(assert (forall ((?A Int) (?i Int) (?j Int) (?x Int)) (=> (not (= ?i ?j)) (= (RefArrayGet (RefArraySet ?A ?i ?x) ?j) (RefArrayGet ?A ?j)))))
(assert (forall ((?a Int) (?d Int) (?x Int) (?y Int) (|?x'| Int) (|?y'| Int)) (! (=> (= (ArrayIndex ?a ?d ?x ?y) (ArrayIndex ?a ?d |?x'| |?y'|)) (and (= ?x |?x'|) (= ?y |?y'|))) :pattern ((ArrayIndex ?a ?d ?x ?y) (ArrayIndex ?a ?d |?x'| |?y'|)) )))
(assert (forall ((?a Int) (?i Int) (?heap Int)) (! (let ((?v_0 (RefArrayGet (select2 ?heap ?a elements_) ?i))) (=> (and (= (IsHeap ?heap) Smt.true) (not (= ?v_0 nullObject))) (subtypes (typeof_ ?v_0) (ElementType_ (typeof_ ?a))))) :pattern ((typeof_ (RefArrayGet (select2 ?heap ?a elements_) ?i))) )))
(assert (forall ((?a Int) (?T Int) (?i Int) (?r Int) (?heap Int)) (! (=> (and (= (IsHeap ?heap) Smt.true) (subtypes (typeof_ ?a) (NonNullRefArray ?T ?r))) (not (= (RefArrayGet (select2 ?heap ?a elements_) ?i) nullObject))) :pattern ((subtypes (typeof_ ?a) (NonNullRefArray ?T ?r)) (RefArrayGet (select2 ?heap ?a elements_) ?i)) )))
(assert (forall ((?a Int)) (<= 1 (Rank_ ?a))))
(assert (forall ((?a Int) (?T Int) (?r Int)) (! (=> (and (not (= ?a nullObject)) (subtypes (typeof_ ?a) (RefArray ?T ?r))) (= (Rank_ ?a) ?r)) :pattern ((subtypes (typeof_ ?a) (RefArray ?T ?r))) )))
(assert (forall ((?a Int) (?T Int) (?r Int)) (! (=> (and (not (= ?a nullObject)) (subtypes (typeof_ ?a) (NonNullRefArray ?T ?r))) (= (Rank_ ?a) ?r)) :pattern ((subtypes (typeof_ ?a) (NonNullRefArray ?T ?r))) )))
(assert (forall ((?a Int) (?T Int) (?r Int)) (! (=> (and (not (= ?a nullObject)) (subtypes (typeof_ ?a) (ValueArray ?T ?r))) (= (Rank_ ?a) ?r)) :pattern ((subtypes (typeof_ ?a) (ValueArray ?T ?r))) )))
(assert (forall ((?a Int)) (! (let ((?v_0 (Length_ ?a))) (and (<= 0 ?v_0) (<= ?v_0 int_2147483647))) :pattern ((Length_ ?a)) )))
(assert (forall ((?a Int) (?i Int)) (<= 0 (DimLength_ ?a ?i))))
(assert (forall ((?a Int)) (! (=> (= (Rank_ ?a) 1) (= (DimLength_ ?a 0) (Length_ ?a))) :pattern ((DimLength_ ?a 0)) )))
(assert (forall ((?a Int) (?i Int)) (! (= (LBound_ ?a ?i) 0) :pattern ((LBound_ ?a ?i)) )))
(assert (forall ((?a Int) (?i Int)) (! (= (UBound_ ?a ?i) (- (DimLength_ ?a ?i) 1)) :pattern ((UBound_ ?a ?i)) )))
(assert (forall ((?T Int) (?ET Int) (?r Int)) (! (=> (subtypes ?T (ValueArray ?ET ?r)) (= (ArrayCategory_ ?T) ArrayCategoryValue_)) :pattern ((subtypes ?T (ValueArray ?ET ?r))) )))
(assert (forall ((?T Int) (?ET Int) (?r Int)) (! (=> (subtypes ?T (RefArray ?ET ?r)) (= (ArrayCategory_ ?T) ArrayCategoryRef_)) :pattern ((subtypes ?T (RefArray ?ET ?r))) )))
(assert (forall ((?T Int) (?ET Int) (?r Int)) (! (=> (subtypes ?T (NonNullRefArray ?ET ?r)) (= (ArrayCategory_ ?T) ArrayCategoryNonNullRef_)) :pattern ((subtypes ?T (NonNullRefArray ?ET ?r))) )))
(assert (subtypes System.Array System.Object))
(assert (forall ((?T Int) (?r Int)) (! (let ((?v_0 (ValueArray ?T ?r))) (and (subtypes ?v_0 ?v_0) (subtypes ?v_0 System.Array))) :pattern ((ValueArray ?T ?r)) )))
(assert (forall ((?T Int) (?r Int)) (! (let ((?v_0 (RefArray ?T ?r))) (and (subtypes ?v_0 ?v_0) (subtypes ?v_0 System.Array))) :pattern ((RefArray ?T ?r)) )))
(assert (forall ((?T Int) (?r Int)) (! (let ((?v_0 (NonNullRefArray ?T ?r))) (and (subtypes ?v_0 ?v_0) (subtypes ?v_0 System.Array))) :pattern ((NonNullRefArray ?T ?r)) )))
(assert (forall ((?T Int) (?U Int) (?r Int)) (=> (subtypes ?U ?T) (subtypes (RefArray ?U ?r) (RefArray ?T ?r)))))
(assert (forall ((?T Int) (?U Int) (?r Int)) (=> (subtypes ?U ?T) (subtypes (NonNullRefArray ?U ?r) (NonNullRefArray ?T ?r)))))
(assert (forall ((?A Int) (?r Int)) (= (ElementType_ (ValueArray ?A ?r)) ?A)))
(assert (forall ((?A Int) (?r Int)) (= (ElementType_ (RefArray ?A ?r)) ?A)))
(assert (forall ((?A Int) (?r Int)) (= (ElementType_ (NonNullRefArray ?A ?r)) ?A)))
(assert (forall ((?A Int) (?r Int) (?T Int)) (! (let ((?v_0 (ElementType_ ?T))) (=> (subtypes ?T (RefArray ?A ?r)) (and (= ?T (RefArray ?v_0 ?r)) (subtypes ?v_0 ?A)))) :pattern ((subtypes ?T (RefArray ?A ?r))) )))
(assert (forall ((?A Int) (?r Int) (?T Int)) (! (let ((?v_0 (ElementType_ ?T))) (=> (subtypes ?T (NonNullRefArray ?A ?r)) (and (= ?T (NonNullRefArray ?v_0 ?r)) (subtypes ?v_0 ?A)))) :pattern ((subtypes ?T (NonNullRefArray ?A ?r))) )))
(assert (forall ((?A Int) (?r Int) (?T Int)) (! (let ((?v_0 (ValueArray ?A ?r))) (=> (subtypes ?T ?v_0) (= ?T ?v_0))) :pattern ((subtypes ?T (ValueArray ?A ?r))) )))
(assert (forall ((?A Int) (?r Int) (?T Int)) (! (let ((?v_0 (ElementType_ ?T))) (=> (subtypes (RefArray ?A ?r) ?T) (or (subtypes System.Array ?T) (and (= ?T (RefArray ?v_0 ?r)) (subtypes ?A ?v_0))))) :pattern ((subtypes (RefArray ?A ?r) ?T)) )))
(assert (forall ((?A Int) (?r Int) (?T Int)) (! (let ((?v_0 (ElementType_ ?T))) (=> (subtypes (NonNullRefArray ?A ?r) ?T) (or (subtypes System.Array ?T) (and (= ?T (NonNullRefArray ?v_0 ?r)) (subtypes ?A ?v_0))))) :pattern ((subtypes (NonNullRefArray ?A ?r) ?T)) )))
(assert (forall ((?A Int) (?r Int) (?T Int)) (! (let ((?v_0 (ValueArray ?A ?r))) (=> (subtypes ?v_0 ?T) (or (subtypes System.Array ?T) (= ?T ?v_0)))) :pattern ((subtypes (ValueArray ?A ?r) ?T)) )))
(assert (forall ((?s Int) (?f Int) (?x Int)) (= (StructGet_ (StructSet_ ?s ?f ?x) ?f) ?x)))
(assert (forall ((?s Int) (?f Int) (|?f'| Int) (?x Int)) (=> (not (= ?f |?f'|)) (= (StructGet_ (StructSet_ ?s ?f ?x) |?f'|) (StructGet_ ?s |?f'|)))))
(assert (forall ((?T Int)) (! (let ((?v_0 (BaseClass_ ?T))) (and (subtypes ?T ?v_0) (=> (not (= ?T System.Object)) (not (= ?T ?v_0))))) :pattern ((BaseClass_ ?T)) )))
(assert (forall ((?A Int) (?B Int) (?C Int)) (! (=> (subtypes ?C (AsDirectSubClass ?B ?A)) (= (OneClassDown ?C ?A) ?B)) :pattern ((subtypes ?C (AsDirectSubClass ?B ?A))) )))
(assert (forall ((?T Int)) (=> (= (IsValueType_ ?T) Smt.true) (and (forall ((?U Int)) (=> (subtypes ?T ?U) (= ?T ?U))) (forall ((?U Int)) (=> (subtypes ?U ?T) (= ?T ?U)))))))
(assert (subtypes System.Type System.Object))
(assert (forall ((?T Int)) (! (= (IsNotNull_ (TypeObject ?T) System.Type) Smt.true) :pattern ((TypeObject ?T)) )))
(assert (forall ((?T Int)) (! (= (TypeName (TypeObject ?T)) ?T) :pattern ((TypeObject ?T)) )))
(assert (forall ((?o Int) (?T Int)) (! (= (= (Is_ ?o ?T) Smt.true) (or (= ?o nullObject) (subtypes (typeof_ ?o) ?T))) :pattern ((Is_ ?o ?T)) )))
(assert (forall ((?o Int) (?T Int)) (! (= (= (IsNotNull_ ?o ?T) Smt.true) (and (not (= ?o nullObject)) (= (Is_ ?o ?T) Smt.true))) :pattern ((IsNotNull_ ?o ?T)) )))
(assert (forall ((?o Int) (?T Int)) (=> (= (Is_ ?o ?T) Smt.true) (= (As_ ?o ?T) ?o))))
(assert (forall ((?o Int) (?T Int)) (=> (not (= (Is_ ?o ?T) Smt.true)) (= (As_ ?o ?T) nullObject))))
(assert (forall ((?h Int) (?o Int)) (! (let ((?v_0 (typeof_ ?o))) (=> (and (= (IsHeap ?h) Smt.true) (not (= ?o nullObject)) (subtypes ?v_0 System.Array)) (and (= (select2 ?h ?o inv_) ?v_0) (= (select2 ?h ?o localinv_) ?v_0)))) :pattern ((subtypes (typeof_ ?o) System.Array) (select2 ?h ?o inv_)) )))
(assert (forall ((?h Int) (?o Int) (?f Int)) (! (=> (and (= (IsHeap ?h) Smt.true) (= (select2 ?h ?o allocated_) Smt.true)) (= (IsAllocated ?h (select2 ?h ?o ?f)) Smt.true)) :pattern ((IsAllocated ?h (select2 ?h ?o ?f))) )))
(assert (forall ((?h Int) (?o Int) (?f Int)) (! (=> (and (= (IsHeap ?h) Smt.true) (= (select2 ?h ?o allocated_) Smt.true)) (= (select2 ?h (select2 ?h ?o ?f) allocated_) Smt.true)) :pattern ((select2 ?h (select2 ?h ?o ?f) allocated_)) )))
(assert (forall ((?h Int) (?s Int) (?f Int)) (! (=> (= (IsAllocated ?h ?s) Smt.true) (= (IsAllocated ?h (StructGet_ ?s ?f)) Smt.true)) :pattern ((IsAllocated ?h (StructGet_ ?s ?f))) )))
(assert (forall ((?h Int) (?e Int) (?i Int)) (! (=> (= (IsAllocated ?h ?e) Smt.true) (= (IsAllocated ?h (RefArrayGet ?e ?i)) Smt.true)) :pattern ((IsAllocated ?h (RefArrayGet ?e ?i))) )))
(assert (forall ((?h Int) (?e Int) (?i Int)) (! (=> (= (IsAllocated ?h ?e) Smt.true) (= (IsAllocated ?h (ValueArrayGet ?e ?i)) Smt.true)) :pattern ((IsAllocated ?h (ValueArrayGet ?e ?i))) )))
(assert (forall ((?h Int) (?o Int)) (! (=> (= (IsAllocated ?h ?o) Smt.true) (= (select2 ?h ?o allocated_) Smt.true)) :pattern ((select2 ?h ?o allocated_)) )))
(assert (forall ((?h Int) (?c Int)) (! (=> (= (IsHeap ?h) Smt.true) (= (select2 ?h (ClassRepr ?c) allocated_) Smt.true)) :pattern ((select2 ?h (ClassRepr ?c) allocated_)) )))
(assert (forall ((?f Int) (?T Int)) (! (=> (= (AsNonNullRefField ?f ?T) ?f) (= (AsRefField ?f ?T) ?f)) :pattern ((AsNonNullRefField ?f ?T)) )))
(assert (forall ((?h Int) (?o Int) (?f Int) (?T Int)) (! (=> (= (IsHeap ?h) Smt.true) (= (Is_ (select2 ?h ?o (AsRefField ?f ?T)) ?T) Smt.true)) :pattern ((select2 ?h ?o (AsRefField ?f ?T))) )))
(assert (forall ((?h Int) (?o Int) (?f Int) (?T Int)) (! (=> (and (= (IsHeap ?h) Smt.true) (not (= ?o nullObject)) (or (not (= ?o BeingConstructed_)) (= (= (select2 ?h BeingConstructed_ NonNullFieldsAreInitialized_) Smt.true) true))) (not (= (select2 ?h ?o (AsNonNullRefField ?f ?T)) nullObject))) :pattern ((select2 ?h ?o (AsNonNullRefField ?f ?T))) )))
(assert (forall ((?h Int) (?o Int) (?f Int) (?T Int)) (! (=> (= (IsHeap ?h) Smt.true) (InRange (select2 ?h ?o (AsRangeField ?f ?T)) ?T)) :pattern ((select2 ?h ?o (AsRangeField ?f ?T))) )))
(assert (forall ((?o Int)) (! (not (= (IsMemberlessType_ (typeof_ ?o)) Smt.true)) :pattern ((IsMemberlessType_ (typeof_ ?o))) )))
(assert (not (= (IsImmutable_ System.Object) Smt.true)))
(assert (forall ((?T Int) (?U Int)) (! (=> (subtypes ?U (AsImmutable_ ?T)) (and (= (IsImmutable_ ?U) Smt.true) (= (AsImmutable_ ?U) ?U))) :pattern ((subtypes ?U (AsImmutable_ ?T))) )))
(assert (forall ((?T Int) (?U Int)) (! (=> (subtypes ?U (AsMutable_ ?T)) (and (not (= (IsImmutable_ ?U) Smt.true)) (= (AsMutable_ ?U) ?U))) :pattern ((subtypes ?U (AsMutable_ ?T))) )))
(assert (forall ((?o Int) (?T Int)) (! (=> (and (not (= ?o nullObject)) (not (= ?o BeingConstructed_)) (subtypes (typeof_ ?o) (AsImmutable_ ?T))) (forall ((?h Int)) (! (let ((?v_0 (typeof_ ?o))) (=> (= (IsHeap ?h) Smt.true) (and (= (select2 ?h ?o inv_) ?v_0) (= (select2 ?h ?o localinv_) ?v_0) (= (select2 ?h ?o ownerFrame_) PeerGroupPlaceholder_) (= (AsOwner ?o (select2 ?h ?o ownerRef_)) ?o) (forall ((?t Int)) (! (=> (= (AsOwner ?o (select2 ?h ?t ownerRef_)) ?o) (or (= ?t ?o) (not (= (select2 ?h ?t ownerFrame_) PeerGroupPlaceholder_)))) :pattern ((AsOwner ?o (select2 ?h ?t ownerRef_))) ))))) :pattern ((IsHeap ?h)) ))) :pattern ((subtypes (typeof_ ?o) (AsImmutable_ ?T))) )))
(assert (forall ((?s Int)) (! (<= 0 (StringLength_ ?s)) :pattern ((StringLength_ ?s)) )))
(assert (forall ((?h Int) (?o Int) (?f Int) (?T Int)) (! (let ((?v_0 (select2 ?h ?o (AsRepField ?f ?T)))) (=> (and (= (IsHeap ?h) Smt.true) (not (= ?v_0 nullObject))) (and (= (select2 ?h ?v_0 ownerRef_) ?o) (= (select2 ?h ?v_0 ownerFrame_) ?T)))) :pattern ((select2 ?h ?o (AsRepField ?f ?T))) )))
(assert (forall ((?h Int) (?o Int) (?f Int)) (! (let ((?v_0 (select2 ?h ?o (AsPeerField ?f)))) (=> (and (= (IsHeap ?h) Smt.true) (not (= ?v_0 nullObject))) (and (= (select2 ?h ?v_0 ownerRef_) (select2 ?h ?o ownerRef_)) (= (select2 ?h ?v_0 ownerFrame_) (select2 ?h ?o ownerFrame_))))) :pattern ((select2 ?h ?o (AsPeerField ?f))) )))
(assert (forall ((?h Int) (?o Int)) (! (let ((?v_0 (select2 ?h ?o ownerFrame_)) (?v_1 (select2 ?h ?o ownerRef_)) (?v_2 (typeof_ ?o))) (=> (and (= (IsHeap ?h) Smt.true) (not (= ?v_0 PeerGroupPlaceholder_)) (subtypes (select2 ?h ?v_1 inv_) ?v_0) (not (= (select2 ?h ?v_1 localinv_) (BaseClass_ ?v_0)))) (and (= (select2 ?h ?o inv_) ?v_2) (= (select2 ?h ?o localinv_) ?v_2)))) :pattern ((subtypes (select2 ?h (select2 ?h ?o ownerRef_) inv_) (select2 ?h ?o ownerFrame_))) )))
(assert (forall ((?o Int) (?f Int) (?h Int)) (! (let ((?v_0 (select2 ?h ?o ownerFrame_)) (?v_1 (select2 ?h ?o ownerRef_))) (=> (and (= (IsHeap ?h) Smt.true) (not (= ?o nullObject)) (= (= (select2 ?h ?o allocated_) Smt.true) true) (not (= ?v_0 PeerGroupPlaceholder_)) (subtypes (select2 ?h ?v_1 inv_) ?v_0) (not (= (select2 ?h ?v_1 localinv_) (BaseClass_ ?v_0)))) (= (select2 ?h ?o ?f) (FieldDependsOnFCO_ ?o ?f (select2 ?h (select2 ?h ?o FirstConsistentOwner_) exposeVersion_))))) :pattern ((select2 ?h (AsPureObject_ ?o) ?f)) )))
(assert (forall ((?o Int) (?h Int)) (! (let ((?v_0 (select2 ?h ?o ownerFrame_)) (?v_1 (select2 ?h ?o ownerRef_)) (?v_2 (select2 ?h ?o FirstConsistentOwner_))) (let ((?v_3 (select2 ?h ?v_2 ownerFrame_)) (?v_4 (select2 ?h ?v_2 ownerRef_))) (=> (and (= (IsHeap ?h) Smt.true) (not (= ?o nullObject)) (= (= (select2 ?h ?o allocated_) Smt.true) true) (not (= ?v_0 PeerGroupPlaceholder_)) (subtypes (select2 ?h ?v_1 inv_) ?v_0) (not (= (select2 ?h ?v_1 localinv_) (BaseClass_ ?v_0)))) (and (not (= ?v_2 nullObject)) (= (= (select2 ?h ?v_2 allocated_) Smt.true) true) (or (= ?v_3 PeerGroupPlaceholder_) (not (subtypes (select2 ?h ?v_4 inv_) ?v_3)) (= (select2 ?h ?v_4 localinv_) (BaseClass_ ?v_3))))))) :pattern ((select2 ?h ?o FirstConsistentOwner_)) )))
(assert (forall ((?x Int) (?p Int)) (! (= (Unbox (Box ?x ?p)) ?x) :pattern ((Unbox (Box ?x ?p))) )))
(assert (forall ((?p Int)) (! (=> (= (IsValueType_ (UnboxedType ?p)) Smt.true) (forall ((?heap Int) (?x Int)) (! (let ((?v_0 (Box ?x ?p))) (let ((?v_1 (typeof_ ?v_0))) (=> (= (IsHeap ?heap) Smt.true) (and (= (select2 ?heap ?v_0 inv_) ?v_1) (= (select2 ?heap ?v_0 localinv_) ?v_1))))) :pattern ((select2 ?heap (Box ?x ?p) inv_)) ))) :pattern ((IsValueType_ (UnboxedType ?p))) )))
(assert (forall ((?x Int) (?p Int)) (! (let ((?v_0 (Box ?x ?p))) (=> (and (subtypes (UnboxedType ?v_0) System.Object) (= ?v_0 ?p)) (= ?x ?p))) :pattern ((subtypes (UnboxedType (Box ?x ?p)) System.Object)) )))
(assert (forall ((?p Int) (?typ Int)) (! (= (= (UnboxedType ?p) ?typ) (not (= (BoxTester ?p ?typ) nullObject))) :pattern ((BoxTester ?p ?typ)) )))
(assert (= (IsValueType_ System.SByte) Smt.true))
(assert (= (IsValueType_ System.Byte) Smt.true))
(assert (= (IsValueType_ System.Int16) Smt.true))
(assert (= (IsValueType_ System.UInt16) Smt.true))
(assert (= (IsValueType_ System.Int32) Smt.true))
(assert (= (IsValueType_ System.UInt32) Smt.true))
(assert (= (IsValueType_ System.Int64) Smt.true))
(assert (= (IsValueType_ System.UInt64) Smt.true))
(assert (= (IsValueType_ System.Char) Smt.true))
(assert (= (IsValueType_ System.UIntPtr) Smt.true))
(assert (= (IsValueType_ System.IntPtr) Smt.true))
(assert (< int_m9223372036854775808 int_m2147483648))
(assert (< int_m2147483648 (- 0 100000)))
(assert (< 100000 int_2147483647))
(assert (< int_2147483647 int_4294967295))
(assert (< int_4294967295 int_9223372036854775807))
(assert (< int_9223372036854775807 int_18446744073709551615))
(assert (= (+ int_m9223372036854775808 1) (- 0 int_9223372036854775807)))
(assert (= (+ int_m2147483648 1) (- 0 int_2147483647)))
(assert (forall ((?i Int)) (= (InRange ?i System.SByte) (and (<= (- 0 128) ?i) (< ?i 128)))))
(assert (forall ((?i Int)) (= (InRange ?i System.Byte) (and (<= 0 ?i) (< ?i 256)))))
(assert (forall ((?i Int)) (= (InRange ?i System.Int16) (and (<= (- 0 32768) ?i) (< ?i 32768)))))
(assert (forall ((?i Int)) (= (InRange ?i System.UInt16) (and (<= 0 ?i) (< ?i 65536)))))
(assert (forall ((?i Int)) (= (InRange ?i System.Int32) (and (<= int_m2147483648 ?i) (<= ?i int_2147483647)))))
(assert (forall ((?i Int)) (= (InRange ?i System.UInt32) (and (<= 0 ?i) (<= ?i int_4294967295)))))
(assert (forall ((?i Int)) (= (InRange ?i System.Int64) (and (<= int_m9223372036854775808 ?i) (<= ?i int_9223372036854775807)))))
(assert (forall ((?i Int)) (= (InRange ?i System.UInt64) (and (<= 0 ?i) (<= ?i int_18446744073709551615)))))
(assert (forall ((?i Int)) (= (InRange ?i System.Char) (and (<= 0 ?i) (< ?i 65536)))))
(assert (forall ((?z Int) (?B Int) (?C Int)) (=> (InRange ?z ?C) (= (IntToInt_ ?z ?B ?C) ?z))))
(assert (forall ((?b Int) (?x Int) (?y Int)) (! (=> (= ?b Smt.true) (= (IfThenElse_ ?b ?x ?y) ?x)) :pattern ((IfThenElse_ ?b ?x ?y)) )))
(assert (forall ((?b Int) (?x Int) (?y Int)) (! (=> (not (= ?b Smt.true)) (= (IfThenElse_ ?b ?x ?y) ?y)) :pattern ((IfThenElse_ ?b ?x ?y)) )))
(assert (forall ((?x Int) (?y Int)) (! (= (modulo ?x ?y) (- ?x (multiply (divide ?x ?y) ?y))) :pattern ((modulo ?x ?y))  :pattern ((divide ?x ?y)) )))
(assert (forall ((?x Int) (?y Int)) (! (let ((?v_0 (modulo ?x ?y))) (=> (and (<= 0 ?x) (< 0 ?y)) (and (<= 0 ?v_0) (< ?v_0 ?y)))) :pattern ((modulo ?x ?y)) )))
(assert (forall ((?x Int) (?y Int)) (! (let ((?v_0 (modulo ?x ?y))) (=> (and (<= 0 ?x) (< ?y 0)) (and (<= 0 ?v_0) (< ?v_0 (- 0 ?y))))) :pattern ((modulo ?x ?y)) )))
(assert (forall ((?x Int) (?y Int)) (! (let ((?v_0 (modulo ?x ?y))) (=> (and (<= ?x 0) (< 0 ?y)) (and (< (- 0 ?y) ?v_0) (<= ?v_0 0)))) :pattern ((modulo ?x ?y)) )))
(assert (forall ((?x Int) (?y Int)) (! (let ((?v_0 (modulo ?x ?y))) (=> (and (<= ?x 0) (< ?y 0)) (and (< ?y ?v_0) (<= ?v_0 0)))) :pattern ((modulo ?x ?y)) )))
(assert (forall ((?x Int) (?y Int)) (! (=> (and (<= 0 ?x) (<= 0 ?y)) (= (modulo (+ ?x ?y) ?y) (modulo ?x ?y))) :pattern ((modulo (+ ?x ?y) ?y)) )))
(assert (forall ((?x Int) (?y Int)) (! (=> (and (<= 0 ?x) (<= 0 ?y)) (= (modulo (+ ?y ?x) ?y) (modulo ?x ?y))) :pattern ((modulo (+ ?y ?x) ?y)) )))
(assert (forall ((?x Int) (?y Int)) (! (let ((?v_0 (- ?x ?y))) (=> (and (<= 0 ?v_0) (<= 0 ?y)) (= (modulo ?v_0 ?y) (modulo ?x ?y)))) :pattern ((modulo (- ?x ?y) ?y)) )))
(assert (forall ((?a Int) (?b Int) (?d Int)) (! (=> (and (<= 2 ?d) (= (modulo ?a ?d) (modulo ?b ?d)) (< ?a ?b)) (<= (+ ?a ?d) ?b)) :pattern ((modulo ?a ?d) (modulo ?b ?d)) )))
(assert (forall ((?x Int) (?y Int)) (! (=> (or (<= 0 ?x) (<= 0 ?y)) (<= 0 (and_ ?x ?y))) :pattern ((and_ ?x ?y)) )))
(assert (forall ((?x Int) (?y Int)) (! (let ((?v_0 (or_ ?x ?y))) (=> (and (<= 0 ?x) (<= 0 ?y)) (and (<= 0 ?v_0) (<= ?v_0 (+ ?x ?y))))) :pattern ((or_ ?x ?y)) )))
(assert (forall ((?i Int)) (! (= (shl_ ?i 0) ?i) :pattern ((shl_ ?i 0)) )))
(assert (forall ((?i Int) (?j Int)) (=> (<= 0 ?j) (= (shl_ ?i (+ ?j 1)) (* (shl_ ?i ?j) 2)))))
(assert (forall ((?i Int) (?j Int)) (let ((?v_0 (shl_ ?i ?j))) (=> (and (<= 0 ?i) (< ?i 32768) (<= 0 ?j) (<= ?j 16)) (and (<= 0 ?v_0) (<= ?v_0 int_2147483647))))))
(assert (forall ((?i Int)) (! (= (shr_ ?i 0) ?i) :pattern ((shr_ ?i 0)) )))
(assert (forall ((?i Int) (?j Int)) (=> (<= 0 ?j) (= (shr_ ?i (+ ?j 1)) (divide (shr_ ?i ?j) 2)))))
(assert (forall ((?h Int) (?a Int) (?b Int)) (! (= (= (System.String.Equals_System.String_ ?h ?a ?b) Smt.true) (= (System.String.Equals_System.String_System.String_ ?h ?a ?b) Smt.true)) :pattern ((System.String.Equals_System.String_ ?h ?a ?b)) )))
(assert (forall ((?h Int) (?a Int) (?b Int)) (! (let ((?v_0 (= (System.String.Equals_System.String_System.String_ ?h ?a ?b) Smt.true)) (?v_1 (= (StringEquals_ ?a ?b) Smt.true))) (and (= ?v_0 ?v_1) (= ?v_0 (= (StringEquals_ ?b ?a) Smt.true)) (=> (= ?a ?b) ?v_1))) :pattern ((System.String.Equals_System.String_System.String_ ?h ?a ?b)) )))
(assert (forall ((?a Int) (?b Int) (?c Int)) (=> (and (= (StringEquals_ ?a ?b) Smt.true) (= (StringEquals_ ?b ?c) Smt.true)) (= (StringEquals_ ?a ?c) Smt.true))))
(assert (forall ((?h Int) (?a Int) (?b Int)) (! (=> (and (not (= ?a nullObject)) (not (= ?b nullObject)) (= (System.String.Equals_System.String_System.String_ ?h ?a ?b) Smt.true)) (= (System.String.IsInterned_System.String_notnull_ ?h ?a) (System.String.IsInterned_System.String_notnull_ ?h ?b))) :pattern ((System.String.Equals_System.String_System.String_ ?h ?a ?b)) )))
(assert (not (= (IsStaticField SExpressionSimplifier.PrettySx.currentToken) Smt.true)))
(assert (= (IsDirectlyModifiableField SExpressionSimplifier.PrettySx.currentToken) Smt.true))
(assert (= (IncludedInModifiesStar_ SExpressionSimplifier.PrettySx.currentToken) Smt.true))
(assert (= (DeclType SExpressionSimplifier.PrettySx.currentToken) SExpressionSimplifier.PrettySx))
(assert (= (AsRangeField SExpressionSimplifier.PrettySx.currentToken SExpressionSimplifier.PrettySx.Token) SExpressionSimplifier.PrettySx.currentToken))
(assert (not (= (IsStaticField SExpressionSimplifier.PrettySx.currentTokenString) Smt.true)))
(assert (= (IsDirectlyModifiableField SExpressionSimplifier.PrettySx.currentTokenString) Smt.true))
(assert (= (IncludedInModifiesStar_ SExpressionSimplifier.PrettySx.currentTokenString) Smt.true))
(assert (= (DeclType SExpressionSimplifier.PrettySx.currentTokenString) SExpressionSimplifier.PrettySx))
(assert (= (AsRefField SExpressionSimplifier.PrettySx.currentTokenString System.String) SExpressionSimplifier.PrettySx.currentTokenString))
(assert (not (= (IsStaticField SExpressionSimplifier.Atom.S) Smt.true)))
(assert (= (IsDirectlyModifiableField SExpressionSimplifier.Atom.S) Smt.true))
(assert (= (IncludedInModifiesStar_ SExpressionSimplifier.Atom.S) Smt.true))
(assert (= (DeclType SExpressionSimplifier.Atom.S) SExpressionSimplifier.Atom))
(assert (= (AsNonNullRefField SExpressionSimplifier.Atom.S System.String) SExpressionSimplifier.Atom.S))
(assert (forall ((?heap_ Int) (?r_ Int)) (! (=> (= (IsHeap ?heap_) Smt.true) (= (select2 ?heap_ ?r_ SExpressionSimplifier.Atom.S) (SExpressionSimplifier.Atom.S_ ?r_))) :pattern ((select2 ?heap_ ?r_ SExpressionSimplifier.Atom.S)) )))
(assert (not (= (IsStaticField SExpressionSimplifier.Nary.F) Smt.true)))
(assert (= (IsDirectlyModifiableField SExpressionSimplifier.Nary.F) Smt.true))
(assert (= (IncludedInModifiesStar_ SExpressionSimplifier.Nary.F) Smt.true))
(assert (= (DeclType SExpressionSimplifier.Nary.F) SExpressionSimplifier.Nary))
(assert (= (AsNonNullRefField SExpressionSimplifier.Nary.F System.String) SExpressionSimplifier.Nary.F))
(assert (forall ((?heap_ Int) (?r_ Int)) (! (=> (= (IsHeap ?heap_) Smt.true) (= (select2 ?heap_ ?r_ SExpressionSimplifier.Nary.F) (SExpressionSimplifier.Nary.F_ ?r_))) :pattern ((select2 ?heap_ ?r_ SExpressionSimplifier.Nary.F)) )))
(assert (not (= (IsStaticField SExpressionSimplifier.Nary.Args) Smt.true)))
(assert (= (IsDirectlyModifiableField SExpressionSimplifier.Nary.Args) Smt.true))
(assert (= (IncludedInModifiesStar_ SExpressionSimplifier.Nary.Args) Smt.true))
(assert (= (AsRepField SExpressionSimplifier.Nary.Args SExpressionSimplifier.Nary) SExpressionSimplifier.Nary.Args))
(assert (= (DeclType SExpressionSimplifier.Nary.Args) SExpressionSimplifier.Nary))
(assert (= (AsNonNullRefField SExpressionSimplifier.Nary.Args System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx) SExpressionSimplifier.Nary.Args))
(assert (forall ((?heap_ Int) (?r_ Int)) (! (=> (= (IsHeap ?heap_) Smt.true) (= (select2 ?heap_ ?r_ SExpressionSimplifier.Nary.Args) (SExpressionSimplifier.Nary.Args_ ?r_))) :pattern ((select2 ?heap_ ?r_ SExpressionSimplifier.Nary.Args)) )))
(assert (subtypes SExpressionSimplifier.PrettySx SExpressionSimplifier.PrettySx))
(assert (= (BaseClass_ SExpressionSimplifier.PrettySx) System.Object))
(assert (= (AsDirectSubClass SExpressionSimplifier.PrettySx (BaseClass_ SExpressionSimplifier.PrettySx)) SExpressionSimplifier.PrettySx))
(assert (not (= (IsImmutable_ SExpressionSimplifier.PrettySx) Smt.true)))
(assert (= (AsMutable_ SExpressionSimplifier.PrettySx) SExpressionSimplifier.PrettySx))
(assert (forall ((?U_ Int)) (! (=> (subtypes ?U_ SExpressionSimplifier.PrettySx.Token) (= ?U_ SExpressionSimplifier.PrettySx.Token)) :pattern ((subtypes ?U_ SExpressionSimplifier.PrettySx.Token)) )))
(assert (subtypes System.IO.TextReader System.IO.TextReader))
(assert (subtypes System.MarshalByRefObject System.MarshalByRefObject))
(assert (= (BaseClass_ System.MarshalByRefObject) System.Object))
(assert (= (AsDirectSubClass System.MarshalByRefObject (BaseClass_ System.MarshalByRefObject)) System.MarshalByRefObject))
(assert (not (= (IsImmutable_ System.MarshalByRefObject) Smt.true)))
(assert (= (AsMutable_ System.MarshalByRefObject) System.MarshalByRefObject))
(assert (= (IsMemberlessType_ System.MarshalByRefObject) Smt.true))
(assert (= (BaseClass_ System.IO.TextReader) System.MarshalByRefObject))
(assert (= (AsDirectSubClass System.IO.TextReader (BaseClass_ System.IO.TextReader)) System.IO.TextReader))
(assert (not (= (IsImmutable_ System.IO.TextReader) Smt.true)))
(assert (= (AsMutable_ System.IO.TextReader) System.IO.TextReader))
(assert (subtypes System.IDisposable System.Object))
(assert (= (IsMemberlessType_ System.IDisposable) Smt.true))
(assert (subtypes System.IO.TextReader System.IDisposable))
(assert (= (IsMemberlessType_ System.IO.TextReader) Smt.true))
(assert (forall ((?Heap_ Int)) (! (let ((?v_0 (System.Console.get_In_ ?Heap_))) (=> (= (IsHeap ?Heap_) Smt.true) (and (= (select2 ?Heap_ ?v_0 allocated_) Smt.true) (= (IsNotNull_ ?v_0 System.IO.TextReader) Smt.true) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?v_0 ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?v_0 ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))))) :pattern ((System.Console.get_In_ ?Heap_)) )))
(assert (subtypes System.IO.TextWriter System.IO.TextWriter))
(assert (= (BaseClass_ System.IO.TextWriter) System.MarshalByRefObject))
(assert (= (AsDirectSubClass System.IO.TextWriter (BaseClass_ System.IO.TextWriter)) System.IO.TextWriter))
(assert (not (= (IsImmutable_ System.IO.TextWriter) Smt.true)))
(assert (= (AsMutable_ System.IO.TextWriter) System.IO.TextWriter))
(assert (subtypes System.IO.TextWriter System.IDisposable))
(assert (= (IsMemberlessType_ System.IO.TextWriter) Smt.true))
(assert (forall ((?Heap_ Int)) (! (let ((?v_0 (System.Console.get_Out_ ?Heap_))) (=> (= (IsHeap ?Heap_) Smt.true) (and (= (select2 ?Heap_ ?v_0 allocated_) Smt.true) (= (IsNotNull_ ?v_0 System.IO.TextWriter) Smt.true) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?v_0 ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?v_0 ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))))) :pattern ((System.Console.get_Out_ ?Heap_)) )))
(assert (forall ((?U_ Int)) (! (=> (subtypes ?U_ System.Boolean) (= ?U_ System.Boolean)) :pattern ((subtypes ?U_ System.Boolean)) )))
(assert (subtypes SExpressionSimplifier.Sx SExpressionSimplifier.Sx))
(assert (= (BaseClass_ SExpressionSimplifier.Sx) System.Object))
(assert (= (AsDirectSubClass SExpressionSimplifier.Sx (BaseClass_ SExpressionSimplifier.Sx)) SExpressionSimplifier.Sx))
(assert (= (IsImmutable_ SExpressionSimplifier.Sx) Smt.true))
(assert (= (AsImmutable_ SExpressionSimplifier.Sx) SExpressionSimplifier.Sx))
(assert (= (IsMemberlessType_ SExpressionSimplifier.Sx) Smt.true))
(assert (subtypes SExpressionSimplifier.Atom SExpressionSimplifier.Atom))
(assert (= (BaseClass_ SExpressionSimplifier.Atom) SExpressionSimplifier.Sx))
(assert (= (AsDirectSubClass SExpressionSimplifier.Atom (BaseClass_ SExpressionSimplifier.Atom)) SExpressionSimplifier.Atom))
(assert (= (IsImmutable_ SExpressionSimplifier.Atom) Smt.true))
(assert (= (AsImmutable_ SExpressionSimplifier.Atom) SExpressionSimplifier.Atom))
(assert (forall ((?U_ Int)) (! (=> (subtypes ?U_ SExpressionSimplifier.Atom) (= ?U_ SExpressionSimplifier.Atom)) :pattern ((subtypes ?U_ SExpressionSimplifier.Atom)) )))
(assert (subtypes SExpressionSimplifier.Nary SExpressionSimplifier.Nary))
(assert (= (BaseClass_ SExpressionSimplifier.Nary) SExpressionSimplifier.Sx))
(assert (= (AsDirectSubClass SExpressionSimplifier.Nary (BaseClass_ SExpressionSimplifier.Nary)) SExpressionSimplifier.Nary))
(assert (= (IsImmutable_ SExpressionSimplifier.Nary) Smt.true))
(assert (= (AsImmutable_ SExpressionSimplifier.Nary) SExpressionSimplifier.Nary))
(assert (forall ((?U_ Int)) (! (=> (subtypes ?U_ SExpressionSimplifier.Nary) (= ?U_ SExpressionSimplifier.Nary)) :pattern ((subtypes ?U_ SExpressionSimplifier.Nary)) )))
(assert (forall ((?U_ Int)) (! (=> (subtypes ?U_ SExpressionSimplifier.Sx) (or (= ?U_ SExpressionSimplifier.Sx) (subtypes ?U_ SExpressionSimplifier.Atom) (subtypes ?U_ SExpressionSimplifier.Nary))) :pattern ((subtypes ?U_ SExpressionSimplifier.Sx)) )))
(assert (subtypes System.String System.String))
(assert (= (BaseClass_ System.String) System.Object))
(assert (= (AsDirectSubClass System.String (BaseClass_ System.String)) System.String))
(assert (= (IsImmutable_ System.String) Smt.true))
(assert (= (AsImmutable_ System.String) System.String))
(assert (subtypes System.IComparable System.Object))
(assert (= (IsMemberlessType_ System.IComparable) Smt.true))
(assert (subtypes System.String System.IComparable))
(assert (subtypes System.ICloneable System.Object))
(assert (= (IsMemberlessType_ System.ICloneable) Smt.true))
(assert (subtypes System.String System.ICloneable))
(assert (subtypes System.IConvertible System.Object))
(assert (= (IsMemberlessType_ System.IConvertible) Smt.true))
(assert (subtypes System.String System.IConvertible))
(assert (subtypes System.IComparable_1...System.String System.Object))
(assert (= (IsMemberlessType_ System.IComparable_1...System.String) Smt.true))
(assert (subtypes System.String System.IComparable_1...System.String))
(assert (subtypes System.Collections.Generic.IEnumerable_1...System.Char System.Object))
(assert (subtypes System.Collections.IEnumerable System.Object))
(assert (= (IsMemberlessType_ System.Collections.IEnumerable) Smt.true))
(assert (subtypes System.Collections.Generic.IEnumerable_1...System.Char System.Collections.IEnumerable))
(assert (= (IsMemberlessType_ System.Collections.Generic.IEnumerable_1...System.Char) Smt.true))
(assert (subtypes System.String System.Collections.Generic.IEnumerable_1...System.Char))
(assert (subtypes System.String System.Collections.IEnumerable))
(assert (subtypes System.IEquatable_1...System.String System.Object))
(assert (= (IsMemberlessType_ System.IEquatable_1...System.String) Smt.true))
(assert (subtypes System.String System.IEquatable_1...System.String))
(assert (forall ((?U_ Int)) (! (=> (subtypes ?U_ System.String) (= ?U_ System.String)) :pattern ((subtypes ?U_ System.String)) )))
(assert (subtypes System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx))
(assert (= (BaseClass_ System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx) System.Object))
(assert (= (AsDirectSubClass System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx (BaseClass_ System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx)) System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx))
(assert (not (= (IsImmutable_ System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx) Smt.true)))
(assert (= (AsMutable_ System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx) System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx))
(assert (subtypes System.Collections.Generic.IList_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Object))
(assert (subtypes System.Collections.Generic.ICollection_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Object))
(assert (subtypes System.Collections.Generic.IEnumerable_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Object))
(assert (subtypes System.Collections.Generic.IEnumerable_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.IEnumerable))
(assert (= (IsMemberlessType_ System.Collections.Generic.IEnumerable_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx) Smt.true))
(assert (subtypes System.Collections.Generic.ICollection_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.Generic.IEnumerable_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx))
(assert (subtypes System.Collections.Generic.ICollection_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.IEnumerable))
(assert (= (IsMemberlessType_ System.Collections.Generic.ICollection_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx) Smt.true))
(assert (subtypes System.Collections.Generic.IList_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.Generic.ICollection_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx))
(assert (subtypes System.Collections.Generic.IList_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.Generic.IEnumerable_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx))
(assert (subtypes System.Collections.Generic.IList_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.IEnumerable))
(assert (= (IsMemberlessType_ System.Collections.Generic.IList_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx) Smt.true))
(assert (subtypes System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.Generic.IList_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx))
(assert (subtypes System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.Generic.ICollection_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx))
(assert (subtypes System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.Generic.IEnumerable_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx))
(assert (subtypes System.Collections.IList System.Object))
(assert (subtypes System.Collections.ICollection System.Object))
(assert (subtypes System.Collections.ICollection System.Collections.IEnumerable))
(assert (= (IsMemberlessType_ System.Collections.ICollection) Smt.true))
(assert (subtypes System.Collections.IList System.Collections.ICollection))
(assert (subtypes System.Collections.IList System.Collections.IEnumerable))
(assert (= (IsMemberlessType_ System.Collections.IList) Smt.true))
(assert (subtypes System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.IList))
(assert (subtypes System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.ICollection))
(assert (subtypes System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx System.Collections.IEnumerable))
(assert (subtypes System.Type System.Type))
(assert (subtypes System.Reflection.MemberInfo System.Reflection.MemberInfo))
(assert (= (BaseClass_ System.Reflection.MemberInfo) System.Object))
(assert (= (AsDirectSubClass System.Reflection.MemberInfo (BaseClass_ System.Reflection.MemberInfo)) System.Reflection.MemberInfo))
(assert (= (IsImmutable_ System.Reflection.MemberInfo) Smt.true))
(assert (= (AsImmutable_ System.Reflection.MemberInfo) System.Reflection.MemberInfo))
(assert (subtypes System.Reflection.ICustomAttributeProvider System.Object))
(assert (= (IsMemberlessType_ System.Reflection.ICustomAttributeProvider) Smt.true))
(assert (subtypes System.Reflection.MemberInfo System.Reflection.ICustomAttributeProvider))
(assert (subtypes System.Runtime.InteropServices._MemberInfo System.Object))
(assert (= (IsMemberlessType_ System.Runtime.InteropServices._MemberInfo) Smt.true))
(assert (subtypes System.Reflection.MemberInfo System.Runtime.InteropServices._MemberInfo))
(assert (= (IsMemberlessType_ System.Reflection.MemberInfo) Smt.true))
(assert (= (BaseClass_ System.Type) System.Reflection.MemberInfo))
(assert (= (AsDirectSubClass System.Type (BaseClass_ System.Type)) System.Type))
(assert (= (IsImmutable_ System.Type) Smt.true))
(assert (= (AsImmutable_ System.Type) System.Type))
(assert (subtypes System.Runtime.InteropServices._Type System.Object))
(assert (= (IsMemberlessType_ System.Runtime.InteropServices._Type) Smt.true))
(assert (subtypes System.Type System.Runtime.InteropServices._Type))
(assert (subtypes System.Reflection.IReflect System.Object))
(assert (= (IsMemberlessType_ System.Reflection.IReflect) Smt.true))
(assert (subtypes System.Type System.Reflection.IReflect))
(assert (= (IsMemberlessType_ System.Type) Smt.true))
(assert (subtypes System.Text.StringBuilder System.Text.StringBuilder))
(assert (= (BaseClass_ System.Text.StringBuilder) System.Object))
(assert (= (AsDirectSubClass System.Text.StringBuilder (BaseClass_ System.Text.StringBuilder)) System.Text.StringBuilder))
(assert (not (= (IsImmutable_ System.Text.StringBuilder) Smt.true)))
(assert (= (AsMutable_ System.Text.StringBuilder) System.Text.StringBuilder))
(assert (subtypes System.Runtime.Serialization.ISerializable System.Object))
(assert (= (IsMemberlessType_ System.Runtime.Serialization.ISerializable) Smt.true))
(assert (subtypes System.Text.StringBuilder System.Runtime.Serialization.ISerializable))
(assert (forall ((?U_ Int)) (! (=> (subtypes ?U_ System.Text.StringBuilder) (= ?U_ System.Text.StringBuilder)) :pattern ((subtypes ?U_ System.Text.StringBuilder)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (=> (and (= (IsHeap ?Heap_) Smt.true) (forall ((?pc_ Int)) (let ((?v_0 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_0) (= (select2 ?Heap_ ?pc_ localinv_) ?v_0)))))) (InRange (System.Text.StringBuilder.get_Length_ ?Heap_ ?this) System.Int32)) :pattern ((System.Text.StringBuilder.get_Length_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (let ((?v_0 (typeof_ ?this))) (=> (and (not (= ?this nullObject)) (subtypes ?v_0 System.Text.StringBuilder) (= (select2 ?Heap_ ?this inv_) ?v_0) (= (select2 ?Heap_ ?this localinv_) ?v_0) (= (IsHeap ?Heap_) Smt.true) (= (select2 ?Heap_ ?this allocated_) Smt.true)) (= (System.Text.StringBuilder.get_Length_ ?Heap_ ?this) (System.Text.StringBuilder.get_Length_.1 (select2 ?Heap_ ?this exposeVersion_))))) :pattern ((System.Text.StringBuilder.get_Length_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (let ((?v_0 (System.Text.StringBuilder.ToString_ ?Heap_ ?this))) (=> (and (= (IsHeap ?Heap_) Smt.true) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))) (and (= (select2 ?Heap_ ?v_0 allocated_) Smt.true) (= (IsNotNull_ ?v_0 System.String) Smt.true) (forall ((?pc_ Int)) (let ((?v_2 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?v_0 ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?v_0 ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_2) (= (select2 ?Heap_ ?pc_ localinv_) ?v_2)))))))) :pattern ((System.Text.StringBuilder.ToString_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (let ((?v_0 (typeof_ ?this))) (=> (and (not (= ?this nullObject)) (subtypes ?v_0 System.Text.StringBuilder) (= (select2 ?Heap_ ?this inv_) ?v_0) (= (select2 ?Heap_ ?this localinv_) ?v_0) (= (IsHeap ?Heap_) Smt.true) (= (select2 ?Heap_ ?this allocated_) Smt.true)) (= (System.Text.StringBuilder.ToString_ ?Heap_ ?this) (System.Text.StringBuilder.ToString_.1 (select2 ?Heap_ ?this exposeVersion_))))) :pattern ((System.Text.StringBuilder.ToString_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int) (?c_in Int)) (! (=> (and (= (IsHeap ?Heap_) Smt.true) (InRange ?c_in System.Char)) true) :pattern ((System.Char.IsWhiteSpace_System.Char_ ?Heap_ ?c_in)) )))
(assert (forall ((?Heap_ Int) (?this Int) (?index_in Int)) (! (=> (and (= (IsHeap ?Heap_) Smt.true) (InRange ?index_in System.Int32) (forall ((?pc_ Int)) (let ((?v_0 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_0) (= (select2 ?Heap_ ?pc_ localinv_) ?v_0)))))) (InRange (System.String.get_Chars_System.Int32_ ?Heap_ ?this ?index_in) System.Char)) :pattern ((System.String.get_Chars_System.Int32_ ?Heap_ ?this ?index_in)) )))
(assert (forall ((?Heap_ Int) (?this Int) (?index_in Int)) (! (let ((?v_0 (typeof_ ?this))) (=> (and (not (= ?this nullObject)) (subtypes ?v_0 System.String) (= (select2 ?Heap_ ?this inv_) ?v_0) (= (select2 ?Heap_ ?this localinv_) ?v_0) (= (IsHeap ?Heap_) Smt.true) (= (select2 ?Heap_ ?this allocated_) Smt.true)) (= (System.String.get_Chars_System.Int32_ ?Heap_ ?this ?index_in) (System.String.get_Chars_System.Int32_.1 (select2 ?Heap_ ?this exposeVersion_) ?index_in)))) :pattern ((System.String.get_Chars_System.Int32_ ?Heap_ ?this ?index_in)) )))
(assert (forall ((?Heap_ Int) (?this Int) (?startIndex_in Int) (?length_in Int)) (! (let ((?v_0 (System.String.Substring_System.Int32_System.Int32_ ?Heap_ ?this ?startIndex_in ?length_in))) (=> (and (= (IsHeap ?Heap_) Smt.true) (InRange ?startIndex_in System.Int32) (InRange ?length_in System.Int32) (<= 0 ?startIndex_in) (<= 0 ?length_in) (<= (+ ?startIndex_in ?length_in) (StringLength_ ?this)) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))) (and (= (select2 ?Heap_ ?v_0 allocated_) Smt.true) (= (IsNotNull_ ?v_0 System.String) Smt.true) (forall ((?pc_ Int)) (let ((?v_2 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?v_0 ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?v_0 ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_2) (= (select2 ?Heap_ ?pc_ localinv_) ?v_2)))))))) :pattern ((System.String.Substring_System.Int32_System.Int32_ ?Heap_ ?this ?startIndex_in ?length_in)) )))
(assert (forall ((?Heap_ Int) (?this Int) (?startIndex_in Int) (?length_in Int)) (! (let ((?v_0 (typeof_ ?this))) (=> (and (not (= ?this nullObject)) (subtypes ?v_0 System.String) (= (select2 ?Heap_ ?this inv_) ?v_0) (= (select2 ?Heap_ ?this localinv_) ?v_0) (= (IsHeap ?Heap_) Smt.true) (= (select2 ?Heap_ ?this allocated_) Smt.true)) (= (System.String.Substring_System.Int32_System.Int32_ ?Heap_ ?this ?startIndex_in ?length_in) (System.String.Substring_System.Int32_System.Int32_.1 (select2 ?Heap_ ?this exposeVersion_) ?startIndex_in ?length_in)))) :pattern ((System.String.Substring_System.Int32_System.Int32_ ?Heap_ ?this ?startIndex_in ?length_in)) )))
(assert (forall ((?Heap_ Int) (?a_in Int) (?b_in Int)) (! (=> (and (= (IsHeap ?Heap_) Smt.true) (= (Is_ ?a_in System.String) Smt.true) (= (Is_ ?b_in System.String) Smt.true) (or (= ?a_in nullObject) (forall ((?pc_ Int)) (let ((?v_0 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?a_in ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?a_in ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_0) (= (select2 ?Heap_ ?pc_ localinv_) ?v_0)))))) (or (= ?b_in nullObject) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?b_in ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?b_in ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1))))))) true) :pattern ((System.String.Equals_System.String_System.String_ ?Heap_ ?a_in ?b_in)) )))
(assert (subtypes System.CharEnumerator System.CharEnumerator))
(assert (= (BaseClass_ System.CharEnumerator) System.Object))
(assert (= (AsDirectSubClass System.CharEnumerator (BaseClass_ System.CharEnumerator)) System.CharEnumerator))
(assert (not (= (IsImmutable_ System.CharEnumerator) Smt.true)))
(assert (= (AsMutable_ System.CharEnumerator) System.CharEnumerator))
(assert (subtypes System.CharEnumerator System.ICloneable))
(assert (subtypes System.Collections.Generic.IEnumerator_1...System.Char System.Object))
(assert (subtypes System.Collections.Generic.IEnumerator_1...System.Char System.IDisposable))
(assert (subtypes System.Collections.IEnumerator System.Object))
(assert (= (IsMemberlessType_ System.Collections.IEnumerator) Smt.true))
(assert (subtypes System.Collections.Generic.IEnumerator_1...System.Char System.Collections.IEnumerator))
(assert (= (IsMemberlessType_ System.Collections.Generic.IEnumerator_1...System.Char) Smt.true))
(assert (subtypes System.CharEnumerator System.Collections.Generic.IEnumerator_1...System.Char))
(assert (subtypes System.CharEnumerator System.IDisposable))
(assert (subtypes System.CharEnumerator System.Collections.IEnumerator))
(assert (forall ((?U_ Int)) (! (=> (subtypes ?U_ System.CharEnumerator) (= ?U_ System.CharEnumerator)) :pattern ((subtypes ?U_ System.CharEnumerator)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (let ((?v_0 (System.String.GetEnumerator_ ?Heap_ ?this))) (=> (and (= (IsHeap ?Heap_) Smt.true) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))) (and (= (select2 ?Heap_ ?v_0 allocated_) Smt.true) (= (IsNotNull_ ?v_0 System.CharEnumerator) Smt.true) (forall ((?pc_ Int)) (let ((?v_2 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?v_0 ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?v_0 ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_2) (= (select2 ?Heap_ ?pc_ localinv_) ?v_2)))))))) :pattern ((System.String.GetEnumerator_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (=> (and (= (IsHeap ?Heap_) Smt.true) (forall ((?pc_ Int)) (let ((?v_0 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_0) (= (select2 ?Heap_ ?pc_ localinv_) ?v_0)))))) (InRange (System.CharEnumerator.get_Current_ ?Heap_ ?this) System.Char)) :pattern ((System.CharEnumerator.get_Current_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (let ((?v_0 (typeof_ ?this))) (=> (and (not (= ?this nullObject)) (subtypes ?v_0 System.CharEnumerator) (= (select2 ?Heap_ ?this inv_) ?v_0) (= (select2 ?Heap_ ?this localinv_) ?v_0) (= (IsHeap ?Heap_) Smt.true) (= (select2 ?Heap_ ?this allocated_) Smt.true)) (= (System.CharEnumerator.get_Current_ ?Heap_ ?this) (System.CharEnumerator.get_Current_.1 (select2 ?Heap_ ?this exposeVersion_))))) :pattern ((System.CharEnumerator.get_Current_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int) (?c_in Int)) (! (=> (and (= (IsHeap ?Heap_) Smt.true) (InRange ?c_in System.Char)) true) :pattern ((System.Char.IsLetterOrDigit_System.Char_ ?Heap_ ?c_in)) )))
(assert (forall ((?Heap_ Int) (?str0_in Int) (?str1_in Int)) (! (let ((?v_0 (System.String.Concat_System.String_System.String_ ?Heap_ ?str0_in ?str1_in))) (=> (and (= (IsHeap ?Heap_) Smt.true) (= (Is_ ?str0_in System.String) Smt.true) (= (Is_ ?str1_in System.String) Smt.true) (or (= ?str0_in nullObject) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?str0_in ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?str0_in ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))) (or (= ?str1_in nullObject) (forall ((?pc_ Int)) (let ((?v_2 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?str1_in ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?str1_in ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_2) (= (select2 ?Heap_ ?pc_ localinv_) ?v_2))))))) (and (= (select2 ?Heap_ ?v_0 allocated_) Smt.true) (= (IsNotNull_ ?v_0 System.String) Smt.true) (forall ((?pc_ Int)) (let ((?v_3 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?v_0 ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?v_0 ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_3) (= (select2 ?Heap_ ?pc_ localinv_) ?v_3)))))))) :pattern ((System.String.Concat_System.String_System.String_ ?Heap_ ?str0_in ?str1_in)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (=> (and (= (IsHeap ?Heap_) Smt.true) (forall ((?pc_ Int)) (let ((?v_0 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_0) (= (select2 ?Heap_ ?pc_ localinv_) ?v_0)))))) true) :pattern ((SExpressionSimplifier.Sx.get_IsTrue_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (let ((?v_0 (typeof_ ?this))) (=> (and (not (= ?this nullObject)) (subtypes ?v_0 SExpressionSimplifier.Sx) (= (select2 ?Heap_ ?this inv_) ?v_0) (= (select2 ?Heap_ ?this localinv_) ?v_0) (= (IsHeap ?Heap_) Smt.true) (= (select2 ?Heap_ ?this allocated_) Smt.true)) (= (= (SExpressionSimplifier.Sx.get_IsTrue_ ?Heap_ ?this) Smt.true) (= (SExpressionSimplifier.Sx.get_IsTrue_.1 (select2 ?Heap_ ?this exposeVersion_)) Smt.true)))) :pattern ((SExpressionSimplifier.Sx.get_IsTrue_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (=> (and (= (IsHeap ?Heap_) Smt.true) (forall ((?pc_ Int)) (let ((?v_0 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_0) (= (select2 ?Heap_ ?pc_ localinv_) ?v_0)))))) true) :pattern ((SExpressionSimplifier.Sx.get_IsFalse_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (let ((?v_0 (typeof_ ?this))) (=> (and (not (= ?this nullObject)) (subtypes ?v_0 SExpressionSimplifier.Sx) (= (select2 ?Heap_ ?this inv_) ?v_0) (= (select2 ?Heap_ ?this localinv_) ?v_0) (= (IsHeap ?Heap_) Smt.true) (= (select2 ?Heap_ ?this allocated_) Smt.true)) (= (= (SExpressionSimplifier.Sx.get_IsFalse_ ?Heap_ ?this) Smt.true) (= (SExpressionSimplifier.Sx.get_IsFalse_.1 (select2 ?Heap_ ?this exposeVersion_)) Smt.true)))) :pattern ((SExpressionSimplifier.Sx.get_IsFalse_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int)) (! (let ((?v_0 (SExpressionSimplifier.Sx.get_True_ ?Heap_))) (=> (= (IsHeap ?Heap_) Smt.true) (and (= (select2 ?Heap_ ?v_0 allocated_) Smt.true) (= (IsNotNull_ ?v_0 SExpressionSimplifier.Sx) Smt.true) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?v_0 ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?v_0 ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))))) :pattern ((SExpressionSimplifier.Sx.get_True_ ?Heap_)) )))
(assert (forall ((?Heap_ Int)) (! (let ((?v_0 (SExpressionSimplifier.Sx.get_False_ ?Heap_))) (=> (= (IsHeap ?Heap_) Smt.true) (and (= (select2 ?Heap_ ?v_0 allocated_) Smt.true) (= (IsNotNull_ ?v_0 SExpressionSimplifier.Sx) Smt.true) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?v_0 ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?v_0 ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))))) :pattern ((SExpressionSimplifier.Sx.get_False_ ?Heap_)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (let ((?v_0 (System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.get_Count_ ?Heap_ ?this))) (=> (and (= (IsHeap ?Heap_) Smt.true) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))) (and (InRange ?v_0 System.Int32) (>= ?v_0 0)))) :pattern ((System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.get_Count_ ?Heap_ ?this)) )))
(assert (forall ((?Heap_ Int) (?this Int) (?index_in Int)) (! (let ((?v_0 (System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.get_Item_System.Int32_ ?Heap_ ?this ?index_in))) (=> (and (= (IsHeap ?Heap_) Smt.true) (InRange ?index_in System.Int32) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))) (and (= (select2 ?Heap_ ?v_0 allocated_) Smt.true) (= (IsNotNull_ ?v_0 SExpressionSimplifier.Sx) Smt.true) (forall ((?pc_ Int)) (let ((?v_2 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?v_0 ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?v_0 ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_2) (= (select2 ?Heap_ ?pc_ localinv_) ?v_2)))))))) :pattern ((System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.get_Item_System.Int32_ ?Heap_ ?this ?index_in)) )))
(assert (forall ((?U_ Int)) (! (=> (subtypes ?U_ System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator) (= ?U_ System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator)) :pattern ((subtypes ?U_ System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator)) )))
(assert (forall ((?Heap_ Int) (?this Int)) (! (=> (and (= (IsHeap ?Heap_) Smt.true) (forall ((?pc_ Int)) (let ((?v_0 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_0) (= (select2 ?Heap_ ?pc_ localinv_) ?v_0)))))) (and (= (IsAllocated ?Heap_ (System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.GetEnumerator_ ?Heap_ ?this)) Smt.true) true)) :pattern ((System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.GetEnumerator_ ?Heap_ ?this)) )))
(assert (forall ((?h_ Int) (?p0_ Int)) (! (= (System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator.get_Current_ ?h_ ?p0_) (System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator.get_Current_.1 ?p0_)) :pattern ((System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator.get_Current_ ?h_ ?p0_)) )))
(assert (forall ((?Heap_ Int) (?this_in Int)) (! (let ((?v_0 (System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator.get_Current_ ?Heap_ ?this_in))) (=> (= (IsHeap ?Heap_) Smt.true) (and (= (select2 ?Heap_ ?v_0 allocated_) Smt.true) (= (IsNotNull_ ?v_0 SExpressionSimplifier.Sx) Smt.true) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?v_0 ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?v_0 ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))))) :pattern ((System.Collections.Generic.List_1...optional...Microsoft.Contracts.NonNullType.SExpressionSimplifier.Sx.Enumerator.get_Current_ ?Heap_ ?this_in)) )))
(assert (forall ((?Heap_ Int) (?this Int) (?value_in Int)) (! (=> (and (= (IsHeap ?Heap_) Smt.true) (= (Is_ ?value_in System.String) Smt.true) (forall ((?pc_ Int)) (let ((?v_0 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?this ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?this ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_0) (= (select2 ?Heap_ ?pc_ localinv_) ?v_0))))) (or (= ?value_in nullObject) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?value_in ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?value_in ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1))))))) true) :pattern ((System.String.Equals_System.String_ ?Heap_ ?this ?value_in)) )))
(assert (forall ((?Heap_ Int) (?str_in Int)) (! (let ((?v_0 (System.String.IsInterned_System.String_notnull_ ?Heap_ ?str_in))) (=> (and (= (IsHeap ?Heap_) Smt.true) (= (IsNotNull_ ?str_in System.String) Smt.true) (not (= ?str_in nullObject)) (forall ((?pc_ Int)) (let ((?v_1 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?str_in ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?str_in ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_1) (= (select2 ?Heap_ ?pc_ localinv_) ?v_1)))))) (and (= (select2 ?Heap_ ?v_0 allocated_) Smt.true) (= (Is_ ?v_0 System.String) Smt.true) (or (= ?v_0 nullObject) (forall ((?pc_ Int)) (let ((?v_2 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 ?Heap_ ?pc_ allocated_) Smt.true) (= (select2 ?Heap_ ?pc_ ownerRef_) (select2 ?Heap_ ?v_0 ownerRef_)) (= (select2 ?Heap_ ?pc_ ownerFrame_) (select2 ?Heap_ ?v_0 ownerFrame_))) (and (= (select2 ?Heap_ ?pc_ inv_) ?v_2) (= (select2 ?Heap_ ?pc_ localinv_) ?v_2))))))))) :pattern ((System.String.IsInterned_System.String_notnull_ ?Heap_ ?str_in)) )))
(assert (= (IsNotNull_ stringLiteral3_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral3_) 1))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral3_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral3_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral3_) stringLiteral3_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral3_)) )))
(assert (= (IsNotNull_ stringLiteral4_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral4_) 2))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral4_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral4_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral4_) stringLiteral4_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral4_)) )))
(assert (= (IsNotNull_ stringLiteral5_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral5_) 2))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral5_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral5_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral5_) stringLiteral5_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral5_)) )))
(assert (= (IsNotNull_ stringLiteral6_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral6_) 1))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral6_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral6_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral6_) stringLiteral6_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral6_)) )))
(assert (= (IsNotNull_ stringLiteral7_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral7_) 1))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral7_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral7_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral7_) stringLiteral7_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral7_)) )))
(assert (= (IsNotNull_ stringLiteral8_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral8_) 1))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral8_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral8_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral8_) stringLiteral8_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral8_)) )))
(assert (= (IsNotNull_ stringLiteral9_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral9_) 1))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral9_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral9_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral9_) stringLiteral9_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral9_)) )))
(assert (= (IsNotNull_ stringLiteral10_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral10_) 1))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral10_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral10_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral10_) stringLiteral10_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral10_)) )))
(assert (= (IsNotNull_ stringLiteral11_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral11_) 1))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral11_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral11_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral11_) stringLiteral11_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral11_)) )))
(assert (= (IsNotNull_ stringLiteral12_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral12_) 2))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral12_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral12_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral12_) stringLiteral12_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral12_)) )))
(assert (= (IsNotNull_ stringLiteral14_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral14_) 1))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral14_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral14_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral14_) stringLiteral14_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral14_)) )))
(assert (= (IsNotNull_ stringLiteral15_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral15_) 4))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral15_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral15_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral15_) stringLiteral15_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral15_)) )))
(assert (= (IsNotNull_ stringLiteral16_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral16_) 5))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral16_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral16_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral16_) stringLiteral16_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral16_)) )))
(assert (= (IsNotNull_ stringLiteral17_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral17_) 6))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral17_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral17_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral17_) stringLiteral17_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral17_)) )))
(assert (= (IsNotNull_ stringLiteral19_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral19_) 6))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral19_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral19_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral19_) stringLiteral19_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral19_)) )))
(assert (= (IsNotNull_ stringLiteral21_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral21_) 2))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral21_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral21_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral21_) stringLiteral21_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral21_)) )))
(assert (= (IsNotNull_ stringLiteral22_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral22_) 3))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral22_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral22_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral22_) stringLiteral22_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral22_)) )))
(assert (= (IsNotNull_ stringLiteral23_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral23_) 4))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral23_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral23_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral23_) stringLiteral23_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral23_)) )))
(assert (= (IsNotNull_ stringLiteral24_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral24_) 1))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral24_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral24_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral24_) stringLiteral24_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral24_)) )))
(assert (= (IsNotNull_ stringLiteral25_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral25_) 1))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral25_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral25_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral25_) stringLiteral25_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral25_)) )))
(assert (= (IsNotNull_ stringLiteral26_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral26_) 7))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral26_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral26_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral26_) stringLiteral26_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral26_)) )))
(assert (= (IsNotNull_ stringLiteral28_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral28_) 3))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral28_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral28_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral28_) stringLiteral28_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral28_)) )))
(assert (= (IsNotNull_ stringLiteral29_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral29_) 3))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral29_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral29_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral29_) stringLiteral29_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral29_)) )))
(assert (= (IsNotNull_ stringLiteral30_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral30_) 6))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral30_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral30_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral30_) stringLiteral30_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral30_)) )))
(assert (= (IsNotNull_ stringLiteral33_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral33_) 6))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral33_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral33_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral33_) stringLiteral33_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral33_)) )))
(assert (= (IsNotNull_ stringLiteral35_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral35_) 7))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral35_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral35_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral35_) stringLiteral35_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral35_)) )))
(assert (= (IsNotNull_ stringLiteral36_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral36_) 2))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral36_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral36_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral36_) stringLiteral36_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral36_)) )))
(assert (= (IsNotNull_ stringLiteral37_ System.String) Smt.true))
(assert (= (StringLength_ stringLiteral37_) 3))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (select2 ?heap stringLiteral37_ allocated_) Smt.true)) :pattern ((select2 ?heap stringLiteral37_ allocated_)) )))
(assert (forall ((?heap Int)) (! (=> (= (IsHeap ?heap) Smt.true) (= (System.String.IsInterned_System.String_notnull_ ?heap stringLiteral37_) stringLiteral37_)) :pattern ((System.String.IsInterned_System.String_notnull_ ?heap stringLiteral37_)) )))
(assert (forall ((?A Int) (?i Int) (?v Int)) (= (select1 (store1 ?A ?i ?v) ?i) ?v)))
(assert (forall ((?A Int) (?i Int) (?j Int) (?v Int)) (=> (not (= ?i ?j)) (= (select1 (store1 ?A ?i ?v) ?j) (select1 ?A ?j)))))
(assert (forall ((?A Int) (?o Int) (?f Int) (?v Int)) (= (select2 (store2 ?A ?o ?f ?v) ?o ?f) ?v)))
(assert (forall ((?A Int) (?o Int) (?f Int) (?p Int) (?g Int) (?v Int)) (=> (not (= ?o ?p)) (= (select2 (store2 ?A ?o ?f ?v) ?p ?g) (select2 ?A ?p ?g)))))
(assert (forall ((?A Int) (?o Int) (?f Int) (?p Int) (?g Int) (?v Int)) (=> (not (= ?f ?g)) (= (select2 (store2 ?A ?o ?f ?v) ?p ?g) (select2 ?A ?p ?g)))))
(assert (forall ((?x Int) (?y Int)) (= (= (boolIff ?x ?y) Smt.true) (= (= ?x Smt.true) (= ?y Smt.true)))))
(assert (forall ((?x Int) (?y Int)) (= (= (boolImplies ?x ?y) Smt.true) (=> (= ?x Smt.true) (= ?y Smt.true)))))
(assert (forall ((?x Int) (?y Int)) (= (= (boolAnd ?x ?y) Smt.true) (and (= ?x Smt.true) (= ?y Smt.true)))))
(assert (forall ((?x Int) (?y Int)) (= (= (boolOr ?x ?y) Smt.true) (or (= ?x Smt.true) (= ?y Smt.true)))))
(assert (forall ((?x Int)) (! (= (= (boolNot ?x) Smt.true) (not (= ?x Smt.true))) :pattern ((boolNot ?x)) )))
(assert (forall ((?x Int) (?y Int)) (= (= (anyEqual ?x ?y) Smt.true) (= ?x ?y))))
(assert (forall ((?x Int) (?y Int)) (! (= (= (anyNeq ?x ?y) Smt.true) (not (= ?x ?y))) :pattern ((anyNeq ?x ?y)) )))
(assert (forall ((?x Int) (?y Int)) (= (= (intLess ?x ?y) Smt.true) (< ?x ?y))))
(assert (forall ((?x Int) (?y Int)) (= (= (intAtMost ?x ?y) Smt.true) (<= ?x ?y))))
(assert (forall ((?x Int) (?y Int)) (= (= (intAtLeast ?x ?y) Smt.true) (>= ?x ?y))))
(assert (forall ((?x Int) (?y Int)) (= (= (intGreater ?x ?y) Smt.true) (> ?x ?y))))
(assert (distinct Smt.false Smt.true))
(assert (forall ((?t Int)) (! (subtypes ?t ?t) :pattern ((subtypes ?t ?t)) )))
(assert (forall ((?t Int) (?u Int) (?v Int)) (! (=> (and (subtypes ?t ?u) (subtypes ?u ?v)) (subtypes ?t ?v)) :pattern ((subtypes ?t ?u) (subtypes ?u ?v)) )))
(assert (forall ((?t Int) (?u Int)) (! (=> (and (subtypes ?t ?u) (subtypes ?u ?t)) (= ?t ?u)) :pattern ((subtypes ?t ?u) (subtypes ?u ?t)) )))
(assert (let ((?v_0 (select2 Heap_ wr_in ownerFrame_)) (?v_1 (select2 Heap_ wr_in ownerRef_))) (let ((?v_6 (or (= ?v_0 PeerGroupPlaceholder_) (not (subtypes (select2 Heap_ ?v_1 inv_) ?v_0)) (= (select2 Heap_ ?v_1 localinv_) (BaseClass_ ?v_0)))) (?v_7 (forall ((?pc_ Int)) (let ((?v_17 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 Heap_ ?pc_ allocated_) Smt.true) (= (select2 Heap_ ?pc_ ownerRef_) ?v_1) (= (select2 Heap_ ?pc_ ownerFrame_) ?v_0)) (and (= (select2 Heap_ ?pc_ inv_) ?v_17) (= (select2 Heap_ ?pc_ localinv_) ?v_17))))))) (let ((?v_8 (and ?v_6 ?v_7)) (?v_2 (select2 Heap_ this ownerFrame_)) (?v_3 (select2 Heap_ this ownerRef_)) (?v_4 (not (= this nullObject))) (?v_5 (not (= wr_in nullObject))) (?v_9 (select2 Heap_ stack0o_0 ownerFrame_)) (?v_10 (select2 Heap_ stack0o_0 ownerRef_))) (let ((?v_11 (or (= stack0o_0 nullObject) (and (or (= ?v_9 PeerGroupPlaceholder_) (not (subtypes (select2 Heap_ ?v_10 inv_) ?v_9)) (= (select2 Heap_ ?v_10 localinv_) (BaseClass_ ?v_9))) (forall ((?pc_ Int)) (let ((?v_18 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 Heap_ ?pc_ allocated_) Smt.true) (= (select2 Heap_ ?pc_ ownerRef_) ?v_10) (= (select2 Heap_ ?pc_ ownerFrame_) ?v_9)) (and (= (select2 Heap_ ?pc_ inv_) ?v_18) (= (select2 Heap_ ?pc_ localinv_) ?v_18)))))))) (?v_12 (forall ((?o_ Int) (?f_ Int)) (! (let ((?v_19 (select2 Heap_ ?o_ ownerFrame_)) (?v_20 (select2 Heap_ ?o_ ownerRef_))) (=> (and (not (= ?f_ inv_)) (not (= ?f_ localinv_)) (not (= ?f_ FirstConsistentOwner_)) (or (not (= (IsStaticField ?f_) Smt.true)) (not (= (IsDirectlyModifiableField ?f_) Smt.true))) (not (= ?o_ nullObject)) (= (select2 Heap_ ?o_ allocated_) Smt.true) (or (= ?v_19 PeerGroupPlaceholder_) (not (subtypes (select2 Heap_ ?v_20 inv_) ?v_19)) (= (select2 Heap_ ?v_20 localinv_) (BaseClass_ ?v_19))) (or (not (= ?o_ wr_in)) (not (subtypes (typeof_ wr_in) (DeclType ?f_))) (not (= (IncludedInModifiesStar_ ?f_) Smt.true))) true) (= (select2 Heap_ ?o_ ?f_) (select2 Heap_0_ ?o_ ?f_)))) :pattern ((select2 Heap_0_ ?o_ ?f_)) ))) (?v_13 (= ReallyLastGeneratedExit_correct Smt.true)) (?v_14 (= block27608_correct Smt.true)) (?v_15 (= block27506_correct Smt.true)) (?v_16 (= entry_correct Smt.true))) (not (=> (=> (=> true (=> (= (IsHeap Heap_) Smt.true) (=> (= (IsNotNull_ wr_in System.IO.TextWriter) Smt.true) (=> (= BeingConstructed_ nullObject) (=> ?v_8 (=> (and (or (= ?v_2 PeerGroupPlaceholder_) (not (subtypes (select2 Heap_ ?v_3 inv_) ?v_2)) (= (select2 Heap_ ?v_3 localinv_) (BaseClass_ ?v_2))) (forall ((?pc_ Int)) (let ((?v_21 (typeof_ ?pc_))) (=> (and (not (= ?pc_ nullObject)) (= (select2 Heap_ ?pc_ allocated_) Smt.true) (= (select2 Heap_ ?pc_ ownerRef_) ?v_3) (= (select2 Heap_ ?pc_ ownerFrame_) ?v_2)) (and (= (select2 Heap_ ?pc_ inv_) ?v_21) (= (select2 Heap_ ?pc_ localinv_) ?v_21)))))) (=> (= (select2 Heap_ wr_in allocated_) Smt.true) (=> true (=> (= (IsNotNull_ this SExpressionSimplifier.Atom) Smt.true) (=> (= (select2 Heap_ this allocated_) Smt.true) (=> true (=> (=> (=> true (=> true (=> true (=> (=> (=> true (=> true (and ?v_4 (=> ?v_4 (=> (= stack0o_0 (select2 Heap_ this SExpressionSimplifier.Atom.S)) (and ?v_5 (=> ?v_5 (and ?v_6 ?v_7 (=> ?v_8 (and ?v_11 (=> ?v_11 (=> (= (IsHeap Heap_0_) Smt.true) (=> (forall ((?o_ Int)) (! (let ((?v_22 (typeof_ ?o_))) (=> (and (not (= ?o_ nullObject)) (not (= (select2 Heap_ ?o_ allocated_) Smt.true)) (= (select2 Heap_0_ ?o_ allocated_) Smt.true)) (and (= (select2 Heap_0_ ?o_ inv_) ?v_22) (= (select2 Heap_0_ ?o_ localinv_) ?v_22)))) :pattern ((select2 Heap_0_ ?o_ localinv_))  :pattern ((select2 Heap_0_ ?o_ inv_)) )) (=> (forall ((?o_ Int)) (! (let ((?v_23 (select2 Heap_ ?o_ FirstConsistentOwner_))) (=> (= (select2 Heap_ ?v_23 exposeVersion_) (select2 Heap_0_ ?v_23 exposeVersion_)) (= ?v_23 (select2 Heap_0_ ?o_ FirstConsistentOwner_)))) :pattern ((select2 Heap_0_ ?o_ FirstConsistentOwner_)) )) (=> (forall ((?o_ Int) (?f_ Int)) (! (let ((?v_24 (select2 Heap_ ?o_ ownerFrame_)) (?v_25 (select2 Heap_ ?o_ ownerRef_))) (=> (and (not (= ?f_ inv_)) (not (= ?f_ localinv_)) (not (= ?f_ FirstConsistentOwner_)) (or (not (= (IsStaticField ?f_) Smt.true)) (not (= (IsDirectlyModifiableField ?f_) Smt.true))) (not (= ?o_ nullObject)) (= (select2 Heap_ ?o_ allocated_) Smt.true) (or (= ?v_24 PeerGroupPlaceholder_) (not (subtypes (select2 Heap_ ?v_25 inv_) ?v_24)) (= (select2 Heap_ ?v_25 localinv_) (BaseClass_ ?v_24))) true (or (not (= ?o_ wr_in)) (not (= ?f_ exposeVersion_)))) (= (select2 Heap_ ?o_ ?f_) (select2 Heap_0_ ?o_ ?f_)))) :pattern ((select2 Heap_0_ ?o_ ?f_)) )) (=> (forall ((?o_ Int)) (! (=> (= (select2 Heap_ ?o_ allocated_) Smt.true) (and (= (select2 Heap_ ?o_ inv_) (select2 Heap_0_ ?o_ inv_)) (= (select2 Heap_ ?o_ localinv_) (select2 Heap_0_ ?o_ localinv_)))) :pattern ((select2 Heap_0_ ?o_ localinv_))  :pattern ((select2 Heap_0_ ?o_ inv_)) )) (=> (and (forall ((?o_ Int)) (! (=> (= (select2 Heap_ ?o_ allocated_) Smt.true) (= (select2 Heap_0_ ?o_ allocated_) Smt.true)) :pattern ((select2 Heap_0_ ?o_ allocated_)) )) (forall ((?ot_ Int)) (! (let ((?v_26 (select2 Heap_ ?ot_ ownerFrame_))) (=> (and (= (select2 Heap_ ?ot_ allocated_) Smt.true) (not (= ?v_26 PeerGroupPlaceholder_))) (and (= (select2 Heap_ ?ot_ ownerRef_) (select2 Heap_0_ ?ot_ ownerRef_)) (= ?v_26 (select2 Heap_0_ ?ot_ ownerFrame_))))) :pattern ((select2 Heap_0_ ?ot_ ownerFrame_))  :pattern ((select2 Heap_0_ ?ot_ ownerRef_)) )) (= (= (select2 Heap_ BeingConstructed_ NonNullFieldsAreInitialized_) Smt.true) (= (select2 Heap_0_ BeingConstructed_ NonNullFieldsAreInitialized_) Smt.true))) (=> (forall ((?o_ Int)) (! (= (select2 Heap_ ?o_ sharingMode_) (select2 Heap_0_ ?o_ sharingMode_)) :pattern ((select2 Heap_0_ ?o_ sharingMode_)) )) (=> true (=> (=> (=> true (and ?v_12 (=> ?v_12 (=> true true)))) ?v_13) ?v_13)))))))))))))))))))) ?v_14) ?v_14)))) ?v_15) ?v_15)))))))))))) ?v_16) ?v_16)))))))
(check-sat)
(exit)
