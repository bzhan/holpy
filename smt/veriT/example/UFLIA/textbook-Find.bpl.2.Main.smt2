(set-info :smt-lib-version 2.6)
(set-logic UFLIA)
(set-info :source |
    Spec# benchmarks.  Contributed by Leonardo de Moura and Michal Moskal.
  |)
(set-info :category "industrial")
(set-info :status unsat)
(declare-fun x (Int Int) Int)
(declare-fun true_1 () Int)
(declare-fun false_1 () Int)
(declare-fun intGreater (Int Int) Int)
(declare-fun intAtLeast (Int Int) Int)
(declare-fun intAtMost (Int Int) Int)
(declare-fun intLess (Int Int) Int)
(declare-fun anyNeq (Int Int) Int)
(declare-fun anyEqual (Int Int) Int)
(declare-fun boolNot (Int) Int)
(declare-fun boolOr (Int Int) Int)
(declare-fun boolAnd (Int Int) Int)
(declare-fun boolImplies (Int Int) Int)
(declare-fun boolIff (Int Int) Int)
(declare-fun select2 (Int Int Int) Int)
(declare-fun store2 (Int Int Int Int) Int)
(declare-fun select1 (Int Int) Int)
(declare-fun store1 (Int Int Int) Int)
(declare-fun K () Int)
(declare-fun f (Int) Int)
(declare-fun call153formal_k_0 () Int)
(assert (not (or (not (forall ((?A Int) (?i Int) (?v Int)) (= (select1 (store1 ?A ?i ?v) ?i) ?v))) (not (forall ((?A Int) (?i Int) (?j Int) (?v Int)) (=> (not (= ?i ?j)) (= (select1 (store1 ?A ?i ?v) ?j) (select1 ?A ?j))))) (not (forall ((?A Int) (?o Int) (?f Int) (?v Int)) (= (select2 (store2 ?A ?o ?f ?v) ?o ?f) ?v))) (not (forall ((?A Int) (?o Int) (?f Int) (?p Int) (?g Int) (?v Int)) (=> (not (= ?o ?p)) (= (select2 (store2 ?A ?o ?f ?v) ?p ?g) (select2 ?A ?p ?g))))) (not (forall ((?A Int) (?o Int) (?f Int) (?p Int) (?g Int) (?v Int)) (=> (not (= ?f ?g)) (= (select2 (store2 ?A ?o ?f ?v) ?p ?g) (select2 ?A ?p ?g))))) (not (forall ((?x_1 Int) (?y Int)) (= (= (boolIff ?x_1 ?y) true_1) (= (= ?x_1 true_1) (= ?y true_1))))) (not (forall ((?x_1 Int) (?y Int)) (= (= (boolImplies ?x_1 ?y) true_1) (=> (= ?x_1 true_1) (= ?y true_1))))) (not (forall ((?x_1 Int) (?y Int)) (= (= (boolAnd ?x_1 ?y) true_1) (not (or (not (= ?x_1 true_1)) (not (= ?y true_1))))))) (not (forall ((?x_1 Int) (?y Int)) (= (= (boolOr ?x_1 ?y) true_1) (or (= ?x_1 true_1) (= ?y true_1))))) (not (forall ((?x_1 Int)) (! (= (= (boolNot ?x_1) true_1) (not (= ?x_1 true_1))) :pattern ((boolNot ?x_1)) ))) (not (forall ((?x_1 Int) (?y Int)) (= (= (anyEqual ?x_1 ?y) true_1) (= ?x_1 ?y)))) (not (forall ((?x_1 Int) (?y Int)) (! (= (= (anyNeq ?x_1 ?y) true_1) (not (= ?x_1 ?y))) :pattern ((anyNeq ?x_1 ?y)) ))) (not (forall ((?x_1 Int) (?y Int)) (= (= (intLess ?x_1 ?y) true_1) (< ?x_1 ?y)))) (not (forall ((?x_1 Int) (?y Int)) (= (= (intAtMost ?x_1 ?y) true_1) (<= ?x_1 ?y)))) (not (forall ((?x_1 Int) (?y Int)) (= (= (intAtLeast ?x_1 ?y) true_1) (>= ?x_1 ?y)))) (not (forall ((?x_1 Int) (?y Int)) (= (= (intGreater ?x_1 ?y) true_1) (> ?x_1 ?y)))) (not (distinct false_1 true_1)) (not (forall ((?t Int)) (! (= (x ?t ?t) true_1) :pattern ((x ?t ?t)) ))) (not (forall ((?t Int) (?u Int) (?v Int)) (! (=> (not (or (not (= (x ?t ?u) true_1)) (not (= (x ?u ?v) true_1)))) (= (x ?t ?v) true_1)) :pattern ((x ?t ?u) (x ?u ?v)) ))) (not (forall ((?t Int) (?u Int)) (! (=> (not (or (not (= (x ?t ?u) true_1)) (not (= (x ?u ?t) true_1)))) (= ?t ?u)) :pattern ((x ?t ?u) (x ?u ?t)) ))))))
(assert (not (or (not true) (not (exists ((?k Int)) (= (f ?k) K))))))
(assert (let ((?v_2 (= (f call153formal_k_0) K)) (?v_1 (forall ((?j Int)) (=> (not (or (not (< 0 ?j)) (not (< ?j 0)))) (not (= (f ?j) K))))) (?v_0 (<= 0 0))) (not (=> true (=> true (not (or (not ?v_0) (not (=> ?v_0 (not (or (not ?v_1) (not (=> ?v_1 (=> ?v_2 (=> true (=> true (not (or (not ?v_2) (not (=> ?v_2 true))))))))))))))))))))
(check-sat)
(exit)
