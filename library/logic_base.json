{
    "content": [
        {
            "T": "bool => bool => bool",
            "ascii_op": "&",
            "name": "conj",
            "ty": "def.ax",
            "unicode_op": "∧"
        },
        {
            "T": "bool => bool => bool",
            "ascii_op": "|",
            "name": "disj",
            "ty": "def.ax",
            "unicode_op": "∨"
        },
        {
            "T": "bool => bool",
            "ascii_op": "~",
            "name": "neg",
            "ty": "def.ax",
            "unicode_op": "¬"
        },
        {
            "T": "bool",
            "name": "true",
            "ty": "def.ax"
        },
        {
            "T": "bool",
            "name": "false",
            "ty": "def.ax"
        },
        {
            "T": "('a => bool) => bool",
            "name": "exists",
            "ty": "def.ax"
        },
        {
            "name": "conjI",
            "prop": "A --> B --> A & B",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "conjD1",
            "prop": "A & B --> A",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "conjD2",
            "prop": "A & B --> B",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "disjI1",
            "prop": "A --> A | B",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "disjI2",
            "prop": "B --> A | B",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "disjE",
            "prop": "A | B --> (A --> C) --> (B --> C) --> C",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool",
                "C": "bool"
            }
        },
        {
            "name": "negI",
            "prop": "(A --> false) --> ~A",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "negE",
            "prop": "~A --> A --> false",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "trueI",
            "prop": "true",
            "ty": "thm",
            "vars": {}
        },
        {
            "name": "falseE",
            "prop": "false --> A",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "exI",
            "prop": "P a --> ?a::'a. P a",
            "ty": "thm",
            "vars": {
                "P": "'a => bool",
                "a": "'a"
            }
        },
        {
            "name": "exE",
            "prop": "(?a::'a. P a) --> (!a::'a. P a --> C) --> C",
            "ty": "thm",
            "vars": {
                "C": "bool",
                "P": "'a => bool",
                "a": "'a"
            }
        },
        {
            "name": "classical",
            "prop": "A | ~A",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "arg_combination",
            "ty": "macro"
        },
        {
            "name": "fun_combination",
            "ty": "macro"
        },
        {
            "name": "beta_norm",
            "ty": "macro"
        },
        {
            "name": "apply_theorem",
            "ty": "macro"
        },
        {
            "name": "apply_theorem_for",
            "ty": "macro"
        },
        {
            "name": "rewrite_goal",
            "ty": "macro"
        },
        {
            "name": "rewrite_back_goal",
            "ty": "macro"
        }
    ],
    "imports": [],
    "name": "logic_base"
}