(set-info :smt-lib-version 2.6)
(set-logic UF)
(set-info :source |
Generated by: Andrew Reynolds
Generated on: 2017-04-28
Generator: Sledgehammer, converted to v2.6 by CVC4
Application: Verfication goals in Isabelle
Target solver: CVC4, Z3
Publications: "A Decision Procedure for (Co)Datatypes" by Andrew Reynolds and Jasmin Blanchette, CADE 2015.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unsat)


(declare-sort A$ 0)
(declare-sort Nat$ 0)
(declare-sort A_set$ 0)
(declare-sort Nat_set$ 0)
(declare-sort A_nat_fun$ 0)
(declare-sort A_bool_fun$ 0)
(declare-sort Nat_nat_fun$ 0)
(declare-sort A_a_tree_fun$ 0)
(declare-sort Nat_bool_fun$ 0)
(declare-sort A_set_a_set_fun$ 0)
(declare-sort A_tree_bool_fun$ 0)
(declare-sort Nat_nat_tree_fun$ 0)
(declare-sort A_tree_list_bool_fun$ 0)
(declare-sort A_tree_a_tree_list_fun$ 0)
(declare-sort A_bool_fun_a_bool_fun_fun$ 0)
(declare-sort A_tree_list_list_bool_fun$ 0)
(declare-sort A_tree_a_tree_list_list_fun$ 0)
(declare-sort A_tree_list_a_tree_list_fun$ 0)
(declare-sort Nat_tree_list_nat_tree_list_fun$ 0)
(declare-sort A_tree_list_a_tree_list_list_fun$ 0)
(declare-sort A_tree_list_a_tree_list_bool_fun_fun$ 0)
(declare-sort A_tree_list_list_a_tree_list_list_fun$ 0)
(declare-sort A_tree_list_a_tree_list_list_bool_fun_fun$ 0)
(declare-sort A_tree_list_list_a_tree_list_bool_fun_fun$ 0)
(declare-sort A_tree_list_list_a_tree_list_list_list_fun$ 0)
(declare-sort A_tree_list_list_a_tree_list_list_bool_fun_fun$ 0)
(declare-sort A_tree$ 0)
(declare-sort A_tree_list$ 0)
(declare-sort Nat_tree$ 0)
(declare-sort Nat_tree_list$ 0)
(declare-sort A_tree_list_list$ 0)
(declare-sort A_tree_list_list_list$ 0)
(declare-fun select$ (A_tree$) Nat$)
(declare-fun selecta$ (A_tree$) A$)
(declare-fun leaf$ (Nat$ A$) A_tree$)
(declare-fun selectb$ (A_tree$) Nat$)
(declare-fun selectc$ (A_tree$) A_tree$)
(declare-fun selectd$ (A_tree$) A_tree$)
(declare-fun innerNode$ (Nat$ A_tree$ A_tree$) A_tree$)
(declare-fun nil$ () A_tree_list$)
(declare-fun hd$ (A_tree_list$) A_tree$)
(declare-fun tl$ (A_tree_list$) A_tree_list$)
(declare-fun cons$ (A_tree$ A_tree_list$) A_tree_list$)
(declare-fun selecte$ (Nat_tree$) Nat$)
(declare-fun selectf$ (Nat_tree$) Nat$)
(declare-fun leaf$a (Nat$ Nat$) Nat_tree$)
(declare-fun selectg$ (Nat_tree$) Nat$)
(declare-fun selecth$ (Nat_tree$) Nat_tree$)
(declare-fun selecti$ (Nat_tree$) Nat_tree$)
(declare-fun innerNode$a (Nat$ Nat_tree$ Nat_tree$) Nat_tree$)
(declare-fun nil$a () Nat_tree_list$)
(declare-fun hd$a (Nat_tree_list$) Nat_tree$)
(declare-fun tl$a (Nat_tree_list$) Nat_tree_list$)
(declare-fun cons$a (Nat_tree$ Nat_tree_list$) Nat_tree_list$)
(declare-fun nil$b () A_tree_list_list$)
(declare-fun hd$b (A_tree_list_list$) A_tree_list$)
(declare-fun tl$b (A_tree_list_list$) A_tree_list_list$)
(declare-fun cons$b (A_tree_list$ A_tree_list_list$) A_tree_list_list$)
(declare-fun nil$c () A_tree_list_list_list$)
(declare-fun hd$c (A_tree_list_list_list$) A_tree_list_list$)
(declare-fun tl$c (A_tree_list_list_list$) A_tree_list_list_list$)
(declare-fun cons$c (A_tree_list_list$ A_tree_list_list_list$) A_tree_list_list_list$)
(declare-fun a$ () A$)
(declare-fun b$ () A$)
(declare-fun t$ () A_tree$)
(declare-fun u$ () A_tree$)
(declare-fun us$ () A_tree_list$)
(declare-fun uu$ (A_tree$) A_tree_list_a_tree_list_fun$)
(declare-fun bot$ () Nat_set$)
(declare-fun inf$ (Nat_set$ Nat_set$) Nat_set$)
(declare-fun sup$ (Nat_set$ Nat_set$) Nat_set$)
(declare-fun uua$ (Nat_set$) Nat_bool_fun$)
(declare-fun uub$ (A_set$) A_bool_fun$)
(declare-fun uuc$ (Nat_tree$ Nat$ Nat$ Nat$ Nat$) Nat_nat_fun$)
(declare-fun uud$ (A_tree$ A$ A$ Nat$ Nat$) A_nat_fun$)
(declare-fun w_a$ () Nat$)
(declare-fun w_b$ () Nat$)
(declare-fun accp$ (A_tree_list_a_tree_list_bool_fun_fun$) A_tree_list_bool_fun$)
(declare-fun bind$ (A_tree_list$ A_tree_a_tree_list_fun$) A_tree_list$)
(declare-fun bot$a () A_set$)
(declare-fun bot$b () A_bool_fun$)
(declare-fun bot$c () Nat$)
(declare-fun bot$d () Bool)
(declare-fun bot$e (Nat$) Bool)
(declare-fun cost$ (Nat_tree$) Nat$)
(declare-fun freq$ (Nat_tree$) Nat_nat_fun$)
(declare-fun inf$a (A_set$) A_set_a_set_fun$)
(declare-fun inf$b (A_bool_fun$) A_bool_fun_a_bool_fun_fun$)
(declare-fun plus$ (Nat$) Nat_nat_fun$)
(declare-fun sup$a (A_set$) A_set_a_set_fun$)
(declare-fun sup$b (A_bool_fun$) A_bool_fun_a_bool_fun_fun$)
(declare-fun zero$ () Nat$)
(declare-fun bind$a (A_tree_list$ A_tree_a_tree_list_list_fun$) A_tree_list_list$)
(declare-fun bind$b (A_tree_list_list$ A_tree_list_a_tree_list_fun$) A_tree_list$)
(declare-fun bind$c (A_tree_list_list$ A_tree_list_a_tree_list_list_fun$) A_tree_list_list$)
(declare-fun cost$a (A_tree$) Nat$)
(declare-fun freq$a (A_tree$) A_nat_fun$)
(declare-fun minus$ (Nat_set$ Nat_set$) Nat_set$)
(declare-fun freq_F$ (A_tree_list$) A_nat_fun$)
(declare-fun insert$ (A_tree_list$) A_tree_list_list_a_tree_list_list_fun$)
(declare-fun member$ (Nat$ Nat_set$) Bool)
(declare-fun minus$a (A_set$ A_set$) A_set$)
(declare-fun minus$b (Nat$) Nat_nat_fun$)
(declare-fun weight$ (Nat_tree$) Nat$)
(declare-fun collect$ (A_bool_fun$) A_set$)
(declare-fun freq_F$a (Nat_tree_list$ Nat$) Nat$)
(declare-fun fun_app$ (A_tree_list_a_tree_list_fun$ A_tree_list$) A_tree_list$)
(declare-fun huffman$ (Nat_tree_list$) Nat_tree$)
(declare-fun insert$a (A_tree$) A_tree_list_a_tree_list_fun$)
(declare-fun insert$b (Nat$ Nat_set$) Nat_set$)
(declare-fun insert$c (A$ A_set$) A_set$)
(declare-fun member$a (A$ A_set$) Bool)
(declare-fun n_lists$ (Nat$) A_tree_list_list_a_tree_list_list_list_fun$)
(declare-fun sublist$ (A_tree_list_list$ Nat_set$) A_tree_list_list$)
(declare-fun weight$a (A_tree$) Nat$)
(declare-fun alphabet$ (Nat_tree$) Nat_set$)
(declare-fun collect$a (Nat_bool_fun$) Nat_set$)
(declare-fun fun_app$a (Nat_bool_fun$ Nat$) Bool)
(declare-fun fun_app$b (A_bool_fun$ A$) Bool)
(declare-fun fun_app$c (Nat_nat_fun$ Nat$) Nat$)
(declare-fun fun_app$d (A_nat_fun$ A$) Nat$)
(declare-fun fun_app$e (Nat_tree_list_nat_tree_list_fun$ Nat_tree_list$) Nat_tree_list$)
(declare-fun fun_app$f (A_set_a_set_fun$ A_set$) A_set$)
(declare-fun fun_app$g (A_bool_fun_a_bool_fun_fun$ A_bool_fun$) A_bool_fun$)
(declare-fun fun_app$h (A_tree_list_list_bool_fun$ A_tree_list_list$) Bool)
(declare-fun fun_app$i (A_tree_list_a_tree_list_list_bool_fun_fun$ A_tree_list$) A_tree_list_list_bool_fun$)
(declare-fun fun_app$j (A_tree_list_bool_fun$ A_tree_list$) Bool)
(declare-fun fun_app$k (A_tree_list_list_a_tree_list_bool_fun_fun$ A_tree_list_list$) A_tree_list_bool_fun$)
(declare-fun fun_app$l (A_tree_list_list_a_tree_list_list_bool_fun_fun$ A_tree_list_list$) A_tree_list_list_bool_fun$)
(declare-fun fun_app$m (A_tree_list_a_tree_list_bool_fun_fun$ A_tree_list$) A_tree_list_bool_fun$)
(declare-fun fun_app$n (A_tree_list_list_a_tree_list_list_list_fun$ A_tree_list_list$) A_tree_list_list_list$)
(declare-fun fun_app$o (A_tree_list_a_tree_list_list_fun$ A_tree_list$) A_tree_list_list$)
(declare-fun fun_app$p (A_tree_list_list_a_tree_list_list_fun$ A_tree_list_list$) A_tree_list_list$)
(declare-fun fun_app$q (Nat_nat_tree_fun$ Nat$) Nat_tree$)
(declare-fun fun_app$r (A_a_tree_fun$ A$) A_tree$)
(declare-fun height_F$ (A_tree_list$) Nat$)
(declare-fun huffman$a (A_tree_list$) A_tree$)
(declare-fun is_empty$ (A_set$) Bool)
(declare-fun list_ex1$ (A_tree_bool_fun$) A_tree_list_bool_fun$)
(declare-fun n_lists$a (Nat$) A_tree_list_a_tree_list_list_fun$)
(declare-fun sublist$a (A_tree_list$ Nat_set$) A_tree_list$)
(declare-fun sublists$ (A_tree_list_list$) A_tree_list_list_list$)
(declare-fun swapSyms$ (Nat_tree$ Nat$ Nat$) Nat_tree$)
(declare-fun the_elem$ (A_set$) A$)
(declare-fun alphabet$a (A_tree$) A_set$)
(declare-fun list_ex1$a (A_tree_list_bool_fun$) A_tree_list_list_bool_fun$)
(declare-fun splitLeaf$ (Nat_tree$ Nat$ Nat$ Nat$ Nat$) Nat_tree$)
(declare-fun sublists$a (A_tree_list$) A_tree_list_list$)
(declare-fun swapSyms$a (A_tree$ A$) A_a_tree_fun$)
(declare-fun undefined$ () A_tree$)
(declare-fun alphabet_F$ (A_tree_list$) A_set$)
(declare-fun consistent$ (Nat_tree$) Bool)
(declare-fun insortTree$ (A_tree$) A_tree_list_a_tree_list_fun$)
(declare-fun splitLeaf$a (A_tree$ Nat$ A$ Nat$ A$) A_tree$)
(declare-fun swapLeaves$ (Nat_tree$ Nat$ Nat$ Nat$) Nat_nat_tree_fun$)
(declare-fun uniteTrees$ (A_tree$ A_tree$) A_tree$)
(declare-fun alphabet_F$a (Nat_tree_list$) Nat_set$)
(declare-fun consistent$a (A_tree$) Bool)
(declare-fun huffman_rel$ () A_tree_list_a_tree_list_bool_fun_fun$)
(declare-fun insortTree$a (Nat_tree$) Nat_tree_list_nat_tree_list_fun$)
(declare-fun splitLeaf_F$ (Nat_tree_list$ Nat$ Nat$ Nat$ Nat$) Nat_tree_list$)
(declare-fun swapLeaves$a (A_tree$ Nat$ A$ Nat$) A_a_tree_fun$)
(declare-fun consistent_F$ (A_tree_list$) Bool)
(declare-fun splitLeaf_F$a (A_tree_list$ Nat$ A$ Nat$ A$) A_tree_list$)
(declare-fun swapFourSyms$ (Nat_tree$ Nat$ Nat$ Nat$ Nat$) Nat_tree$)
(declare-fun consistent_F$a (Nat_tree_list$) Bool)
(declare-fun product_lists$ (A_tree_list_list_list$) A_tree_list_list_list$)
(declare-fun swapFourSyms$a (A_tree$ A$ A$ A$ A$) A_tree$)
(declare-fun product_lists$a (A_tree_list_list$) A_tree_list_list$)
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$)) (! (= (fun_app$ (uu$ ?v0) ?v1) (cons$ ?v0 ?v1)) :pattern ((fun_app$ (uu$ ?v0) ?v1)))))
(assert (forall ((?v0 Nat_set$) (?v1 Nat$)) (! (= (fun_app$a (uua$ ?v0) ?v1) (member$ ?v1 ?v0)) :pattern ((fun_app$a (uua$ ?v0) ?v1)))))
(assert (forall ((?v0 A_set$) (?v1 A$)) (! (= (fun_app$b (uub$ ?v0) ?v1) (member$a ?v1 ?v0)) :pattern ((fun_app$b (uub$ ?v0) ?v1)))))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$) (?v5 Nat$)) (! (= (fun_app$c (uuc$ ?v0 ?v1 ?v2 ?v3 ?v4) ?v5) (ite (= ?v5 ?v1) (ite (member$ ?v2 (alphabet$ ?v0)) ?v3 zero$) (ite (= ?v5 ?v2) (ite (member$ ?v1 (alphabet$ ?v0)) ?v4 zero$) (fun_app$c (freq$ ?v0) ?v5)))) :pattern ((fun_app$c (uuc$ ?v0 ?v1 ?v2 ?v3 ?v4) ?v5)))))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 Nat$) (?v4 Nat$) (?v5 A$)) (! (= (fun_app$d (uud$ ?v0 ?v1 ?v2 ?v3 ?v4) ?v5) (ite (= ?v5 ?v1) (ite (member$a ?v2 (alphabet$a ?v0)) ?v3 zero$) (ite (= ?v5 ?v2) (ite (member$a ?v1 (alphabet$a ?v0)) ?v4 zero$) (fun_app$d (freq$a ?v0) ?v5)))) :pattern ((fun_app$d (uud$ ?v0 ?v1 ?v2 ?v3 ?v4) ?v5)))))
(assert (not (not (member$a a$ (alphabet_F$ us$)))))
(assert (member$a a$ (alphabet$a u$)))
(assert (not (member$a a$ (alphabet$a t$))))
(assert (consistent_F$ (cons$ u$ us$)))
(assert (member$a a$ (alphabet_F$ (cons$ u$ us$))))
(assert (= (fun_app$d (freq_F$ (cons$ u$ us$)) a$) (fun_app$c (plus$ w_a$) w_b$)))
(assert (forall ((?v0 Nat$) (?v1 Nat_tree_list$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (! (=> (not (member$ ?v0 (alphabet_F$a ?v1))) (= (splitLeaf_F$ ?v1 ?v2 ?v0 ?v3 ?v4) ?v1)) :pattern ((splitLeaf_F$ ?v1 ?v2 ?v0 ?v3 ?v4)))))
(assert (forall ((?v0 A$) (?v1 A_tree_list$) (?v2 Nat$) (?v3 Nat$) (?v4 A$)) (! (=> (not (member$a ?v0 (alphabet_F$ ?v1))) (= (splitLeaf_F$a ?v1 ?v2 ?v0 ?v3 ?v4) ?v1)) :pattern ((splitLeaf_F$a ?v1 ?v2 ?v0 ?v3 ?v4)))))
(assert (=> (and (member$a a$ (alphabet_F$ us$)) (and (consistent_F$ us$) (and (not (member$a a$ (alphabet$a t$))) (= (fun_app$d (freq_F$ us$) a$) (fun_app$c (plus$ w_a$) w_b$))))) (= (splitLeaf_F$a (fun_app$ (insortTree$ t$) us$) w_a$ a$ w_b$ b$) (fun_app$ (insortTree$ t$) (splitLeaf_F$a us$ w_a$ a$ w_b$ b$)))))
(assert (forall ((?v0 Nat$) (?v1 Nat_tree_list$)) (! (=> (not (member$ ?v0 (alphabet_F$a ?v1))) (= (freq_F$a ?v1 ?v0) zero$)) :pattern ((freq_F$a ?v1 ?v0)))))
(assert (forall ((?v0 A$) (?v1 A_tree_list$)) (! (=> (not (member$a ?v0 (alphabet_F$ ?v1))) (= (fun_app$d (freq_F$ ?v1) ?v0) zero$)) :pattern ((fun_app$d (freq_F$ ?v1) ?v0)))))
(assert (forall ((?v0 Nat_tree$)) (exists ((?v1 Nat$)) (member$ ?v1 (alphabet$ ?v0)) ) ))
(assert (forall ((?v0 A_tree$)) (exists ((?v1 A$)) (member$a ?v1 (alphabet$a ?v0)) ) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat_tree_list$)) (= (alphabet_F$a (fun_app$e (insortTree$a ?v0) ?v1)) (sup$ (alphabet$ ?v0) (alphabet_F$a ?v1))) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$)) (= (alphabet_F$ (fun_app$ (insortTree$ ?v0) ?v1)) (fun_app$f (sup$a (alphabet$a ?v0)) (alphabet_F$ ?v1))) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat_tree_list$)) (! (= (alphabet_F$a (cons$a ?v0 ?v1)) (sup$ (alphabet$ ?v0) (alphabet_F$a ?v1))) :pattern ((cons$a ?v0 ?v1)))))
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$)) (! (= (alphabet_F$ (cons$ ?v0 ?v1)) (fun_app$f (sup$a (alphabet$a ?v0)) (alphabet_F$ ?v1))) :pattern ((cons$ ?v0 ?v1)))))
(assert (forall ((?v0 Nat_tree_list$)) (=> (not (= ?v0 nil$a)) (= (alphabet$ (huffman$ ?v0)) (alphabet_F$a ?v0))) ))
(assert (forall ((?v0 A_tree_list$)) (=> (not (= ?v0 nil$)) (= (alphabet$a (huffman$a ?v0)) (alphabet_F$ ?v0))) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat_tree_list$)) (= (consistent_F$a (fun_app$e (insortTree$a ?v0) ?v1)) (consistent_F$a (cons$a ?v0 ?v1))) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$)) (= (consistent_F$ (fun_app$ (insortTree$ ?v0) ?v1)) (consistent_F$ (cons$ ?v0 ?v1))) ))
(assert (= (alphabet_F$a nil$a) bot$))
(assert (= (alphabet_F$ nil$) bot$a))
(assert (forall ((?v0 Nat$) (?v1 Nat_tree$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (=> (and (member$ ?v0 (alphabet$ ?v1)) (and (member$ ?v2 (alphabet$ ?v1)) (and (member$ ?v3 (alphabet$ ?v1)) (member$ ?v4 (alphabet$ ?v1))))) (= (alphabet$ (swapFourSyms$ ?v1 ?v0 ?v2 ?v3 ?v4)) (alphabet$ ?v1))) ))
(assert (forall ((?v0 A$) (?v1 A_tree$) (?v2 A$) (?v3 A$) (?v4 A$)) (=> (and (member$a ?v0 (alphabet$a ?v1)) (and (member$a ?v2 (alphabet$a ?v1)) (and (member$a ?v3 (alphabet$a ?v1)) (member$a ?v4 (alphabet$a ?v1))))) (= (alphabet$a (swapFourSyms$a ?v1 ?v0 ?v2 ?v3 ?v4)) (alphabet$a ?v1))) ))
(assert (forall ((?v0 Nat_tree$)) (! (= (fun_app$e (insortTree$a ?v0) nil$a) (cons$a ?v0 nil$a)) :pattern ((insortTree$a ?v0)))))
(assert (forall ((?v0 A_tree$)) (! (= (fun_app$ (insortTree$ ?v0) nil$) (cons$ ?v0 nil$)) :pattern ((insortTree$ ?v0)))))
(assert (forall ((?v0 A_tree$)) (! (= (huffman$a (cons$ ?v0 nil$)) ?v0) :pattern ((uu$ ?v0)))))
(assert (forall ((?v0 Nat$)) (! (= (freq_F$a nil$a ?v0) zero$) :pattern ((freq_F$a nil$a ?v0)))))
(assert (forall ((?v0 A$)) (! (= (fun_app$d (freq_F$ nil$) ?v0) zero$) :pattern ((fun_app$d (freq_F$ nil$) ?v0)))))
(assert (= (consistent_F$ nil$) true))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (! (= (splitLeaf_F$ nil$a ?v0 ?v1 ?v2 ?v3) nil$a) :pattern ((splitLeaf_F$ nil$a ?v0 ?v1 ?v2 ?v3)))))
(assert (forall ((?v0 Nat$) (?v1 A$) (?v2 Nat$) (?v3 A$)) (! (= (splitLeaf_F$a nil$ ?v0 ?v1 ?v2 ?v3) nil$) :pattern ((splitLeaf_F$a nil$ ?v0 ?v1 ?v2 ?v3)))))
(assert (forall ((?v0 A_tree_list$)) (=> (and (=> (= ?v0 nil$) false) (and (forall ((?v1 A_tree$)) (=> (= ?v0 (cons$ ?v1 nil$)) false) ) (forall ((?v1 A_tree$) (?v2 A_tree$) (?v3 A_tree_list$)) (=> (= ?v0 (cons$ ?v1 (cons$ ?v2 ?v3))) false) ))) false) ))
(assert (forall ((?v0 A_tree_list$)) (=> (and (forall ((?v1 A_tree$)) (=> (= ?v0 (cons$ ?v1 nil$)) false) ) (and (forall ((?v1 A_tree$) (?v2 A_tree$) (?v3 A_tree_list$)) (=> (= ?v0 (cons$ ?v1 (cons$ ?v2 ?v3))) false) ) (=> (= ?v0 nil$) false))) false) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat_tree_list$)) (not (= (fun_app$e (insortTree$a ?v0) ?v1) nil$a)) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$)) (not (= (fun_app$ (insortTree$ ?v0) ?v1) nil$)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (= (fun_app$c (plus$ ?v0) ?v1) zero$) (and (= ?v0 zero$) (= ?v1 zero$))) ))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$c (plus$ ?v0) zero$) ?v0) :pattern ((plus$ ?v0)))))
(assert (forall ((?v0 Nat_set$) (?v1 Nat_set$)) (= (= (sup$ ?v0 ?v1) bot$) (and (= ?v0 bot$) (= ?v1 bot$))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (= (fun_app$f (sup$a ?v0) ?v1) bot$a) (and (= ?v0 bot$a) (= ?v1 bot$a))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (= bot$a (fun_app$f (sup$a ?v0) ?v1)) (and (= ?v0 bot$a) (= ?v1 bot$a))) ))
(assert (forall ((?v0 A_bool_fun$) (?v1 A_bool_fun$)) (= (= bot$b (fun_app$g (sup$b ?v0) ?v1)) (and (= ?v0 bot$b) (= ?v1 bot$b))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (= (fun_app$f (sup$a ?v0) ?v1) bot$a) (and (= ?v0 bot$a) (= ?v1 bot$a))) ))
(assert (forall ((?v0 A_bool_fun$) (?v1 A_bool_fun$)) (= (= (fun_app$g (sup$b ?v0) ?v1) bot$b) (and (= ?v0 bot$b) (= ?v1 bot$b))) ))
(assert (forall ((?v0 A_set$)) (= (fun_app$f (sup$a ?v0) bot$a) ?v0) ))
(assert (forall ((?v0 A_bool_fun$)) (= (fun_app$g (sup$b ?v0) bot$b) ?v0) ))
(assert (forall ((?v0 A_set$)) (= (fun_app$f (sup$a bot$a) ?v0) ?v0) ))
(assert (forall ((?v0 A_bool_fun$)) (= (fun_app$g (sup$b bot$b) ?v0) ?v0) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$c (plus$ ?v0) zero$) ?v0) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$c (plus$ ?v0) ?v1) (fun_app$c (plus$ ?v0) ?v2)) (= ?v1 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$c (plus$ ?v0) ?v1) (fun_app$c (plus$ ?v2) ?v1)) (= ?v0 ?v2)) ))
(assert (forall ((?v0 Nat$)) (= (member$ ?v0 bot$) false) ))
(assert (forall ((?v0 A$)) (= (member$a ?v0 bot$a) false) ))
(assert (forall ((?v0 A_bool_fun$)) (= (= bot$a (collect$ ?v0)) (forall ((?v1 A$)) (not (fun_app$b ?v0 ?v1)) )) ))
(assert (forall ((?v0 Nat_set$)) (= (forall ((?v1 Nat$)) (not (member$ ?v1 ?v0)) ) (= ?v0 bot$)) ))
(assert (forall ((?v0 A_set$)) (= (forall ((?v1 A$)) (not (member$a ?v1 ?v0)) ) (= ?v0 bot$a)) ))
(assert (forall ((?v0 A_bool_fun$)) (= (= (collect$ ?v0) bot$a) (forall ((?v1 A$)) (not (fun_app$b ?v0 ?v1)) )) ))
(assert (forall ((?v0 A_set$)) (! (= (fun_app$f (sup$a ?v0) ?v0) ?v0) :pattern ((sup$a ?v0)))))
(assert (forall ((?v0 A_set$)) (! (= (fun_app$f (sup$a ?v0) ?v0) ?v0) :pattern ((sup$a ?v0)))))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v0) ?v1)) (fun_app$f (sup$a ?v0) ?v1)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v0) ?v1)) (fun_app$f (sup$a ?v0) ?v1)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (sup$a (fun_app$f (sup$a ?v0) ?v1)) ?v1) (fun_app$f (sup$a ?v0) ?v1)) ))
(assert (forall ((?v0 A_bool_fun$) (?v1 A_bool_fun$)) (=> (forall ((?v2 A$)) (= (fun_app$b ?v0 ?v2) (fun_app$b ?v1 ?v2)) ) (= (collect$ ?v0) (collect$ ?v1))) ))
(assert (forall ((?v0 Nat_set$)) (= (collect$a (uua$ ?v0)) ?v0) ))
(assert (forall ((?v0 A_set$)) (= (collect$ (uub$ ?v0)) ?v0) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_bool_fun$)) (= (member$ ?v0 (collect$a ?v1)) (fun_app$a ?v1 ?v0)) ))
(assert (forall ((?v0 A$) (?v1 A_bool_fun$)) (= (member$a ?v0 (collect$ ?v1)) (fun_app$b ?v1 ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (=> (not (member$ ?v0 ?v1)) (member$ ?v0 ?v2)) (member$ ?v0 (sup$ ?v2 ?v1))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (=> (not (member$a ?v0 ?v1)) (member$a ?v0 ?v2)) (member$a ?v0 (fun_app$f (sup$a ?v2) ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (= (member$ ?v0 (sup$ ?v1 ?v2)) (or (member$ ?v0 ?v1) (member$ ?v0 ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (= (member$a ?v0 (fun_app$f (sup$a ?v1) ?v2)) (or (member$a ?v0 ?v1) (member$a ?v0 ?v2))) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$c (plus$ zero$) ?v0) ?v0) ))
(assert (= bot$a (collect$ bot$b)))
(assert (= bot$c zero$))
(assert (forall ((?v0 Nat$)) (= (= zero$ ?v0) (= ?v0 zero$)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (= ?v0 ?v1) (= ?v2 ?v3)) (= (fun_app$c (plus$ ?v0) ?v2) (fun_app$c (plus$ ?v1) ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (= (fun_app$c (plus$ ?v0) ?v1) (fun_app$c (plus$ ?v0) ?v2)) (= ?v1 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (= (fun_app$c (plus$ ?v0) ?v1) (fun_app$c (plus$ ?v2) ?v1)) (= ?v0 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$c (plus$ ?v0) ?v1) (fun_app$c (plus$ ?v1) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$c (plus$ ?v0) (fun_app$c (plus$ ?v1) ?v2)) (fun_app$c (plus$ ?v1) (fun_app$c (plus$ ?v0) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$c (plus$ (fun_app$c (plus$ ?v0) ?v1)) ?v2) (fun_app$c (plus$ ?v0) (fun_app$c (plus$ ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$c (plus$ (fun_app$c (plus$ ?v0) ?v1)) ?v2) (fun_app$c (plus$ ?v0) (fun_app$c (plus$ ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$)) (=> (member$ ?v0 bot$) false) ))
(assert (forall ((?v0 A$)) (=> (member$a ?v0 bot$a) false) ))
(assert (forall ((?v0 Nat_set$) (?v1 Nat$)) (=> (= ?v0 bot$) (not (member$ ?v1 ?v0))) ))
(assert (forall ((?v0 A_set$) (?v1 A$)) (=> (= ?v0 bot$a) (not (member$a ?v1 ?v0))) ))
(assert (forall ((?v0 Nat_set$)) (=> (forall ((?v1 Nat$)) (=> (member$ ?v1 ?v0) false) ) (= ?v0 bot$)) ))
(assert (forall ((?v0 A_set$)) (=> (forall ((?v1 A$)) (=> (member$a ?v1 ?v0) false) ) (= ?v0 bot$a)) ))
(assert (forall ((?v0 Nat_set$)) (= (exists ((?v1 Nat$)) (member$ ?v1 ?v0) ) (not (= ?v0 bot$))) ))
(assert (forall ((?v0 A_set$)) (= (exists ((?v1 A$)) (member$a ?v1 ?v0) ) (not (= ?v0 bot$a))) ))
(assert (forall ((?v0 Nat$)) (=> (and (=> (= ?v0 zero$) false) (=> (not (= ?v0 zero$)) false)) false) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (sup$a ?v0) ?v1) (fun_app$f (sup$a ?v1) ?v0)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (sup$a ?v0) ?v1) (fun_app$f (sup$a ?v1) ?v0)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (sup$a ?v0) ?v1) (fun_app$f (sup$a ?v1) ?v0)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v0) ?v1)) (fun_app$f (sup$a ?v0) ?v1)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v1) ?v2)) (fun_app$f (sup$a ?v1) (fun_app$f (sup$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v1) ?v2)) (fun_app$f (sup$a ?v1) (fun_app$f (sup$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v1) ?v2)) (fun_app$f (sup$a ?v1) (fun_app$f (sup$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a (fun_app$f (sup$a ?v0) ?v1)) ?v2) (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v1) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a (fun_app$f (sup$a ?v0) ?v1)) ?v2) (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v1) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a (fun_app$f (sup$a ?v0) ?v1)) ?v2) (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$c (plus$ ?v0) ?v1) (fun_app$c (plus$ ?v0) ?v2)) (= ?v1 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$c (plus$ ?v0) ?v1) (fun_app$c (plus$ ?v2) ?v1)) (= ?v0 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (member$ ?v0 ?v1) (member$ ?v0 (sup$ ?v1 ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (member$a ?v0 ?v1) (member$a ?v0 (fun_app$f (sup$a ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (member$ ?v0 ?v1) (member$ ?v0 (sup$ ?v2 ?v1))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (member$a ?v0 ?v1) (member$a ?v0 (fun_app$f (sup$a ?v2) ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (and (member$ ?v0 (sup$ ?v1 ?v2)) (and (=> (member$ ?v0 ?v1) false) (=> (member$ ?v0 ?v2) false))) false) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (and (member$a ?v0 (fun_app$f (sup$a ?v1) ?v2)) (and (=> (member$a ?v0 ?v1) false) (=> (member$a ?v0 ?v2) false))) false) ))
(assert (forall ((?v0 A_set$)) (! (= (fun_app$f (sup$a ?v0) ?v0) ?v0) :pattern ((sup$a ?v0)))))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (sup$a ?v0) ?v1) (fun_app$f (sup$a ?v1) ?v0)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v0) ?v1)) (fun_app$f (sup$a ?v0) ?v1)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v1) ?v2)) (fun_app$f (sup$a ?v1) (fun_app$f (sup$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a (fun_app$f (sup$a ?v0) ?v1)) ?v2) (fun_app$f (sup$a ?v0) (fun_app$f (sup$a ?v1) ?v2))) ))
(assert (forall ((?v0 Nat_set$) (?v1 Nat_set$) (?v2 Nat_bool_fun$)) (= (forall ((?v3 Nat$)) (=> (member$ ?v3 (sup$ ?v0 ?v1)) (fun_app$a ?v2 ?v3)) ) (and (forall ((?v3 Nat$)) (=> (member$ ?v3 ?v0) (fun_app$a ?v2 ?v3)) ) (forall ((?v3 Nat$)) (=> (member$ ?v3 ?v1) (fun_app$a ?v2 ?v3)) ))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_bool_fun$)) (= (forall ((?v3 A$)) (=> (member$a ?v3 (fun_app$f (sup$a ?v0) ?v1)) (fun_app$b ?v2 ?v3)) ) (and (forall ((?v3 A$)) (=> (member$a ?v3 ?v0) (fun_app$b ?v2 ?v3)) ) (forall ((?v3 A$)) (=> (member$a ?v3 ?v1) (fun_app$b ?v2 ?v3)) ))) ))
(assert (forall ((?v0 Nat_set$) (?v1 Nat_set$) (?v2 Nat_bool_fun$)) (= (exists ((?v3 Nat$)) (and (member$ ?v3 (sup$ ?v0 ?v1)) (fun_app$a ?v2 ?v3)) ) (or (exists ((?v3 Nat$)) (and (member$ ?v3 ?v0) (fun_app$a ?v2 ?v3)) ) (exists ((?v3 Nat$)) (and (member$ ?v3 ?v1) (fun_app$a ?v2 ?v3)) ))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_bool_fun$)) (= (exists ((?v3 A$)) (and (member$a ?v3 (fun_app$f (sup$a ?v0) ?v1)) (fun_app$b ?v2 ?v3)) ) (or (exists ((?v3 A$)) (and (member$a ?v3 ?v0) (fun_app$b ?v2 ?v3)) ) (exists ((?v3 A$)) (and (member$a ?v3 ?v1) (fun_app$b ?v2 ?v3)) ))) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$c (plus$ zero$) ?v0) ?v0) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$c (plus$ ?v0) zero$) ?v0) ))
(assert (forall ((?v0 A_set$)) (= (fun_app$f (sup$a bot$a) ?v0) ?v0) ))
(assert (forall ((?v0 A_bool_fun$)) (= (fun_app$g (sup$b bot$b) ?v0) ?v0) ))
(assert (forall ((?v0 A_set$)) (= (fun_app$f (sup$a ?v0) bot$a) ?v0) ))
(assert (forall ((?v0 A_bool_fun$)) (= (fun_app$g (sup$b ?v0) bot$b) ?v0) ))
(assert (forall ((?v0 A_set$)) (= (fun_app$f (sup$a bot$a) ?v0) ?v0) ))
(assert (forall ((?v0 A_set$)) (= (fun_app$f (sup$a ?v0) bot$a) ?v0) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (= (fun_app$c (plus$ ?v0) ?v1) ?v0) (= ?v1 zero$)) ))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$c (plus$ zero$) ?v0) ?v0) :pattern ((fun_app$c (plus$ zero$) ?v0)))))
(assert (forall ((?v0 A_tree_list$) (?v1 A_tree_list_list$) (?v2 A_tree_list$) (?v3 A_tree_list_list$)) (= (= (cons$b ?v0 ?v1) (cons$b ?v2 ?v3)) (and (= ?v0 ?v2) (= ?v1 ?v3))) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$) (?v2 A_tree$) (?v3 A_tree_list$)) (= (= (cons$ ?v0 ?v1) (cons$ ?v2 ?v3)) (and (= ?v0 ?v2) (= ?v1 ?v3))) ))
(assert (forall ((?v0 A$)) (! (= (fun_app$b bot$b ?v0) bot$d) :pattern ((fun_app$b bot$b ?v0)))))
(assert (forall ((?v0 A_tree$) (?v1 A_tree$) (?v2 A_tree_list$)) (! (= (huffman$a (cons$ ?v0 (cons$ ?v1 ?v2))) (huffman$a (fun_app$ (insortTree$ (uniteTrees$ ?v0 ?v1)) ?v2))) :pattern ((cons$ ?v0 (cons$ ?v1 ?v2))))))
(assert (forall ((?v0 A_tree$) (?v1 A_tree$)) (= (alphabet$a (uniteTrees$ ?v0 ?v1)) (fun_app$f (sup$a (alphabet$a ?v0)) (alphabet$a ?v1))) ))
(assert (forall ((?v0 A_tree_list$) (?v1 A_tree_list_list$)) (not (= nil$b (cons$b ?v0 ?v1))) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$)) (not (= nil$ (cons$ ?v0 ?v1))) ))
(assert (forall ((?v0 A_tree_list_a_tree_list_list_bool_fun_fun$) (?v1 A_tree_list$) (?v2 A_tree_list_list$)) (=> (and (fun_app$h (fun_app$i ?v0 nil$) nil$b) (and (forall ((?v3 A_tree$) (?v4 A_tree_list$)) (fun_app$h (fun_app$i ?v0 (cons$ ?v3 ?v4)) nil$b) ) (and (forall ((?v3 A_tree_list$) (?v4 A_tree_list_list$)) (fun_app$h (fun_app$i ?v0 nil$) (cons$b ?v3 ?v4)) ) (forall ((?v3 A_tree$) (?v4 A_tree_list$) (?v5 A_tree_list$) (?v6 A_tree_list_list$)) (=> (fun_app$h (fun_app$i ?v0 ?v4) ?v6) (fun_app$h (fun_app$i ?v0 (cons$ ?v3 ?v4)) (cons$b ?v5 ?v6))) )))) (fun_app$h (fun_app$i ?v0 ?v1) ?v2)) ))
(assert (forall ((?v0 A_tree_list_list_a_tree_list_bool_fun_fun$) (?v1 A_tree_list_list$) (?v2 A_tree_list$)) (=> (and (fun_app$j (fun_app$k ?v0 nil$b) nil$) (and (forall ((?v3 A_tree_list$) (?v4 A_tree_list_list$)) (fun_app$j (fun_app$k ?v0 (cons$b ?v3 ?v4)) nil$) ) (and (forall ((?v3 A_tree$) (?v4 A_tree_list$)) (fun_app$j (fun_app$k ?v0 nil$b) (cons$ ?v3 ?v4)) ) (forall ((?v3 A_tree_list$) (?v4 A_tree_list_list$) (?v5 A_tree$) (?v6 A_tree_list$)) (=> (fun_app$j (fun_app$k ?v0 ?v4) ?v6) (fun_app$j (fun_app$k ?v0 (cons$b ?v3 ?v4)) (cons$ ?v5 ?v6))) )))) (fun_app$j (fun_app$k ?v0 ?v1) ?v2)) ))
(assert (forall ((?v0 A_tree_list_list_a_tree_list_list_bool_fun_fun$) (?v1 A_tree_list_list$) (?v2 A_tree_list_list$)) (=> (and (fun_app$h (fun_app$l ?v0 nil$b) nil$b) (and (forall ((?v3 A_tree_list$) (?v4 A_tree_list_list$)) (fun_app$h (fun_app$l ?v0 (cons$b ?v3 ?v4)) nil$b) ) (and (forall ((?v3 A_tree_list$) (?v4 A_tree_list_list$)) (fun_app$h (fun_app$l ?v0 nil$b) (cons$b ?v3 ?v4)) ) (forall ((?v3 A_tree_list$) (?v4 A_tree_list_list$) (?v5 A_tree_list$) (?v6 A_tree_list_list$)) (=> (fun_app$h (fun_app$l ?v0 ?v4) ?v6) (fun_app$h (fun_app$l ?v0 (cons$b ?v3 ?v4)) (cons$b ?v5 ?v6))) )))) (fun_app$h (fun_app$l ?v0 ?v1) ?v2)) ))
(assert (forall ((?v0 A_tree_list_a_tree_list_bool_fun_fun$) (?v1 A_tree_list$) (?v2 A_tree_list$)) (=> (and (fun_app$j (fun_app$m ?v0 nil$) nil$) (and (forall ((?v3 A_tree$) (?v4 A_tree_list$)) (fun_app$j (fun_app$m ?v0 (cons$ ?v3 ?v4)) nil$) ) (and (forall ((?v3 A_tree$) (?v4 A_tree_list$)) (fun_app$j (fun_app$m ?v0 nil$) (cons$ ?v3 ?v4)) ) (forall ((?v3 A_tree$) (?v4 A_tree_list$) (?v5 A_tree$) (?v6 A_tree_list$)) (=> (fun_app$j (fun_app$m ?v0 ?v4) ?v6) (fun_app$j (fun_app$m ?v0 (cons$ ?v3 ?v4)) (cons$ ?v5 ?v6))) )))) (fun_app$j (fun_app$m ?v0 ?v1) ?v2)) ))
(assert (forall ((?v0 A_tree_list_list$) (?v1 A_tree_list_list_bool_fun$)) (=> (and (not (= ?v0 nil$b)) (and (forall ((?v2 A_tree_list$)) (fun_app$h ?v1 (cons$b ?v2 nil$b)) ) (forall ((?v2 A_tree_list$) (?v3 A_tree_list_list$)) (=> (and (not (= ?v3 nil$b)) (fun_app$h ?v1 ?v3)) (fun_app$h ?v1 (cons$b ?v2 ?v3))) ))) (fun_app$h ?v1 ?v0)) ))
(assert (forall ((?v0 A_tree_list$) (?v1 A_tree_list_bool_fun$)) (=> (and (not (= ?v0 nil$)) (and (forall ((?v2 A_tree$)) (fun_app$j ?v1 (cons$ ?v2 nil$)) ) (forall ((?v2 A_tree$) (?v3 A_tree_list$)) (=> (and (not (= ?v3 nil$)) (fun_app$j ?v1 ?v3)) (fun_app$j ?v1 (cons$ ?v2 ?v3))) ))) (fun_app$j ?v1 ?v0)) ))
(assert (forall ((?v0 A_tree_list_list$) (?v1 A_tree_list$) (?v2 A_tree_list_list$)) (=> (= ?v0 (cons$b ?v1 ?v2)) (not (= ?v0 nil$b))) ))
(assert (forall ((?v0 A_tree_list$) (?v1 A_tree$) (?v2 A_tree_list$)) (=> (= ?v0 (cons$ ?v1 ?v2)) (not (= ?v0 nil$))) ))
(assert (forall ((?v0 A_tree_list_list$)) (=> (and (=> (= ?v0 nil$b) false) (forall ((?v1 A_tree_list$) (?v2 A_tree_list_list$)) (=> (= ?v0 (cons$b ?v1 ?v2)) false) )) false) ))
(assert (forall ((?v0 A_tree_list$)) (=> (and (=> (= ?v0 nil$) false) (forall ((?v1 A_tree$) (?v2 A_tree_list$)) (=> (= ?v0 (cons$ ?v1 ?v2)) false) )) false) ))
(assert (forall ((?v0 A$)) (! (= (fun_app$b bot$b ?v0) bot$d) :pattern ((fun_app$b bot$b ?v0)))))
(assert (forall ((?v0 A_tree_list$) (?v1 A_tree_list_list$)) (not (= (cons$b ?v0 ?v1) ?v1)) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$)) (not (= (cons$ ?v0 ?v1) ?v1)) ))
(assert (forall ((?v0 A_tree_list$)) (=> (and (=> (= ?v0 nil$) false) (=> (not (= ?v0 nil$)) false)) false) ))
(assert (forall ((?v0 A_tree_list_list$)) (=> (and (=> (= ?v0 nil$b) false) (=> (not (= ?v0 nil$b)) false)) false) ))
(assert (forall ((?v0 A_tree_list_list$)) (= (not (= ?v0 nil$b)) (exists ((?v1 A_tree_list$) (?v2 A_tree_list_list$)) (= ?v0 (cons$b ?v1 ?v2)) )) ))
(assert (forall ((?v0 A_tree_list$)) (= (not (= ?v0 nil$)) (exists ((?v1 A_tree$) (?v2 A_tree_list$)) (= ?v0 (cons$ ?v1 ?v2)) )) ))
(assert (forall ((?v0 A_tree_list_list$)) (=> (and (=> (= ?v0 nil$b) false) (and (forall ((?v1 A_tree_list$)) (=> (= ?v0 (cons$b ?v1 nil$b)) false) ) (forall ((?v1 A_tree_list$) (?v2 A_tree_list$) (?v3 A_tree_list_list$)) (=> (= ?v0 (cons$b ?v1 (cons$b ?v2 ?v3))) false) ))) false) ))
(assert (forall ((?v0 A_tree_list$)) (=> (and (=> (= ?v0 nil$) false) (and (forall ((?v1 A_tree$)) (=> (= ?v0 (cons$ ?v1 nil$)) false) ) (forall ((?v1 A_tree$) (?v2 A_tree$) (?v3 A_tree_list$)) (=> (= ?v0 (cons$ ?v1 (cons$ ?v2 ?v3))) false) ))) false) ))
(assert (forall ((?v0 A_tree_list_list_list$)) (=> (and (=> (= ?v0 nil$c) false) (and (forall ((?v1 A_tree_list_list_list$)) (=> (= ?v0 (cons$c nil$b ?v1)) false) ) (forall ((?v1 A_tree_list$) (?v2 A_tree_list_list$) (?v3 A_tree_list_list_list$)) (=> (= ?v0 (cons$c (cons$b ?v1 ?v2) ?v3)) false) ))) false) ))
(assert (forall ((?v0 A_tree_list_list$)) (=> (and (=> (= ?v0 nil$b) false) (and (forall ((?v1 A_tree_list_list$)) (=> (= ?v0 (cons$b nil$ ?v1)) false) ) (forall ((?v1 A_tree$) (?v2 A_tree_list$) (?v3 A_tree_list_list$)) (=> (= ?v0 (cons$b (cons$ ?v1 ?v2) ?v3)) false) ))) false) ))
(assert (forall ((?v0 Nat$)) (! (= (bot$e ?v0) (member$ ?v0 bot$)) :pattern ((bot$e ?v0)))))
(assert (forall ((?v0 A$)) (! (= (fun_app$b bot$b ?v0) (member$a ?v0 bot$a)) :pattern ((fun_app$b bot$b ?v0)))))
(assert (forall ((?v0 A_tree_list$) (?v1 A_tree$)) (=> (and (= (huffman$a ?v0) ?v1) (and (forall ((?v2 A_tree$)) (=> (and (= ?v0 (cons$ ?v2 nil$)) (= ?v1 ?v2)) false) ) (and (forall ((?v2 A_tree$) (?v3 A_tree$) (?v4 A_tree_list$)) (=> (and (= ?v0 (cons$ ?v2 (cons$ ?v3 ?v4))) (= ?v1 (huffman$a (fun_app$ (insortTree$ (uniteTrees$ ?v2 ?v3)) ?v4)))) false) ) (=> (and (= ?v0 nil$) (= ?v1 undefined$)) false)))) false) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (= ?v0 (fun_app$c (plus$ ?v0) ?v1)) (= ?v1 zero$)) ))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$n (n_lists$ ?v0) nil$b) (ite (= ?v0 zero$) (cons$c nil$b nil$c) nil$c)) :pattern ((n_lists$ ?v0)))))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$o (n_lists$a ?v0) nil$) (ite (= ?v0 zero$) (cons$b nil$ nil$b) nil$b)) :pattern ((n_lists$a ?v0)))))
(assert (forall ((?v0 A_tree_list$) (?v1 Nat_set$)) (! (= (sublist$ (cons$b ?v0 nil$b) ?v1) (ite (member$ zero$ ?v1) (cons$b ?v0 nil$b) nil$b)) :pattern ((sublist$ (cons$b ?v0 nil$b) ?v1)))))
(assert (forall ((?v0 A_tree$) (?v1 Nat_set$)) (! (= (sublist$a (cons$ ?v0 nil$) ?v1) (ite (member$ zero$ ?v1) (cons$ ?v0 nil$) nil$)) :pattern ((sublist$a (cons$ ?v0 nil$) ?v1)))))
(assert (forall ((?v0 Nat_set$)) (! (= (sublist$a nil$ ?v0) nil$) :pattern ((sublist$a nil$ ?v0)))))
(assert (forall ((?v0 Nat_set$)) (! (= (sublist$ nil$b ?v0) nil$b) :pattern ((sublist$ nil$b ?v0)))))
(assert (forall ((?v0 A_tree_list$)) (= (sublist$a ?v0 bot$) nil$) ))
(assert (forall ((?v0 A_tree_list_list$)) (= (sublist$ ?v0 bot$) nil$b) ))
(assert (forall ((?v0 A_tree_list_list$)) (! (= (fun_app$n (n_lists$ zero$) ?v0) (cons$c nil$b nil$c)) :pattern ((fun_app$n (n_lists$ zero$) ?v0)))))
(assert (forall ((?v0 A_tree_list$)) (! (= (fun_app$o (n_lists$a zero$) ?v0) (cons$b nil$ nil$b)) :pattern ((fun_app$o (n_lists$a zero$) ?v0)))))
(assert (= (sublists$ nil$b) (cons$c nil$b nil$c)))
(assert (= (sublists$a nil$) (cons$b nil$ nil$b)))
(assert (= (product_lists$ nil$c) (cons$c nil$b nil$c)))
(assert (= (product_lists$a nil$b) (cons$b nil$ nil$b)))
(assert (forall ((?v0 A_tree_list$) (?v1 A_tree$)) (=> (and (= (huffman$a ?v0) ?v1) (and (fun_app$j (accp$ huffman_rel$) ?v0) (and (forall ((?v2 A_tree$)) (=> (and (= ?v0 (cons$ ?v2 nil$)) (and (= ?v1 ?v2) (fun_app$j (accp$ huffman_rel$) (cons$ ?v2 nil$)))) false) ) (and (forall ((?v2 A_tree$) (?v3 A_tree$) (?v4 A_tree_list$)) (=> (and (= ?v0 (cons$ ?v2 (cons$ ?v3 ?v4))) (and (= ?v1 (huffman$a (fun_app$ (insortTree$ (uniteTrees$ ?v2 ?v3)) ?v4))) (fun_app$j (accp$ huffman_rel$) (cons$ ?v2 (cons$ ?v3 ?v4))))) false) ) (=> (and (= ?v0 nil$) (and (= ?v1 undefined$) (fun_app$j (accp$ huffman_rel$) nil$))) false))))) false) ))
(assert (forall ((?v0 A_tree_a_tree_list_fun$)) (! (= (bind$ nil$ ?v0) nil$) :pattern ((bind$ nil$ ?v0)))))
(assert (forall ((?v0 A_tree_a_tree_list_list_fun$)) (! (= (bind$a nil$ ?v0) nil$b) :pattern ((bind$a nil$ ?v0)))))
(assert (forall ((?v0 A_tree_list_a_tree_list_fun$)) (! (= (bind$b nil$b ?v0) nil$) :pattern ((bind$b nil$b ?v0)))))
(assert (forall ((?v0 A_tree_list_a_tree_list_list_fun$)) (! (= (bind$c nil$b ?v0) nil$b) :pattern ((bind$c nil$b ?v0)))))
(assert (forall ((?v0 A_tree_list$)) (! (= (fun_app$p (insert$ ?v0) nil$b) (cons$b ?v0 nil$b)) :pattern ((insert$ ?v0)))))
(assert (forall ((?v0 A_tree$)) (! (= (fun_app$ (insert$a ?v0) nil$) (cons$ ?v0 nil$)) :pattern ((insert$a ?v0)))))
(assert (forall ((?v0 A_set$)) (! (= (is_empty$ ?v0) (= ?v0 bot$a)) :pattern ((is_empty$ ?v0)))))
(assert (forall ((?v0 A_tree_list$)) (=> (not (= ?v0 nil$)) (= (freq$a (huffman$a ?v0)) (freq_F$ ?v0))) ))
(assert (= (height_F$ nil$) zero$))
(assert (forall ((?v0 Nat$) (?v1 Nat_tree$)) (! (=> (not (member$ ?v0 (alphabet$ ?v1))) (= (fun_app$c (freq$ ?v1) ?v0) zero$)) :pattern ((fun_app$c (freq$ ?v1) ?v0)))))
(assert (forall ((?v0 A$) (?v1 A_tree$)) (! (=> (not (member$a ?v0 (alphabet$a ?v1))) (= (fun_app$d (freq$a ?v1) ?v0) zero$)) :pattern ((fun_app$d (freq$a ?v1) ?v0)))))
(assert (forall ((?v0 A_tree$) (?v1 A_tree$) (?v2 A$)) (= (fun_app$d (freq$a (uniteTrees$ ?v0 ?v1)) ?v2) (fun_app$c (plus$ (fun_app$d (freq$a ?v0) ?v2)) (fun_app$d (freq$a ?v1) ?v2))) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$) (?v2 A$)) (= (fun_app$d (freq_F$ (fun_app$ (insortTree$ ?v0) ?v1)) ?v2) (fun_app$c (plus$ (fun_app$d (freq$a ?v0) ?v2)) (fun_app$d (freq_F$ ?v1) ?v2))) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$) (?v2 A$)) (! (= (fun_app$d (freq_F$ (cons$ ?v0 ?v1)) ?v2) (fun_app$c (plus$ (fun_app$d (freq$a ?v0) ?v2)) (fun_app$d (freq_F$ ?v1) ?v2))) :pattern ((fun_app$d (freq_F$ (cons$ ?v0 ?v1)) ?v2)))))
(assert (forall ((?v0 Nat$) (?v1 Nat_tree$) (?v2 Nat_tree_list$) (?v3 Nat$) (?v4 Nat$) (?v5 Nat$)) (=> (and (member$ ?v0 (alphabet$ ?v1)) (and (consistent$ ?v1) (and (not (member$ ?v0 (alphabet_F$a ?v2))) (= (fun_app$c (freq$ ?v1) ?v0) (fun_app$c (plus$ ?v3) ?v4))))) (= (splitLeaf_F$ (fun_app$e (insortTree$a ?v1) ?v2) ?v3 ?v0 ?v4 ?v5) (fun_app$e (insortTree$a (splitLeaf$ ?v1 ?v3 ?v0 ?v4 ?v5)) ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_tree$) (?v2 A_tree_list$) (?v3 Nat$) (?v4 Nat$) (?v5 A$)) (=> (and (member$a ?v0 (alphabet$a ?v1)) (and (consistent$a ?v1) (and (not (member$a ?v0 (alphabet_F$ ?v2))) (= (fun_app$d (freq$a ?v1) ?v0) (fun_app$c (plus$ ?v3) ?v4))))) (= (splitLeaf_F$a (fun_app$ (insortTree$ ?v1) ?v2) ?v3 ?v0 ?v4 ?v5) (fun_app$ (insortTree$ (splitLeaf$a ?v1 ?v3 ?v0 ?v4 ?v5)) ?v2))) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat_tree$) (?v2 Nat$)) (=> (and (= (inf$ (alphabet$ ?v0) (alphabet$ ?v1)) bot$) (member$ ?v2 (alphabet$ ?v1))) (= (fun_app$c (freq$ ?v0) ?v2) zero$)) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree$) (?v2 A$)) (=> (and (= (fun_app$f (inf$a (alphabet$a ?v0)) (alphabet$a ?v1)) bot$a) (member$a ?v2 (alphabet$a ?v1))) (= (fun_app$d (freq$a ?v0) ?v2) zero$)) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat_tree$) (?v2 Nat$)) (=> (and (= (inf$ (alphabet$ ?v0) (alphabet$ ?v1)) bot$) (member$ ?v2 (alphabet$ ?v0))) (= (fun_app$c (freq$ ?v1) ?v2) zero$)) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree$) (?v2 A$)) (=> (and (= (fun_app$f (inf$a (alphabet$a ?v0)) (alphabet$a ?v1)) bot$a) (member$a ?v2 (alphabet$a ?v0))) (= (fun_app$d (freq$a ?v1) ?v2) zero$)) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (member$ ?v3 (alphabet$ ?v0)) (member$ ?v4 (alphabet$ ?v0)))))) (= (freq$ (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4)) (freq$ ?v0))) ))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (=> (and (consistent$a ?v0) (and (member$a ?v1 (alphabet$a ?v0)) (and (member$a ?v2 (alphabet$a ?v0)) (and (member$a ?v3 (alphabet$a ?v0)) (member$a ?v4 (alphabet$a ?v0)))))) (= (freq$a (swapFourSyms$a ?v0 ?v1 ?v2 ?v3 ?v4)) (freq$a ?v0))) ))
(assert (forall ((?v0 A_set$)) (! (= (fun_app$f (inf$a ?v0) ?v0) ?v0) :pattern ((inf$a ?v0)))))
(assert (forall ((?v0 A_set$)) (! (= (fun_app$f (inf$a ?v0) ?v0) ?v0) :pattern ((inf$a ?v0)))))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v0) ?v1)) (fun_app$f (inf$a ?v0) ?v1)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v0) ?v1)) (fun_app$f (inf$a ?v0) ?v1)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (inf$a (fun_app$f (inf$a ?v0) ?v1)) ?v1) (fun_app$f (inf$a ?v0) ?v1)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (inf$a (fun_app$f (inf$a ?v0) ?v1)) ?v1) (fun_app$f (inf$a ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (and (member$ ?v0 ?v1) (member$ ?v0 ?v2)) (member$ ?v0 (inf$ ?v1 ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (and (member$a ?v0 ?v1) (member$a ?v0 ?v2)) (member$a ?v0 (fun_app$f (inf$a ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (= (member$ ?v0 (inf$ ?v1 ?v2)) (and (member$ ?v0 ?v1) (member$ ?v0 ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (= (member$a ?v0 (fun_app$f (inf$a ?v1) ?v2)) (and (member$a ?v0 ?v1) (member$a ?v0 ?v2))) ))
(assert (forall ((?v0 A_set$)) (= (fun_app$f (inf$a ?v0) bot$a) bot$a) ))
(assert (forall ((?v0 A_bool_fun$)) (= (fun_app$g (inf$b ?v0) bot$b) bot$b) ))
(assert (forall ((?v0 A_set$)) (= (fun_app$f (inf$a bot$a) ?v0) bot$a) ))
(assert (forall ((?v0 A_bool_fun$)) (= (fun_app$g (inf$b bot$b) ?v0) bot$b) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (sup$a ?v0) (fun_app$f (inf$a ?v0) ?v1)) ?v0) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (inf$a ?v0) (fun_app$f (sup$a ?v0) ?v1)) ?v0) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a ?v0) (fun_app$f (sup$a ?v1) ?v2)) (fun_app$f (sup$a (fun_app$f (inf$a ?v0) ?v1)) (fun_app$f (inf$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a (fun_app$f (sup$a ?v0) ?v1)) ?v2) (fun_app$f (sup$a (fun_app$f (inf$a ?v0) ?v2)) (fun_app$f (inf$a ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_tree$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (! (=> (not (member$ ?v0 (alphabet$ ?v1))) (= (splitLeaf$ ?v1 ?v2 ?v0 ?v3 ?v4) ?v1)) :pattern ((splitLeaf$ ?v1 ?v2 ?v0 ?v3 ?v4)))))
(assert (forall ((?v0 A$) (?v1 A_tree$) (?v2 Nat$) (?v3 Nat$) (?v4 A$)) (! (=> (not (member$a ?v0 (alphabet$a ?v1))) (= (splitLeaf$a ?v1 ?v2 ?v0 ?v3 ?v4) ?v1)) :pattern ((splitLeaf$a ?v1 ?v2 ?v0 ?v3 ?v4)))))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (member$ ?v0 (inf$ ?v1 ?v2)) (member$ ?v0 ?v1)) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (member$a ?v0 (fun_app$f (inf$a ?v1) ?v2)) (member$a ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (member$ ?v0 (inf$ ?v1 ?v2)) (member$ ?v0 ?v2)) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (member$a ?v0 (fun_app$f (inf$a ?v1) ?v2)) (member$a ?v0 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (and (member$ ?v0 (inf$ ?v1 ?v2)) (=> (and (member$ ?v0 ?v1) (member$ ?v0 ?v2)) false)) false) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (and (member$a ?v0 (fun_app$f (inf$a ?v1) ?v2)) (=> (and (member$a ?v0 ?v1) (member$a ?v0 ?v2)) false)) false) ))
(assert (forall ((?v0 A_set$)) (! (= (fun_app$f (inf$a ?v0) ?v0) ?v0) :pattern ((inf$a ?v0)))))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (inf$a ?v0) ?v1) (fun_app$f (inf$a ?v1) ?v0)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (inf$a ?v0) ?v1) (fun_app$f (inf$a ?v1) ?v0)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (inf$a ?v0) ?v1) (fun_app$f (inf$a ?v1) ?v0)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (inf$a ?v0) ?v1) (fun_app$f (inf$a ?v1) ?v0)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v0) ?v1)) (fun_app$f (inf$a ?v0) ?v1)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v0) ?v1)) (fun_app$f (inf$a ?v0) ?v1)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v1) ?v2)) (fun_app$f (inf$a ?v1) (fun_app$f (inf$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v1) ?v2)) (fun_app$f (inf$a ?v1) (fun_app$f (inf$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v1) ?v2)) (fun_app$f (inf$a ?v1) (fun_app$f (inf$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v1) ?v2)) (fun_app$f (inf$a ?v1) (fun_app$f (inf$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a (fun_app$f (inf$a ?v0) ?v1)) ?v2) (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v1) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a (fun_app$f (inf$a ?v0) ?v1)) ?v2) (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v1) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a (fun_app$f (inf$a ?v0) ?v1)) ?v2) (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v1) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a (fun_app$f (inf$a ?v0) ?v1)) ?v2) (fun_app$f (inf$a ?v0) (fun_app$f (inf$a ?v1) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a ?v0) (fun_app$f (inf$a ?v1) ?v2)) (fun_app$f (inf$a (fun_app$f (sup$a ?v0) ?v1)) (fun_app$f (sup$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a (fun_app$f (inf$a ?v0) ?v1)) ?v2) (fun_app$f (inf$a (fun_app$f (sup$a ?v0) ?v2)) (fun_app$f (sup$a ?v1) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a (fun_app$f (sup$a (fun_app$f (inf$a ?v0) ?v1)) (fun_app$f (inf$a ?v1) ?v2))) (fun_app$f (inf$a ?v2) ?v0)) (fun_app$f (inf$a (fun_app$f (inf$a (fun_app$f (sup$a ?v0) ?v1)) (fun_app$f (sup$a ?v1) ?v2))) (fun_app$f (sup$a ?v2) ?v0))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (=> (forall ((?v3 A_set$) (?v4 A_set$) (?v5 A_set$)) (= (fun_app$f (inf$a ?v3) (fun_app$f (sup$a ?v4) ?v5)) (fun_app$f (sup$a (fun_app$f (inf$a ?v3) ?v4)) (fun_app$f (inf$a ?v3) ?v5))) ) (= (fun_app$f (sup$a ?v0) (fun_app$f (inf$a ?v1) ?v2)) (fun_app$f (inf$a (fun_app$f (sup$a ?v0) ?v1)) (fun_app$f (sup$a ?v0) ?v2)))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (=> (forall ((?v3 A_set$) (?v4 A_set$) (?v5 A_set$)) (= (fun_app$f (sup$a ?v3) (fun_app$f (inf$a ?v4) ?v5)) (fun_app$f (inf$a (fun_app$f (sup$a ?v3) ?v4)) (fun_app$f (sup$a ?v3) ?v5))) ) (= (fun_app$f (inf$a ?v0) (fun_app$f (sup$a ?v1) ?v2)) (fun_app$f (sup$a (fun_app$f (inf$a ?v0) ?v1)) (fun_app$f (inf$a ?v0) ?v2)))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a ?v0) (fun_app$f (inf$a ?v1) ?v2)) (fun_app$f (inf$a (fun_app$f (sup$a ?v0) ?v1)) (fun_app$f (sup$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a (fun_app$f (inf$a ?v0) ?v1)) ?v2) (fun_app$f (inf$a (fun_app$f (sup$a ?v0) ?v2)) (fun_app$f (sup$a ?v1) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a ?v0) (fun_app$f (sup$a ?v1) ?v2)) (fun_app$f (sup$a (fun_app$f (inf$a ?v0) ?v1)) (fun_app$f (inf$a ?v0) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a (fun_app$f (sup$a ?v0) ?v1)) ?v2) (fun_app$f (sup$a (fun_app$f (inf$a ?v0) ?v2)) (fun_app$f (inf$a ?v1) ?v2))) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (=> (and (consistent$ ?v0) (not (member$ ?v1 (alphabet$ ?v0)))) (consistent$ (splitLeaf$ ?v0 ?v2 ?v3 ?v4 ?v1))) ))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 Nat$) (?v3 A$) (?v4 Nat$)) (=> (and (consistent$a ?v0) (not (member$a ?v1 (alphabet$a ?v0)))) (consistent$a (splitLeaf$a ?v0 ?v2 ?v3 ?v4 ?v1))) ))
(assert (forall ((?v0 Nat_set$) (?v1 Nat_set$)) (= (= (inf$ ?v0 ?v1) bot$) (forall ((?v2 Nat$)) (=> (member$ ?v2 ?v0) (forall ((?v3 Nat$)) (=> (member$ ?v3 ?v1) (not (= ?v2 ?v3))) )) )) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (= (fun_app$f (inf$a ?v0) ?v1) bot$a) (forall ((?v2 A$)) (=> (member$a ?v2 ?v0) (forall ((?v3 A$)) (=> (member$a ?v3 ?v1) (not (= ?v2 ?v3))) )) )) ))
(assert (forall ((?v0 A_set$)) (= (fun_app$f (inf$a ?v0) bot$a) bot$a) ))
(assert (forall ((?v0 A_set$)) (= (fun_app$f (inf$a bot$a) ?v0) bot$a) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree$)) (=> (and (consistent$a ?v0) (and (consistent$a ?v1) (= (fun_app$f (inf$a (alphabet$a ?v0)) (alphabet$a ?v1)) bot$a))) (consistent$a (uniteTrees$ ?v0 ?v1))) ))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (=> (consistent$a ?v0) (consistent$a (swapFourSyms$a ?v0 ?v1 ?v2 ?v3 ?v4))) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$)) (! (= (consistent_F$ (cons$ ?v0 ?v1)) (and (consistent$a ?v0) (and (consistent_F$ ?v1) (= (fun_app$f (inf$a (alphabet$a ?v0)) (alphabet_F$ ?v1)) bot$a)))) :pattern ((cons$ ?v0 ?v1)))))
(assert (forall ((?v0 A_tree_list$)) (=> (and (consistent_F$ ?v0) (not (= ?v0 nil$))) (consistent$a (huffman$a ?v0))) ))
(assert (forall ((?v0 A_tree$) (?v1 A_tree_list$) (?v2 Nat$) (?v3 A$) (?v4 Nat$) (?v5 A$)) (! (= (splitLeaf_F$a (cons$ ?v0 ?v1) ?v2 ?v3 ?v4 ?v5) (cons$ (splitLeaf$a ?v0 ?v2 ?v3 ?v4 ?v5) (splitLeaf_F$a ?v1 ?v2 ?v3 ?v4 ?v5))) :pattern ((splitLeaf_F$a (cons$ ?v0 ?v1) ?v2 ?v3 ?v4 ?v5)))))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (= (fun_app$c (freq$ ?v0) ?v1) (fun_app$c (plus$ ?v2) ?v3)))) (= (cost$ (splitLeaf$ ?v0 ?v2 ?v1 ?v3 ?v4)) (fun_app$c (plus$ (fun_app$c (plus$ (cost$ ?v0)) ?v2)) ?v3))) ))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 Nat$) (?v3 Nat$) (?v4 A$)) (=> (and (consistent$a ?v0) (and (member$a ?v1 (alphabet$a ?v0)) (= (fun_app$d (freq$a ?v0) ?v1) (fun_app$c (plus$ ?v2) ?v3)))) (= (cost$a (splitLeaf$a ?v0 ?v2 ?v1 ?v3 ?v4)) (fun_app$c (plus$ (fun_app$c (plus$ (cost$a ?v0)) ?v2)) ?v3))) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (= (fun_app$c (freq$ ?v0) ?v1) (fun_app$c (plus$ ?v2) ?v3)))) (= (weight$ (splitLeaf$ ?v0 ?v2 ?v1 ?v3 ?v4)) (weight$ ?v0))) ))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 Nat$) (?v3 Nat$) (?v4 A$)) (=> (and (consistent$a ?v0) (and (member$a ?v1 (alphabet$a ?v0)) (= (fun_app$d (freq$a ?v0) ?v1) (fun_app$c (plus$ ?v2) ?v3)))) (= (weight$a (splitLeaf$a ?v0 ?v2 ?v1 ?v3 ?v4)) (weight$a ?v0))) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (=> (and (consistent$ ?v0) (not (= ?v1 ?v2))) (= (freq$ (fun_app$q (swapLeaves$ ?v0 ?v3 ?v1 ?v4) ?v2)) (uuc$ ?v0 ?v1 ?v2 ?v3 ?v4))) ))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 Nat$) (?v4 Nat$)) (=> (and (consistent$a ?v0) (not (= ?v1 ?v2))) (= (freq$a (fun_app$r (swapLeaves$a ?v0 ?v3 ?v1 ?v4) ?v2)) (uud$ ?v0 ?v1 ?v2 ?v3 ?v4))) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat$) (?v2 Nat$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)))) (= (freq$ (swapSyms$ ?v0 ?v1 ?v2)) (freq$ ?v0))) ))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$a ?v0) (and (member$a ?v1 (alphabet$a ?v0)) (member$a ?v2 (alphabet$a ?v0)))) (= (freq$a (fun_app$r (swapSyms$a ?v0 ?v1) ?v2)) (freq$a ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_tree$) (?v2 Nat$) (?v3 Nat$)) (! (=> (not (member$ ?v0 (alphabet$ ?v1))) (= (fun_app$q (swapLeaves$ ?v1 ?v2 ?v0 ?v3) ?v0) ?v1)) :pattern ((swapLeaves$ ?v1 ?v2 ?v0 ?v3)))))
(assert (forall ((?v0 A$) (?v1 A_tree$) (?v2 Nat$) (?v3 Nat$)) (! (=> (not (member$a ?v0 (alphabet$a ?v1))) (= (fun_app$r (swapLeaves$a ?v1 ?v2 ?v0 ?v3) ?v0) ?v1)) :pattern ((swapLeaves$a ?v1 ?v2 ?v0 ?v3)))))
(assert (forall ((?v0 Nat$) (?v1 Nat_tree$) (?v2 Nat$)) (=> (and (member$ ?v0 (alphabet$ ?v1)) (member$ ?v2 (alphabet$ ?v1))) (= (alphabet$ (swapSyms$ ?v1 ?v0 ?v2)) (alphabet$ ?v1))) ))
(assert (forall ((?v0 A$) (?v1 A_tree$) (?v2 A$)) (=> (and (member$a ?v0 (alphabet$a ?v1)) (member$a ?v2 (alphabet$a ?v1))) (= (alphabet$a (fun_app$r (swapSyms$a ?v1 ?v0) ?v2)) (alphabet$a ?v1))) ))
(assert (forall ((?v0 A_tree$) (?v1 A$)) (! (=> (consistent$a ?v0) (= (fun_app$r (swapSyms$a ?v0 ?v1) ?v1) ?v0)) :pattern ((swapSyms$a ?v0 ?v1)))))
(assert (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$a ?v0) (= (fun_app$r (swapLeaves$a ?v0 (fun_app$d (freq$a ?v0) ?v1) ?v1 (fun_app$d (freq$a ?v0) ?v1)) ?v1) ?v0)) ))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (! (= (fun_app$r (swapSyms$a ?v0 ?v1) ?v2) (fun_app$r (swapLeaves$a ?v0 (fun_app$d (freq$a ?v0) ?v1) ?v1 (fun_app$d (freq$a ?v0) ?v2)) ?v2)) :pattern ((fun_app$r (swapSyms$a ?v0 ?v1) ?v2)))))
(assert (forall ((?v0 A_tree$) (?v1 Nat$) (?v2 A$) (?v3 Nat$) (?v4 A$)) (=> (consistent$a ?v0) (consistent$a (fun_app$r (swapLeaves$a ?v0 ?v1 ?v2 ?v3) ?v4))) ))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (consistent$a ?v0) (consistent$a (fun_app$r (swapSyms$a ?v0 ?v1) ?v2))) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (=> (and (consistent$ ?v0) (not (= ?v1 ?v2))) (ite (member$ ?v1 (alphabet$ ?v0)) (ite (member$ ?v2 (alphabet$ ?v0)) (= (fun_app$c (plus$ (fun_app$c (plus$ (weight$ (fun_app$q (swapLeaves$ ?v0 ?v3 ?v1 ?v4) ?v2))) (fun_app$c (freq$ ?v0) ?v1))) (fun_app$c (freq$ ?v0) ?v2)) (fun_app$c (plus$ (fun_app$c (plus$ (weight$ ?v0)) ?v3)) ?v4)) (= (fun_app$c (plus$ (weight$ (fun_app$q (swapLeaves$ ?v0 ?v3 ?v1 ?v4) ?v2))) (fun_app$c (freq$ ?v0) ?v1)) (fun_app$c (plus$ (weight$ ?v0)) ?v4))) (ite (member$ ?v2 (alphabet$ ?v0)) (= (fun_app$c (plus$ (weight$ (fun_app$q (swapLeaves$ ?v0 ?v3 ?v1 ?v4) ?v2))) (fun_app$c (freq$ ?v0) ?v2)) (fun_app$c (plus$ (weight$ ?v0)) ?v3)) (= (weight$ (fun_app$q (swapLeaves$ ?v0 ?v3 ?v1 ?v4) ?v2)) (weight$ ?v0))))) ))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 Nat$) (?v4 Nat$)) (=> (and (consistent$a ?v0) (not (= ?v1 ?v2))) (ite (member$a ?v1 (alphabet$a ?v0)) (ite (member$a ?v2 (alphabet$a ?v0)) (= (fun_app$c (plus$ (fun_app$c (plus$ (weight$a (fun_app$r (swapLeaves$a ?v0 ?v3 ?v1 ?v4) ?v2))) (fun_app$d (freq$a ?v0) ?v1))) (fun_app$d (freq$a ?v0) ?v2)) (fun_app$c (plus$ (fun_app$c (plus$ (weight$a ?v0)) ?v3)) ?v4)) (= (fun_app$c (plus$ (weight$a (fun_app$r (swapLeaves$a ?v0 ?v3 ?v1 ?v4) ?v2))) (fun_app$d (freq$a ?v0) ?v1)) (fun_app$c (plus$ (weight$a ?v0)) ?v4))) (ite (member$a ?v2 (alphabet$a ?v0)) (= (fun_app$c (plus$ (weight$a (fun_app$r (swapLeaves$a ?v0 ?v3 ?v1 ?v4) ?v2))) (fun_app$d (freq$a ?v0) ?v2)) (fun_app$c (plus$ (weight$a ?v0)) ?v3)) (= (weight$a (fun_app$r (swapLeaves$a ?v0 ?v3 ?v1 ?v4) ?v2)) (weight$a ?v0))))) ))
(assert (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (! (= (swapFourSyms$a ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$r (swapSyms$a ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$r (swapSyms$a ?v0 ?v1) ?v4) (fun_app$r (swapSyms$a (fun_app$r (swapSyms$a ?v0 ?v1) ?v3) ?v2) ?v4)))) :pattern ((swapFourSyms$a ?v0 ?v1 ?v2 ?v3 ?v4)))))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (= (alphabet$ (splitLeaf$ ?v0 ?v1 ?v2 ?v3 ?v4)) (ite (member$ ?v2 (alphabet$ ?v0)) (sup$ (alphabet$ ?v0) (insert$b ?v4 bot$)) (alphabet$ ?v0))) ))
(assert (forall ((?v0 A_tree$) (?v1 Nat$) (?v2 A$) (?v3 Nat$) (?v4 A$)) (= (alphabet$a (splitLeaf$a ?v0 ?v1 ?v2 ?v3 ?v4)) (ite (member$a ?v2 (alphabet$a ?v0)) (fun_app$f (sup$a (alphabet$a ?v0)) (insert$c ?v4 bot$a)) (alphabet$a ?v0))) ))
(assert (forall ((?v0 A_tree_bool_fun$)) (! (= (fun_app$j (list_ex1$ ?v0) nil$) false) :pattern ((list_ex1$ ?v0)))))
(assert (forall ((?v0 A_tree_list_bool_fun$)) (! (= (fun_app$h (list_ex1$a ?v0) nil$b) false) :pattern ((list_ex1$a ?v0)))))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat$)) (=> (=> (not (member$ ?v0 ?v1)) (= ?v0 ?v2)) (member$ ?v0 (insert$b ?v2 ?v1))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A$)) (=> (=> (not (member$a ?v0 ?v1)) (= ?v0 ?v2)) (member$a ?v0 (insert$c ?v2 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_set$)) (= (member$ ?v0 (insert$b ?v1 ?v2)) (or (= ?v0 ?v1) (member$ ?v0 ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A$) (?v2 A_set$)) (= (member$a ?v0 (insert$c ?v1 ?v2)) (or (= ?v0 ?v1) (member$a ?v0 ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_set$)) (= (insert$c ?v0 (insert$c ?v0 ?v1)) (insert$c ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$)) (member$ ?v0 (insert$b ?v0 bot$)) ))
(assert (forall ((?v0 A$)) (member$a ?v0 (insert$c ?v0 bot$a)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (not (member$ ?v0 ?v1)) (= (inf$ ?v1 (insert$b ?v0 ?v2)) (inf$ ?v1 ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (not (member$a ?v0 ?v1)) (= (fun_app$f (inf$a ?v1) (insert$c ?v0 ?v2)) (fun_app$f (inf$a ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (not (member$ ?v0 ?v1)) (= (inf$ (insert$b ?v0 ?v2) ?v1) (inf$ ?v2 ?v1))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (not (member$a ?v0 ?v1)) (= (fun_app$f (inf$a (insert$c ?v0 ?v2)) ?v1) (fun_app$f (inf$a ?v2) ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (member$ ?v0 ?v1) (= (inf$ ?v1 (insert$b ?v0 ?v2)) (insert$b ?v0 (inf$ ?v1 ?v2)))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (member$a ?v0 ?v1) (= (fun_app$f (inf$a ?v1) (insert$c ?v0 ?v2)) (insert$c ?v0 (fun_app$f (inf$a ?v1) ?v2)))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (member$ ?v0 ?v1) (= (inf$ (insert$b ?v0 ?v2) ?v1) (insert$b ?v0 (inf$ ?v2 ?v1)))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (member$a ?v0 ?v1) (= (fun_app$f (inf$a (insert$c ?v0 ?v2)) ?v1) (insert$c ?v0 (fun_app$f (inf$a ?v2) ?v1)))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a (insert$c ?v0 ?v1)) (insert$c ?v0 ?v2)) (insert$c ?v0 (fun_app$f (inf$a ?v1) ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A$) (?v2 A_set$)) (= (fun_app$f (sup$a ?v0) (insert$c ?v1 ?v2)) (insert$c ?v1 (fun_app$f (sup$a ?v0) ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (sup$a (insert$c ?v0 ?v1)) ?v2) (insert$c ?v0 (fun_app$f (sup$a ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (= (= bot$ (inf$ (insert$b ?v0 ?v1) ?v2)) (and (not (member$ ?v0 ?v2)) (= bot$ (inf$ ?v1 ?v2)))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (= (= bot$a (fun_app$f (inf$a (insert$c ?v0 ?v1)) ?v2)) (and (not (member$a ?v0 ?v2)) (= bot$a (fun_app$f (inf$a ?v1) ?v2)))) ))
(assert (forall ((?v0 Nat_set$) (?v1 Nat$) (?v2 Nat_set$)) (= (= bot$ (inf$ ?v0 (insert$b ?v1 ?v2))) (and (not (member$ ?v1 ?v0)) (= bot$ (inf$ ?v0 ?v2)))) ))
(assert (forall ((?v0 A_set$) (?v1 A$) (?v2 A_set$)) (= (= bot$a (fun_app$f (inf$a ?v0) (insert$c ?v1 ?v2))) (and (not (member$a ?v1 ?v0)) (= bot$a (fun_app$f (inf$a ?v0) ?v2)))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (= (= (inf$ (insert$b ?v0 ?v1) ?v2) bot$) (and (not (member$ ?v0 ?v2)) (= (inf$ ?v1 ?v2) bot$))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (= (= (fun_app$f (inf$a (insert$c ?v0 ?v1)) ?v2) bot$a) (and (not (member$a ?v0 ?v2)) (= (fun_app$f (inf$a ?v1) ?v2) bot$a))) ))
(assert (forall ((?v0 Nat_set$) (?v1 Nat$) (?v2 Nat_set$)) (= (= (inf$ ?v0 (insert$b ?v1 ?v2)) bot$) (and (not (member$ ?v1 ?v0)) (= (inf$ ?v0 ?v2) bot$))) ))
(assert (forall ((?v0 A_set$) (?v1 A$) (?v2 A_set$)) (= (= (fun_app$f (inf$a ?v0) (insert$c ?v1 ?v2)) bot$a) (and (not (member$a ?v1 ?v0)) (= (fun_app$f (inf$a ?v0) ?v2) bot$a))) ))
(assert (forall ((?v0 Nat_set$) (?v1 Nat$) (?v2 Nat_set$)) (= (inf$ ?v0 (insert$b ?v1 ?v2)) (ite (member$ ?v1 ?v0) (insert$b ?v1 (inf$ ?v0 ?v2)) (inf$ ?v0 ?v2))) ))
(assert (forall ((?v0 A_set$) (?v1 A$) (?v2 A_set$)) (= (fun_app$f (inf$a ?v0) (insert$c ?v1 ?v2)) (ite (member$a ?v1 ?v0) (insert$c ?v1 (fun_app$f (inf$a ?v0) ?v2)) (fun_app$f (inf$a ?v0) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (= (inf$ (insert$b ?v0 ?v1) ?v2) (ite (member$ ?v0 ?v2) (insert$b ?v0 (inf$ ?v1 ?v2)) (inf$ ?v1 ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (= (fun_app$f (inf$a (insert$c ?v0 ?v1)) ?v2) (ite (member$a ?v0 ?v2) (insert$c ?v0 (fun_app$f (inf$a ?v1) ?v2)) (fun_app$f (inf$a ?v1) ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_set$)) (= (insert$c ?v0 ?v1) (fun_app$f (sup$a (insert$c ?v0 bot$a)) ?v1)) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$) (?v2 A$)) (= (= (fun_app$f (sup$a ?v0) ?v1) (insert$c ?v2 bot$a)) (or (and (= ?v0 bot$a) (= ?v1 (insert$c ?v2 bot$a))) (or (and (= ?v0 (insert$c ?v2 bot$a)) (= ?v1 bot$a)) (and (= ?v0 (insert$c ?v2 bot$a)) (= ?v1 (insert$c ?v2 bot$a)))))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (= (= (insert$c ?v0 bot$a) (fun_app$f (sup$a ?v1) ?v2)) (or (and (= ?v1 bot$a) (= ?v2 (insert$c ?v0 bot$a))) (or (and (= ?v1 (insert$c ?v0 bot$a)) (= ?v2 bot$a)) (and (= ?v1 (insert$c ?v0 bot$a)) (= ?v2 (insert$c ?v0 bot$a)))))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$)) (member$ ?v0 (insert$b ?v0 ?v1)) ))
(assert (forall ((?v0 A$) (?v1 A_set$)) (member$a ?v0 (insert$c ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (and (not (member$ ?v0 ?v1)) (not (member$ ?v0 ?v2))) (= (= (insert$b ?v0 ?v1) (insert$b ?v0 ?v2)) (= ?v1 ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (and (not (member$a ?v0 ?v1)) (not (member$a ?v0 ?v2))) (= (= (insert$c ?v0 ?v1) (insert$c ?v0 ?v2)) (= ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat$) (?v3 Nat_set$)) (=> (and (not (member$ ?v0 ?v1)) (not (member$ ?v2 ?v3))) (= (= (insert$b ?v0 ?v1) (insert$b ?v2 ?v3)) (ite (= ?v0 ?v2) (= ?v1 ?v3) (exists ((?v4 Nat_set$)) (and (= ?v1 (insert$b ?v2 ?v4)) (and (not (member$ ?v2 ?v4)) (and (= ?v3 (insert$b ?v0 ?v4)) (not (member$ ?v0 ?v4))))) )))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A$) (?v3 A_set$)) (=> (and (not (member$a ?v0 ?v1)) (not (member$a ?v2 ?v3))) (= (= (insert$c ?v0 ?v1) (insert$c ?v2 ?v3)) (ite (= ?v0 ?v2) (= ?v1 ?v3) (exists ((?v4 A_set$)) (and (= ?v1 (insert$c ?v2 ?v4)) (and (not (member$a ?v2 ?v4)) (and (= ?v3 (insert$c ?v0 ?v4)) (not (member$a ?v0 ?v4))))) )))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$)) (=> (member$ ?v0 ?v1) (exists ((?v2 Nat_set$)) (and (= ?v1 (insert$b ?v0 ?v2)) (not (member$ ?v0 ?v2))) )) ))
(assert (forall ((?v0 A$) (?v1 A_set$)) (=> (member$a ?v0 ?v1) (exists ((?v2 A_set$)) (and (= ?v1 (insert$c ?v0 ?v2)) (not (member$a ?v0 ?v2))) )) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat$)) (=> (member$ ?v0 ?v1) (member$ ?v0 (insert$b ?v2 ?v1))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A$)) (=> (member$a ?v0 ?v1) (member$a ?v0 (insert$c ?v2 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$)) (! (=> (member$ ?v0 ?v1) (= (insert$b ?v0 ?v1) ?v1)) :pattern ((insert$b ?v0 ?v1)))))
(assert (forall ((?v0 A$) (?v1 A_set$)) (! (=> (member$a ?v0 ?v1) (= (insert$c ?v0 ?v1) ?v1)) :pattern ((insert$c ?v0 ?v1)))))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$)) (=> (and (member$ ?v0 ?v1) (forall ((?v2 Nat_set$)) (=> (and (= ?v1 (insert$b ?v0 ?v2)) (not (member$ ?v0 ?v2))) false) )) false) ))
(assert (forall ((?v0 A$) (?v1 A_set$)) (=> (and (member$a ?v0 ?v1) (forall ((?v2 A_set$)) (=> (and (= ?v1 (insert$c ?v0 ?v2)) (not (member$a ?v0 ?v2))) false) )) false) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_set$)) (=> (and (member$ ?v0 (insert$b ?v1 ?v2)) (and (=> (= ?v0 ?v1) false) (=> (member$ ?v0 ?v2) false))) false) ))
(assert (forall ((?v0 A$) (?v1 A$) (?v2 A_set$)) (=> (and (member$a ?v0 (insert$c ?v1 ?v2)) (and (=> (= ?v0 ?v1) false) (=> (member$a ?v0 ?v2) false))) false) ))
(assert (forall ((?v0 A$) (?v1 A$) (?v2 A_set$)) (= (insert$c ?v0 (insert$c ?v1 ?v2)) (insert$c ?v1 (insert$c ?v0 ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A$) (?v2 A$) (?v3 A$)) (= (= (insert$c ?v0 (insert$c ?v1 bot$a)) (insert$c ?v2 (insert$c ?v3 bot$a))) (or (and (= ?v0 ?v2) (= ?v1 ?v3)) (and (= ?v0 ?v3) (= ?v1 ?v2)))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (member$ ?v0 (insert$b ?v1 bot$)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 A$) (?v1 A$)) (= (member$a ?v0 (insert$c ?v1 bot$a)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 A$) (?v1 A$)) (=> (= (insert$c ?v0 bot$a) (insert$c ?v1 bot$a)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (member$ ?v0 (insert$b ?v1 bot$)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 A$) (?v1 A$)) (=> (member$a ?v0 (insert$c ?v1 bot$a)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 A$) (?v1 A_set$)) (not (= (insert$c ?v0 ?v1) bot$a)) ))
(assert (forall ((?v0 A$)) (= (the_elem$ (insert$c ?v0 bot$a)) ?v0) ))
(assert (forall ((?v0 Nat_tree$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (= (alphabet$ (fun_app$q (swapLeaves$ ?v0 ?v1 ?v2 ?v3) ?v4)) (ite (member$ ?v2 (alphabet$ ?v0)) (ite (member$ ?v4 (alphabet$ ?v0)) (alphabet$ ?v0) (sup$ (minus$ (alphabet$ ?v0) (insert$b ?v2 bot$)) (insert$b ?v4 bot$))) (ite (member$ ?v4 (alphabet$ ?v0)) (sup$ (minus$ (alphabet$ ?v0) (insert$b ?v4 bot$)) (insert$b ?v2 bot$)) (alphabet$ ?v0)))) ))
(assert (forall ((?v0 A_tree$) (?v1 Nat$) (?v2 A$) (?v3 Nat$) (?v4 A$)) (= (alphabet$a (fun_app$r (swapLeaves$a ?v0 ?v1 ?v2 ?v3) ?v4)) (ite (member$a ?v2 (alphabet$a ?v0)) (ite (member$a ?v4 (alphabet$a ?v0)) (alphabet$a ?v0) (fun_app$f (sup$a (minus$a (alphabet$a ?v0) (insert$c ?v2 bot$a))) (insert$c ?v4 bot$a))) (ite (member$a ?v4 (alphabet$a ?v0)) (fun_app$f (sup$a (minus$a (alphabet$a ?v0) (insert$c ?v4 bot$a))) (insert$c ?v2 bot$a)) (alphabet$a ?v0)))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (= (member$ ?v0 (minus$ ?v1 ?v2)) (and (member$ ?v0 ?v1) (not (member$ ?v0 ?v2)))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (= (member$a ?v0 (minus$a ?v1 ?v2)) (and (member$a ?v0 ?v1) (not (member$a ?v0 ?v2)))) ))
(assert (forall ((?v0 A_set$) (?v1 A_set$)) (= (minus$a (minus$a ?v0 ?v1) ?v1) (minus$a ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_set$) (?v2 Nat_set$)) (=> (and (member$ ?v0 ?v1) (not (member$ ?v0 ?v2))) (member$ ?v0 (minus$ ?v1 ?v2))) ))
(assert (forall ((?v0 A$) (?v1 A_set$) (?v2 A_set$)) (=> (and (member$a ?v0 ?v1) (not (member$a ?v0 ?v2))) (member$a ?v0 (minus$a ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$c (minus$b ?v0) zero$) ?v0) ))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$c (minus$b ?v0) ?v0) zero$) :pattern ((minus$b ?v0)))))
(assert (forall ((?v0 Nat$)) (= (fun_app$c (minus$b zero$) ?v0) zero$) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$c (minus$b (fun_app$c (plus$ ?v0) ?v1)) (fun_app$c (plus$ ?v2) ?v1)) (fun_app$c (minus$b ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$c (minus$b (fun_app$c (plus$ ?v0) ?v1)) (fun_app$c (plus$ ?v0) ?v2)) (fun_app$c (minus$b ?v1) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$c (minus$b (fun_app$c (plus$ ?v0) ?v1)) ?v1) ?v0) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$c (minus$b (fun_app$c (plus$ ?v0) ?v1)) ?v0) ?v1) ))
(check-sat)
(exit)

