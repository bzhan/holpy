{
    "content": [
        {
            "name": "nat_interval",
            "prop": "nat_interval m n = {p. less_eq m p & less_eq p n}",
            "ty": "def",
            "type": "nat => nat => nat set"
        },
        {
            "name": "finite_numseg",
            "prop": "finite {m..n}",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "numseg_combione_r",
            "prop": "m <= p + 1 & p <= n --> (union {m..p} {(p + 1)..n} = {m..n})",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat",
                "p": "nat"
            }
        },
        {
            "name": "numseg_combione_l",
            "prop": "m <= p & p <= n + 1 --> (union {m..(minus p 1)} {p..n} = {m..n})",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat",
                "p": "nat"
            }
        },
        {
            "name": "numseg_lrec",
            "prop": "m <= n --> (insert m {(m+1)..n} = {m..n})",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "numseg_rrec",
            "prop": "m <= n + 1 --> (insert (n + 1) {m..n} = {m..(n + 1)})",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "numseg_rec",
            "prop": "m <= Suc n --> ({m..(Suc n)} = insert (Suc n) {m..n})",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "member_numseg",
            "prop": "member p {m..n} = (m <= p & p <= n)",
            "ty": "thm",
            "vars": {
                "p": "nat",
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "member_numseg_0",
            "prop": "member p {0..n} = (p <= n)",
            "ty": "thm",
            "vars": {
                "p": "nat",
                "n": "nat"
            }
        },
        {
            "name": "numseg_empty",
            "prop": "({m..n} = empty_set) = (n < m)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "numseg_sing",
            "prop": "{n..n} = {n}",
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "name": "inter_numseg",
            "prop": "inter {m..n} {p..q} = {(max m p)..(min n q)}",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat",
                "p": "nat",
                "q": "nat"
            }
        },
        {
            "name": "numseg_add_split",
            "prop": "m <= n + 1 --> {m..(n + p)} = union {m..n} {(n + 1)..(p + 1)}",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat",
                "p": "nat"
            }
        },
        {
            "hint_backward": "true",
            "name": "neutral",
            "prop": "neutral op x = (!y. (op x y = y) & (op y x = y))",
            "ty": "def",
            "type": "('a => 'a => 'a) => 'a => bool"
        }           
    ],
    "description": "Basic results about iterate.",
    "imports": [
        "set"
    ],
    "name": "iterate"
}
