(set-info :smt-lib-version 2.6)
(set-logic UF)
(set-info :source |
Generated by: Andrew Reynolds
Generated on: 2017-04-28
Generator: Sledgehammer, converted to v2.6 by CVC4
Application: Verfication goals in Isabelle
Target solver: CVC4, Z3
Publications: "A Decision Procedure for (Co)Datatypes" by Andrew Reynolds and Jasmin Blanchette, CADE 2015.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unsat)


(declare-sort Nat$ 0)
(declare-sort Rule$ 0)
(declare-sort State$ 0)
(declare-sort Rule_set$ 0)
(declare-sort Rule_fset$ 0)
(declare-sort State_set$ 0)
(declare-sort State_fset$ 0)
(declare-sort Nat_nat_fun$ 0)
(declare-sort Nat_bool_fun$ 0)
(declare-sort Rule_bool_fun$ 0)
(declare-sort State_bool_fun$ 0)
(declare-sort Rule_fset_bool_fun$ 0)
(declare-sort Rule_rule_prod_tree$ 0)
(declare-sort State_fset_bool_fun$ 0)
(declare-sort State_rule_prod_set$ 0)
(declare-sort Nat_nat_bool_fun_fun$ 0)
(declare-sort Rule_state_prod_tree$ 0)
(declare-sort Rule_stream_bool_fun$ 0)
(declare-sort State_rule_prod_fset$ 0)
(declare-sort State_rule_prod_tree$ 0)
(declare-sort State_state_prod_tree$ 0)
(declare-sort State_stream_bool_fun$ 0)
(declare-sort Rule_rule_bool_fun_fun$ 0)
(declare-sort Rule_state_bool_fun_fun$ 0)
(declare-sort Rule_rule_prod_tree_fset$ 0)
(declare-sort State_rule_prod_bool_fun$ 0)
(declare-sort State_rule_prod_tree_set$ 0)
(declare-sort State_rule_prod_tree_fset$ 0)
(declare-sort Rule_rule_fset_bool_fun_fun$ 0)
(declare-sort Rule_rule_stream_bool_fun_fun$ 0)
(declare-sort State_rule_prod_fset_bool_fun$ 0)
(declare-sort State_rule_prod_tree_bool_fun$ 0)
(declare-sort State_state_fset_bool_fun_fun$ 0)
(declare-sort Rule_state_rule_prod_prod_tree$ 0)
(declare-sort State_rule_prod_rule_prod_tree$ 0)
(declare-sort State_rule_prod_state_prod_tree$ 0)
(declare-sort State_rule_prod_stream_bool_fun$ 0)
(declare-sort State_state_rule_prod_prod_tree$ 0)
(declare-sort State_state_stream_bool_fun_fun$ 0)
(declare-sort State_rule_prod_rule_bool_fun_fun$ 0)
(declare-sort State_rule_prod_state_bool_fun_fun$ 0)
(declare-sort State_rule_prod_tree_fset_bool_fun$ 0)
(declare-sort Rule_state_rule_prod_prod_tree_fset$ 0)
(declare-sort State_rule_prod_tree_rule_prod_tree$ 0)
(declare-sort Rule_rule_rule_fset_bool_fun_fun_fun$ 0)
(declare-sort Rule_stream_rule_stream_bool_fun_fun$ 0)
(declare-sort State_rule_prod_tree_state_prod_tree$ 0)
(declare-sort State_state_rule_prod_prod_tree_fset$ 0)
(declare-sort State_rule_rule_fset_bool_fun_fun_fun$ 0)
(declare-sort Rule_state_state_fset_bool_fun_fun_fun$ 0)
(declare-sort State_state_state_fset_bool_fun_fun_fun$ 0)
(declare-sort State_rule_prod_tree_rule_prod_tree_fset$ 0)
(declare-sort Rule_stream_state_rule_prod_tree_bool_fun_fun$ 0)
(declare-sort State_rule_prod_tree_state_rule_prod_prod_tree$ 0)
(declare-sort State_rule_prod_rule_rule_fset_bool_fun_fun_fun$ 0)
(declare-sort State_rule_prod_state_rule_prod_fset_bool_fun_fun$ 0)
(declare-sort State_rule_prod_state_state_fset_bool_fun_fun_fun$ 0)
(declare-sort State_rule_prod_state_rule_prod_stream_bool_fun_fun$ 0)
(declare-sort State_rule_prod_tree_state_rule_prod_prod_tree_fset$ 0)
(declare-sort State_rule_prod_tree_rule_rule_fset_bool_fun_fun_fun$ 0)
(declare-sort State_rule_prod_tree_state_state_fset_bool_fun_fun_fun$ 0)
(declare-sort Rule_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$ 0)
(declare-sort State_rule_prod_stream_state_rule_prod_stream_bool_fun_fun$ 0)
(declare-sort State_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun$ 0)
(declare-sort State_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$ 0)
(declare-sort Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ 0)
(declare-sort State_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ 0)
(declare-sort State_rule_prod_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ 0)
(declare-sort Rule_stream$ 0)
(declare-fun shd$ (Rule_stream$) Rule$)
(declare-fun stl$ (Rule_stream$) Rule_stream$)
(declare-fun sCons$ (Rule$ Rule_stream$) Rule_stream$)
(declare-sort State_rule_prod$ 0)
(declare-fun fst$ (State_rule_prod$) State$)
(declare-fun snd$ (State_rule_prod$) Rule$)
(declare-fun pair$ (State$ Rule$) State_rule_prod$)
(declare-sort State_rule_prod_stream$ 0)
(declare-fun shd$a (State_rule_prod_stream$) State_rule_prod$)
(declare-fun stl$a (State_rule_prod_stream$) State_rule_prod_stream$)
(declare-fun sCons$a (State_rule_prod$ State_rule_prod_stream$) State_rule_prod_stream$)
(declare-sort Rule_rule_prod$ 0)
(declare-fun fst$a (Rule_rule_prod$) Rule$)
(declare-fun snd$a (Rule_rule_prod$) Rule$)
(declare-fun pair$a (Rule$ Rule$) Rule_rule_prod$)
(declare-sort Rule_rule_prod_stream$ 0)
(declare-fun shd$b (Rule_rule_prod_stream$) Rule_rule_prod$)
(declare-fun stl$b (Rule_rule_prod_stream$) Rule_rule_prod_stream$)
(declare-fun sCons$b (Rule_rule_prod$ Rule_rule_prod_stream$) Rule_rule_prod_stream$)
(declare-sort State_state_rule_prod_prod$ 0)
(declare-fun fst$b (State_state_rule_prod_prod$) State$)
(declare-fun snd$b (State_state_rule_prod_prod$) State_rule_prod$)
(declare-fun pair$b (State$ State_rule_prod$) State_state_rule_prod_prod$)
(declare-sort State_state_rule_prod_prod_stream$ 0)
(declare-fun shd$c (State_state_rule_prod_prod_stream$) State_state_rule_prod_prod$)
(declare-fun stl$c (State_state_rule_prod_prod_stream$) State_state_rule_prod_prod_stream$)
(declare-fun sCons$c (State_state_rule_prod_prod$ State_state_rule_prod_prod_stream$) State_state_rule_prod_prod_stream$)
(declare-sort Rule_state_rule_prod_prod$ 0)
(declare-fun fst$c (Rule_state_rule_prod_prod$) Rule$)
(declare-fun snd$c (Rule_state_rule_prod_prod$) State_rule_prod$)
(declare-fun pair$c (Rule$ State_rule_prod$) Rule_state_rule_prod_prod$)
(declare-sort Rule_state_rule_prod_prod_stream$ 0)
(declare-sort State_stream$ 0)
(declare-sort State_rule_prod_tree_stream$ 0)
(declare-fun shd$d (Rule_state_rule_prod_prod_stream$) Rule_state_rule_prod_prod$)
(declare-fun stl$d (Rule_state_rule_prod_prod_stream$) Rule_state_rule_prod_prod_stream$)
(declare-fun sCons$d (Rule_state_rule_prod_prod$ Rule_state_rule_prod_prod_stream$) Rule_state_rule_prod_prod_stream$)
(declare-fun shd$e (State_stream$) State$)
(declare-fun stl$e (State_stream$) State_stream$)
(declare-fun sCons$e (State$ State_stream$) State_stream$)
(declare-fun shd$f (State_rule_prod_tree_stream$) State_rule_prod_tree$)
(declare-fun stl$f (State_rule_prod_tree_stream$) State_rule_prod_tree_stream$)
(declare-fun sCons$f (State_rule_prod_tree$ State_rule_prod_tree_stream$) State_rule_prod_tree_stream$)
(declare-fun r$ () Rule$)
(declare-fun s$ () State_set$)
(declare-fun rs$ () Rule_stream$)
(declare-fun s$a () State$)
(declare-fun s$b () State$)
(declare-fun sa$ () State$)
(declare-fun uu$ (State_rule_prod_tree_set$) State_rule_prod_tree_bool_fun$)
(declare-fun wf$ (Rule_state_state_fset_bool_fun_fun_fun$) Rule_stream_state_rule_prod_tree_bool_fun_fun$)
(declare-fun bot$ () Rule_set$)
(declare-fun eff$ () Rule_state_state_fset_bool_fun_fun_fun$)
(declare-fun pos$ (Rule_stream$ Rule$) Nat$)
(declare-fun rsa$ () Rule_stream$)
(declare-fun suc$ (Nat$) Nat$)
(declare-fun uua$ (State_rule_prod_set$) State_rule_prod_bool_fun$)
(declare-fun uub$ (Rule_set$) Rule_bool_fun$)
(declare-fun uuc$ (State_set$) State_bool_fun$)
(declare-fun wf$a (Rule_rule_rule_fset_bool_fun_fun_fun$ Rule_stream$ Rule_rule_prod_tree$) Bool)
(declare-fun wf$b (State_state_state_fset_bool_fun_fun_fun$ State_stream$ State_state_prod_tree$) Bool)
(declare-fun wf$c (State_rule_rule_fset_bool_fun_fun_fun$ State_stream$ Rule_state_prod_tree$) Bool)
(declare-fun wf$d (Rule_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$ Rule_stream$ State_rule_prod_rule_prod_tree$) Bool)
(declare-fun wf$e (State_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$ State_stream$ State_rule_prod_state_prod_tree$) Bool)
(declare-fun wf$f (State_rule_prod_state_state_fset_bool_fun_fun_fun$ State_rule_prod_stream$ State_state_rule_prod_prod_tree$) Bool)
(declare-fun wf$g (State_rule_prod_rule_rule_fset_bool_fun_fun_fun$ State_rule_prod_stream$ Rule_state_rule_prod_prod_tree$) Bool)
(declare-fun wf$h (State_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ State_stream$ State_rule_prod_tree_state_prod_tree$) Bool)
(declare-fun wf$i (Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ Rule_stream$ State_rule_prod_tree_rule_prod_tree$) Bool)
(declare-fun bot$a () Nat$)
(declare-fun bot$b () State_set$)
(declare-fun bot$c () State_fset$)
(declare-fun bot$d () State_rule_prod_tree_fset$)
(declare-fun bot$e () Rule_bool_fun$)
(declare-fun cont$ (State_rule_prod_tree$) State_rule_prod_tree_fset$)
(declare-fun fair$ (Rule_stream$ Rule_stream$) Bool)
(declare-fun less$ (Nat$) Nat_bool_fun$)
(declare-fun pos$a (Rule_rule_prod_stream$ Rule_rule_prod$) Nat$)
(declare-fun pos$b (State_state_rule_prod_prod_stream$ State_state_rule_prod_prod$) Nat$)
(declare-fun pos$c (Rule_state_rule_prod_prod_stream$ Rule_state_rule_prod_prod$) Nat$)
(declare-fun pos$d (State_stream$ State$) Nat$)
(declare-fun pos$e (State_rule_prod_stream$ State_rule_prod$) Nat$)
(declare-fun root$ (State_rule_prod_tree$) State_rule_prod$)
(declare-fun sset$ (Rule_stream$) Rule_set$)
(declare-fun trim$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule_stream$ State$) Rule_stream$)
(declare-fun cont$a (Rule_state_rule_prod_prod_tree$) Rule_state_rule_prod_prod_tree_fset$)
(declare-fun cont$b (State_state_rule_prod_prod_tree$) State_state_rule_prod_prod_tree_fset$)
(declare-fun cont$c (State_rule_prod_tree_state_rule_prod_prod_tree$) State_rule_prod_tree_state_rule_prod_prod_tree_fset$)
(declare-fun cont$d (Rule_rule_prod_tree$) Rule_rule_prod_tree_fset$)
(declare-fun cont$e (State_rule_prod_tree_rule_prod_tree$) State_rule_prod_tree_rule_prod_tree_fset$)
(declare-fun epath$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule_stream$ State_rule_prod_stream$) Bool)
(declare-fun fair$a (Rule_rule_prod_stream$ Rule_rule_prod_stream$) Bool)
(declare-fun fair$b (State_state_rule_prod_prod_stream$ State_state_rule_prod_prod_stream$) Bool)
(declare-fun fair$c (Rule_state_rule_prod_prod_stream$ Rule_state_rule_prod_prod_stream$) Bool)
(declare-fun fair$d (State_stream$ State_stream$) Bool)
(declare-fun fair$e (State_rule_prod_stream$ State_rule_prod_stream$) Bool)
(declare-fun fenum$ (Rule_stream$) Rule_stream$)
(declare-fun ipath$ (State_rule_prod_tree$ State_rule_prod_stream$) Bool)
(declare-fun less$a (Rule_set$ Rule_set$) Bool)
(declare-fun less$b (State_fset$ State_fset$) Bool)
(declare-fun less$c (State_rule_prod_tree_fset$ State_rule_prod_tree_fset$) Bool)
(declare-fun minus$ (Nat$) Nat_nat_fun$)
(declare-fun rules$ () Rule_stream$)
(declare-fun sdrop$ (Nat$ Rule_stream$) Rule_stream$)
(declare-fun sset$a (State_stream$) State_set$)
(declare-fun sset$b (State_rule_prod_stream$) State_rule_prod_set$)
(declare-fun sset$c (State_rule_prod_tree_stream$) State_rule_prod_tree_set$)
(declare-fun steps$ () State_rule_prod_stream$)
(declare-fun trim$a (State_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ State_stream$ State_rule_prod_tree$) State_stream$)
(declare-fun trim$b (Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ Rule_stream$ State_rule_prod_tree$) Rule_stream$)
(declare-fun trim$c (State_rule_rule_fset_bool_fun_fun_fun$ State_stream$ Rule$) State_stream$)
(declare-fun trim$d (State_state_state_fset_bool_fun_fun_fun$ State_stream$ State$) State_stream$)
(declare-fun trim$e (State_rule_prod_rule_rule_fset_bool_fun_fun_fun$ State_rule_prod_stream$ Rule$) State_rule_prod_stream$)
(declare-fun trim$f (State_rule_prod_state_state_fset_bool_fun_fun_fun$ State_rule_prod_stream$ State$) State_rule_prod_stream$)
(declare-fun trim$g (Rule_rule_rule_fset_bool_fun_fun_fun$ Rule_stream$ Rule$) Rule_stream$)
(declare-fun trim$h (State_rule_prod_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ State_rule_prod_stream$ State_rule_prod_tree$) State_rule_prod_stream$)
(declare-fun ipath$a (Rule_state_rule_prod_prod_tree$ Rule_state_rule_prod_prod_stream$) Bool)
(declare-fun ipath$b (State_state_rule_prod_prod_tree$ State_state_rule_prod_prod_stream$) Bool)
(declare-fun ipath$c (Rule_rule_prod_tree$ Rule_rule_prod_stream$) Bool)
(declare-fun member$ (State_rule_prod_tree$ State_rule_prod_tree_set$) Bool)
(declare-fun mkTree$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule_stream$ State$) State_rule_prod_tree$)
(declare-fun sdrop$a (Nat$ Rule_rule_prod_stream$) Rule_rule_prod_stream$)
(declare-fun sdrop$b (Nat$ State_state_rule_prod_prod_stream$) State_state_rule_prod_prod_stream$)
(declare-fun sdrop$c (Nat$ Rule_state_rule_prod_prod_stream$) Rule_state_rule_prod_prod_stream$)
(declare-fun sdrop$d (Nat$ State_stream$) State_stream$)
(declare-fun sdrop$e (Nat$ State_rule_prod_stream$) State_rule_prod_stream$)
(declare-fun stepsa$ () State_rule_prod_stream$)
(declare-fun collect$ (State_bool_fun$) State_set$)
(declare-fun enabled$ (Rule_state_state_fset_bool_fun_fun_fun$) Rule_state_bool_fun_fun$)
(declare-fun fmember$ (State$ State_fset$) Bool)
(declare-fun fun_app$ (State_rule_prod_tree_bool_fun$ State_rule_prod_tree$) Bool)
(declare-fun less_eq$ (Nat$) Nat_bool_fun$)
(declare-fun member$a (State_rule_prod$ State_rule_prod_set$) Bool)
(declare-fun member$b (State$ State_set$) Bool)
(declare-fun member$c (Rule$ Rule_set$) Bool)
(declare-fun minWait$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule_stream$ State$) Nat$)
(declare-fun mkTree$a (Rule_rule_rule_fset_bool_fun_fun_fun$ Rule_stream$ Rule$) Rule_rule_prod_tree$)
(declare-fun mkTree$b (State_state_state_fset_bool_fun_fun_fun$ State_stream$ State$) State_state_prod_tree$)
(declare-fun mkTree$c (State_rule_rule_fset_bool_fun_fun_fun$ State_stream$ Rule$) Rule_state_prod_tree$)
(declare-fun mkTree$d (Rule_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$ Rule_stream$ State_rule_prod$) State_rule_prod_rule_prod_tree$)
(declare-fun mkTree$e (State_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$ State_stream$ State_rule_prod$) State_rule_prod_state_prod_tree$)
(declare-fun mkTree$f (State_rule_prod_state_state_fset_bool_fun_fun_fun$ State_rule_prod_stream$ State$) State_state_rule_prod_prod_tree$)
(declare-fun mkTree$g (State_rule_prod_rule_rule_fset_bool_fun_fun_fun$ State_rule_prod_stream$ Rule$) Rule_state_rule_prod_prod_tree$)
(declare-fun mkTree$h (State_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ State_stream$ State_rule_prod_tree$) State_rule_prod_tree_state_prod_tree$)
(declare-fun mkTree$i (Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ Rule_stream$ State_rule_prod_tree$) State_rule_prod_tree_rule_prod_tree$)
(declare-fun mkTree$j (State_rule_prod_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ State_rule_prod_stream$ State_rule_prod_tree$) State_rule_prod_tree_state_rule_prod_prod_tree$)
(declare-fun pickEff$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule$ State$) State_fset$)
(declare-fun collect$a (Rule_bool_fun$) Rule_set$)
(declare-fun collect$b (State_rule_prod_tree_bool_fun$) State_rule_prod_tree_set$)
(declare-fun collect$c (State_rule_prod_bool_fun$) State_rule_prod_set$)
(declare-fun enabled$a (Rule_rule_rule_fset_bool_fun_fun_fun$) Rule_rule_bool_fun_fun$)
(declare-fun enabled$b (State_rule_prod_state_state_fset_bool_fun_fun_fun$) State_rule_prod_state_bool_fun_fun$)
(declare-fun enabled$c (State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) State_rule_prod_rule_bool_fun_fun$)
(declare-fun fmember$a (Rule$ Rule_fset$) Bool)
(declare-fun fmember$b (State_rule_prod_tree$ State_rule_prod_tree_fset$) Bool)
(declare-fun fmember$c (State_rule_prod$ State_rule_prod_fset$) Bool)
(declare-fun fmember$d (Rule_state_rule_prod_prod_tree$ Rule_state_rule_prod_prod_tree_fset$) Bool)
(declare-fun fmember$e (State_state_rule_prod_prod_tree$ State_state_rule_prod_prod_tree_fset$) Bool)
(declare-fun fmember$f (State_rule_prod_tree_state_rule_prod_prod_tree$ State_rule_prod_tree_state_rule_prod_prod_tree_fset$) Bool)
(declare-fun fmember$g (Rule_rule_prod_tree$ Rule_rule_prod_tree_fset$) Bool)
(declare-fun fmember$h (State_rule_prod_tree_rule_prod_tree$ State_rule_prod_tree_rule_prod_tree_fset$) Bool)
(declare-fun fun_app$a (State_rule_prod_bool_fun$ State_rule_prod$) Bool)
(declare-fun fun_app$b (State_bool_fun$ State$) Bool)
(declare-fun fun_app$c (Rule_bool_fun$ Rule$) Bool)
(declare-fun fun_app$d (Nat_bool_fun$ Nat$) Bool)
(declare-fun fun_app$e (Rule_state_bool_fun_fun$ Rule$) State_bool_fun$)
(declare-fun fun_app$f (State_fset_bool_fun$ State_fset$) Bool)
(declare-fun fun_app$g (State_state_fset_bool_fun_fun$ State$) State_fset_bool_fun$)
(declare-fun fun_app$h (Rule_state_state_fset_bool_fun_fun_fun$ Rule$) State_state_fset_bool_fun_fun$)
(declare-fun fun_app$i (Nat_nat_bool_fun_fun$ Nat$) Nat_bool_fun$)
(declare-fun fun_app$j (Rule_rule_bool_fun_fun$ Rule$) Rule_bool_fun$)
(declare-fun fun_app$k (Rule_fset_bool_fun$ Rule_fset$) Bool)
(declare-fun fun_app$l (Rule_rule_fset_bool_fun_fun$ Rule$) Rule_fset_bool_fun$)
(declare-fun fun_app$m (Rule_rule_rule_fset_bool_fun_fun_fun$ Rule$) Rule_rule_fset_bool_fun_fun$)
(declare-fun fun_app$n (State_rule_prod_state_bool_fun_fun$ State_rule_prod$) State_bool_fun$)
(declare-fun fun_app$o (State_rule_prod_state_state_fset_bool_fun_fun_fun$ State_rule_prod$) State_state_fset_bool_fun_fun$)
(declare-fun fun_app$p (State_rule_prod_rule_bool_fun_fun$ State_rule_prod$) Rule_bool_fun$)
(declare-fun fun_app$q (State_rule_prod_rule_rule_fset_bool_fun_fun_fun$ State_rule_prod$) Rule_rule_fset_bool_fun_fun$)
(declare-fun fun_app$r (Nat_nat_fun$ Nat$) Nat$)
(declare-fun fun_app$s (Rule_stream_state_rule_prod_tree_bool_fun_fun$ Rule_stream$) State_rule_prod_tree_bool_fun$)
(declare-fun fun_app$t (State_rule_rule_fset_bool_fun_fun_fun$ State$) Rule_rule_fset_bool_fun_fun$)
(declare-fun fun_app$u (State_state_state_fset_bool_fun_fun_fun$ State$) State_state_fset_bool_fun_fun$)
(declare-fun fun_app$v (State_rule_prod_tree_fset_bool_fun$ State_rule_prod_tree_fset$) Bool)
(declare-fun fun_app$w (State_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun$ State_rule_prod_tree$) State_rule_prod_tree_fset_bool_fun$)
(declare-fun fun_app$x (State_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ State$) State_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun$)
(declare-fun fun_app$y (Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ Rule$) State_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun$)
(declare-fun fun_app$z (State_rule_prod_fset_bool_fun$ State_rule_prod_fset$) Bool)
(declare-fun less_eq$a (Rule_set$ Rule_set$) Bool)
(declare-fun less_eq$b (State_fset$ State_fset$) Bool)
(declare-fun less_eq$c (State_rule_prod_tree_fset$ State_rule_prod_tree_fset$) Bool)
(declare-fun minWait$a (State_rule_prod_rule_rule_fset_bool_fun_fun_fun$ State_rule_prod_stream$ Rule$) Nat$)
(declare-fun minWait$b (State_rule_prod_state_state_fset_bool_fun_fun_fun$ State_rule_prod_stream$ State$) Nat$)
(declare-fun minWait$c (Rule_rule_rule_fset_bool_fun_fun_fun$ Rule_stream$ Rule$) Nat$)
(declare-fun pickEff$a (Rule_rule_rule_fset_bool_fun_fun_fun$ Rule$ Rule$) Rule_fset$)
(declare-fun pickEff$b (State_rule_prod_state_state_fset_bool_fun_fun_fun$ State_rule_prod$ State$) State_fset$)
(declare-fun pickEff$c (State_rule_prod_rule_rule_fset_bool_fun_fun_fun$ State_rule_prod$ Rule$) Rule_fset$)
(declare-fun fun_app$aa (State_rule_prod_state_rule_prod_fset_bool_fun_fun$ State_rule_prod$) State_rule_prod_fset_bool_fun$)
(declare-fun fun_app$ab (Rule_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$ Rule$) State_rule_prod_state_rule_prod_fset_bool_fun_fun$)
(declare-fun fun_app$ac (State_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$ State$) State_rule_prod_state_rule_prod_fset_bool_fun_fun$)
(declare-fun fun_app$ad (State_rule_prod_tree_rule_rule_fset_bool_fun_fun_fun$ State_rule_prod_tree$) Rule_rule_fset_bool_fun_fun$)
(declare-fun fun_app$ae (State_rule_prod_tree_state_state_fset_bool_fun_fun_fun$ State_rule_prod_tree$) State_state_fset_bool_fun_fun$)
(declare-fun fun_app$af (Rule_stream_bool_fun$ Rule_stream$) Bool)
(declare-fun fun_app$ag (Rule_stream_rule_stream_bool_fun_fun$ Rule_stream$) Rule_stream_bool_fun$)
(declare-fun fun_app$ah (State_rule_prod_stream_bool_fun$ State_rule_prod_stream$) Bool)
(declare-fun fun_app$ai (State_rule_prod_stream_state_rule_prod_stream_bool_fun_fun$ State_rule_prod_stream$) State_rule_prod_stream_bool_fun$)
(declare-fun fun_app$aj (State_stream_bool_fun$ State_stream$) Bool)
(declare-fun fun_app$ak (State_state_stream_bool_fun_fun$ State$) State_stream_bool_fun$)
(declare-fun fun_app$al (State_rule_prod_state_rule_prod_stream_bool_fun_fun$ State_rule_prod$) State_rule_prod_stream_bool_fun$)
(declare-fun fun_app$am (Rule_rule_stream_bool_fun_fun$ Rule$) Rule_stream_bool_fun$)
(declare-fun fun_app$an (State_rule_prod_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ State_rule_prod$) State_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun$)
(declare-fun saturated$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule_stream$ State_rule_prod_stream$) Bool)
(declare-fun ruleSystem$ (Rule_state_state_fset_bool_fun_fun_fun$ Rule_stream$ State_set$) Bool)
(declare-fun saturated$a (Rule_state_state_fset_bool_fun_fun_fun$ Rule$ State_rule_prod_stream$) Bool)
(declare-fun ruleSystem$a (State_rule_rule_fset_bool_fun_fun_fun$ State_stream$ Rule_set$) Bool)
(declare-fun ruleSystem$b (State_state_state_fset_bool_fun_fun_fun$ State_stream$ State_set$) Bool)
(declare-fun ruleSystem$c (Rule_rule_rule_fset_bool_fun_fun_fun$ Rule_stream$ Rule_set$) Bool)
(declare-fun ruleSystem$d (State_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ State_stream$ State_rule_prod_tree_set$) Bool)
(declare-fun ruleSystem$e (Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ Rule_stream$ State_rule_prod_tree_set$) Bool)
(declare-fun ruleSystem$f (Rule_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$ Rule_stream$ State_rule_prod_set$) Bool)
(declare-fun ruleSystem$g (State_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$ State_stream$ State_rule_prod_set$) Bool)
(declare-fun ruleSystem$h (State_rule_prod_state_state_fset_bool_fun_fun_fun$ State_rule_prod_stream$ State_set$) Bool)
(declare-fun ruleSystem$i (State_rule_prod_rule_rule_fset_bool_fun_fun_fun$ State_rule_prod_stream$ Rule_set$) Bool)
(declare-fun ruleSystem$j (State_rule_prod_tree_rule_rule_fset_bool_fun_fun_fun$ State_rule_prod_tree_stream$ Rule_set$) Bool)
(declare-fun ruleSystem$k (State_rule_prod_tree_state_state_fset_bool_fun_fun_fun$ State_rule_prod_tree_stream$ State_set$) Bool)
(declare-fun ruleSystem$l (State_rule_prod_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$ State_rule_prod_stream$ State_rule_prod_tree_set$) Bool)
(assert (forall ((?v0 State_rule_prod_tree_set$) (?v1 State_rule_prod_tree$)) (! (= (fun_app$ (uu$ ?v0) ?v1) (member$ ?v1 ?v0)) :pattern ((fun_app$ (uu$ ?v0) ?v1)))))
(assert (forall ((?v0 State_rule_prod_set$) (?v1 State_rule_prod$)) (! (= (fun_app$a (uua$ ?v0) ?v1) (member$a ?v1 ?v0)) :pattern ((fun_app$a (uua$ ?v0) ?v1)))))
(assert (forall ((?v0 State_set$) (?v1 State$)) (! (= (fun_app$b (uuc$ ?v0) ?v1) (member$b ?v1 ?v0)) :pattern ((fun_app$b (uuc$ ?v0) ?v1)))))
(assert (forall ((?v0 Rule_set$) (?v1 Rule$)) (! (= (fun_app$c (uub$ ?v0) ?v1) (member$c ?v1 ?v0)) :pattern ((fun_app$c (uub$ ?v0) ?v1)))))
(assert (not (fun_app$d (less$ (minWait$ eff$ rsa$ sa$)) (pos$ rsa$ r$))))
(assert (fair$ rules$ rs$))
(assert (fair$ rules$ rsa$))
(assert (member$c r$ (sset$ rules$)))
(assert (fun_app$b (fun_app$e (enabled$ eff$) r$) sa$))
(assert (forall ((?v0 Rule$) (?v1 State$)) (! (= (fun_app$b (fun_app$e (enabled$ eff$) ?v0) ?v1) (exists ((?v2 State_fset$)) (fun_app$f (fun_app$g (fun_app$h eff$ ?v0) ?v1) ?v2) )) :pattern ((fun_app$b (fun_app$e (enabled$ eff$) ?v0) ?v1)))))
(assert (not (= (pos$ rsa$ r$) (minWait$ eff$ rsa$ sa$))))
(assert (forall ((?v0 Rule_stream$) (?v1 Rule$) (?v2 State$)) (=> (and (fair$ rules$ ?v0) (and (member$c ?v1 (sset$ rules$)) (fun_app$b (fun_app$e (enabled$ eff$) ?v1) ?v2))) (fun_app$d (less_eq$ (minWait$ eff$ ?v0 ?v2)) (pos$ ?v0 ?v1))) ))
(assert (member$b sa$ s$))
(assert (forall ((?v0 Rule$) (?v1 State$)) (=> (fun_app$b (fun_app$e (enabled$ eff$) ?v0) ?v1) (fun_app$f (fun_app$g (fun_app$h eff$ ?v0) ?v1) (pickEff$ eff$ ?v0 ?v1))) ))
(assert (= (trim$ eff$ rsa$ sa$) (sdrop$ (minWait$ eff$ rsa$ sa$) rsa$)))
(assert (ipath$ (mkTree$ eff$ rsa$ sa$) stepsa$))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (not (= ?v0 ?v1)) (or (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less$ ?v1) ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_bool_fun_fun$)) (=> (and (=> (fun_app$d (less$ ?v0) ?v1) (fun_app$d (fun_app$i ?v2 ?v1) ?v0)) (and (=> (= ?v0 ?v1) (fun_app$d (fun_app$i ?v2 ?v1) ?v0)) (=> (fun_app$d (less$ ?v1) ?v0) (fun_app$d (fun_app$i ?v2 ?v1) ?v0)))) (fun_app$d (fun_app$i ?v2 ?v1) ?v0)) ))
(assert (forall ((?v0 Nat_bool_fun$) (?v1 Nat$)) (=> (forall ((?v2 Nat$)) (=> (not (fun_app$d ?v0 ?v2)) (exists ((?v3 Nat$)) (and (fun_app$d (less$ ?v3) ?v2) (not (fun_app$d ?v0 ?v3))) )) ) (fun_app$d ?v0 ?v1)) ))
(assert (forall ((?v0 Nat_bool_fun$) (?v1 Nat$)) (=> (forall ((?v2 Nat$)) (=> (forall ((?v3 Nat$)) (=> (fun_app$d (less$ ?v3) ?v2) (fun_app$d ?v0 ?v3)) ) (fun_app$d ?v0 ?v2)) ) (fun_app$d ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (not (= ?v0 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (not (= ?v1 ?v0))) ))
(assert (member$b s$a s$))
(assert (member$b s$b s$))
(assert (forall ((?v0 Rule_stream$) (?v1 Nat$)) (=> (fair$ rules$ ?v0) (fair$ rules$ (sdrop$ ?v1 ?v0))) ))
(assert (forall ((?v0 State$)) (=> (member$b ?v0 s$) (exists ((?v1 Rule$)) (and (member$c ?v1 (sset$ rules$)) (exists ((?v2 State_fset$)) (fun_app$f (fun_app$g (fun_app$h eff$ ?v1) ?v0) ?v2) )) )) ))
(assert (forall ((?v0 State$) (?v1 Rule_stream$)) (=> (and (member$b ?v0 s$) (fair$ rules$ ?v1)) (fair$ rules$ (trim$ eff$ ?v1 ?v0))) ))
(assert (ruleSystem$ eff$ rules$ s$))
(assert (forall ((?v0 State$) (?v1 Rule_stream$)) (! (=> (and (member$b ?v0 s$) (fair$ rules$ ?v1)) (= (trim$ eff$ ?v1 ?v0) (sdrop$ (minWait$ eff$ ?v1 ?v0) ?v1))) :pattern ((trim$ eff$ ?v1 ?v0)))))
(assert (ipath$ (mkTree$ eff$ rs$ s$b) steps$))
(assert (= (sset$ (fenum$ rules$)) (sset$ rules$)))
(assert (fair$ rules$ (fenum$ rules$)))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (= ?v0 ?v1) (fun_app$d (less_eq$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v0)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v2)) (fun_app$d (less_eq$ ?v0) ?v2)) ))
(assert (forall ((?v0 Rule_rule_prod_stream$) (?v1 Rule_rule_prod_stream$) (?v2 Nat$)) (=> (fair$a ?v0 ?v1) (fair$a ?v0 (sdrop$a ?v2 ?v1))) ))
(assert (forall ((?v0 State_state_rule_prod_prod_stream$) (?v1 State_state_rule_prod_prod_stream$) (?v2 Nat$)) (=> (fair$b ?v0 ?v1) (fair$b ?v0 (sdrop$b ?v2 ?v1))) ))
(assert (forall ((?v0 Rule_state_rule_prod_prod_stream$) (?v1 Rule_state_rule_prod_prod_stream$) (?v2 Nat$)) (=> (fair$c ?v0 ?v1) (fair$c ?v0 (sdrop$c ?v2 ?v1))) ))
(assert (forall ((?v0 State_stream$) (?v1 State_stream$) (?v2 Nat$)) (=> (fair$d ?v0 ?v1) (fair$d ?v0 (sdrop$d ?v2 ?v1))) ))
(assert (forall ((?v0 State_rule_prod_stream$) (?v1 State_rule_prod_stream$) (?v2 Nat$)) (=> (fair$e ?v0 ?v1) (fair$e ?v0 (sdrop$e ?v2 ?v1))) ))
(assert (forall ((?v0 Rule_stream$) (?v1 Rule_stream$) (?v2 Nat$)) (=> (fair$ ?v0 ?v1) (fair$ ?v0 (sdrop$ ?v2 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (or (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v0)) ))
(assert (forall ((?v0 Nat$)) (fun_app$d (less_eq$ ?v0) ?v0) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule$) (?v2 Rule$)) (=> (fun_app$c (fun_app$j (enabled$a ?v0) ?v1) ?v2) (fun_app$k (fun_app$l (fun_app$m ?v0 ?v1) ?v2) (pickEff$a ?v0 ?v1 ?v2))) ))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod$) (?v2 State$)) (=> (fun_app$b (fun_app$n (enabled$b ?v0) ?v1) ?v2) (fun_app$f (fun_app$g (fun_app$o ?v0 ?v1) ?v2) (pickEff$b ?v0 ?v1 ?v2))) ))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod$) (?v2 Rule$)) (=> (fun_app$c (fun_app$p (enabled$c ?v0) ?v1) ?v2) (fun_app$k (fun_app$l (fun_app$q ?v0 ?v1) ?v2) (pickEff$c ?v0 ?v1 ?v2))) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule$) (?v2 State$)) (=> (fun_app$b (fun_app$e (enabled$ ?v0) ?v1) ?v2) (fun_app$f (fun_app$g (fun_app$h ?v0 ?v1) ?v2) (pickEff$ ?v0 ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (not (= ?v0 ?v1))) (fun_app$d (less$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less_eq$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (or (fun_app$d (less$ ?v0) ?v1) (= ?v0 ?v1)) (fun_app$d (less_eq$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat_nat_fun$) (?v1 Nat$) (?v2 Nat$)) (=> (and (forall ((?v3 Nat$) (?v4 Nat$)) (=> (fun_app$d (less$ ?v3) ?v4) (fun_app$d (less$ (fun_app$r ?v0 ?v3)) (fun_app$r ?v0 ?v4))) ) (fun_app$d (less_eq$ ?v1) ?v2)) (fun_app$d (less_eq$ (fun_app$r ?v0 ?v1)) (fun_app$r ?v0 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less_eq$ ?v0) ?v1) (or (fun_app$d (less$ ?v0) ?v1) (= ?v0 ?v1))) :pattern ((fun_app$d (less_eq$ ?v0) ?v1)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less$ ?v0) ?v1) (and (fun_app$d (less_eq$ ?v0) ?v1) (not (= ?v0 ?v1)))) :pattern ((fun_app$d (less$ ?v0) ?v1)))))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule$) (?v2 Rule$)) (! (= (fun_app$c (fun_app$j (enabled$a ?v0) ?v1) ?v2) (exists ((?v3 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$m ?v0 ?v1) ?v2) ?v3) )) :pattern ((fun_app$c (fun_app$j (enabled$a ?v0) ?v1) ?v2)))))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod$) (?v2 State$)) (! (= (fun_app$b (fun_app$n (enabled$b ?v0) ?v1) ?v2) (exists ((?v3 State_fset$)) (fun_app$f (fun_app$g (fun_app$o ?v0 ?v1) ?v2) ?v3) )) :pattern ((fun_app$b (fun_app$n (enabled$b ?v0) ?v1) ?v2)))))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod$) (?v2 Rule$)) (! (= (fun_app$c (fun_app$p (enabled$c ?v0) ?v1) ?v2) (exists ((?v3 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$q ?v0 ?v1) ?v2) ?v3) )) :pattern ((fun_app$c (fun_app$p (enabled$c ?v0) ?v1) ?v2)))))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule$) (?v2 State$)) (! (= (fun_app$b (fun_app$e (enabled$ ?v0) ?v1) ?v2) (exists ((?v3 State_fset$)) (fun_app$f (fun_app$g (fun_app$h ?v0 ?v1) ?v2) ?v3) )) :pattern ((fun_app$b (fun_app$e (enabled$ ?v0) ?v1) ?v2)))))
(assert (forall ((?v0 Nat$)) (not (fun_app$d (less$ ?v0) ?v0)) ))
(assert (forall ((?v0 State_bool_fun$) (?v1 State_bool_fun$)) (=> (forall ((?v2 State$)) (= (fun_app$b ?v0 ?v2) (fun_app$b ?v1 ?v2)) ) (= (collect$ ?v0) (collect$ ?v1))) ))
(assert (forall ((?v0 Rule_bool_fun$) (?v1 Rule_bool_fun$)) (=> (forall ((?v2 Rule$)) (= (fun_app$c ?v0 ?v2) (fun_app$c ?v1 ?v2)) ) (= (collect$a ?v0) (collect$a ?v1))) ))
(assert (forall ((?v0 State_rule_prod_tree_set$)) (= (collect$b (uu$ ?v0)) ?v0) ))
(assert (forall ((?v0 State_rule_prod_set$)) (= (collect$c (uua$ ?v0)) ?v0) ))
(assert (forall ((?v0 Rule_set$)) (= (collect$a (uub$ ?v0)) ?v0) ))
(assert (forall ((?v0 State_set$)) (= (collect$ (uuc$ ?v0)) ?v0) ))
(assert (forall ((?v0 State_rule_prod_tree$) (?v1 State_rule_prod_tree_bool_fun$)) (= (member$ ?v0 (collect$b ?v1)) (fun_app$ ?v1 ?v0)) ))
(assert (forall ((?v0 State_rule_prod$) (?v1 State_rule_prod_bool_fun$)) (= (member$a ?v0 (collect$c ?v1)) (fun_app$a ?v1 ?v0)) ))
(assert (forall ((?v0 Rule$) (?v1 Rule_bool_fun$)) (= (member$c ?v0 (collect$a ?v1)) (fun_app$c ?v1 ?v0)) ))
(assert (forall ((?v0 State$) (?v1 State_bool_fun$)) (= (member$b ?v0 (collect$ ?v1)) (fun_app$b ?v1 ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (not (= ?v0 ?v1)) (and (=> (fun_app$d (less$ ?v0) ?v1) false) (=> (fun_app$d (less$ ?v1) ?v0) false))) false) ))
(assert (forall ((?v0 Nat$)) (=> (fun_app$d (less$ ?v0) ?v0) false) ))
(assert (forall ((?v0 State_rule_prod_stream$)) (= (saturated$ eff$ rules$ ?v0) (forall ((?v1 Rule$)) (=> (member$c ?v1 (sset$ rules$)) (saturated$a eff$ ?v1 ?v0)) )) ))
(assert (forall ((?v0 State$) (?v1 Rule_stream$)) (=> (and (member$b ?v0 s$) (fair$ rules$ ?v1)) (fun_app$ (fun_app$s (wf$ eff$) rules$) (mkTree$ eff$ ?v1 ?v0))) ))
(assert (forall ((?v0 State$) (?v1 Rule_stream$) (?v2 State_rule_prod_stream$) (?v3 Nat$)) (=> (and (member$b ?v0 s$) (and (fair$ rules$ ?v1) (ipath$ (mkTree$ eff$ ?v1 ?v0) ?v2))) (exists ((?v4 Nat$) (?v5 State$)) (and (member$b ?v5 s$) (ipath$ (mkTree$ eff$ (sdrop$ ?v4 ?v1) ?v5) (sdrop$e ?v3 ?v2))) )) ))
(assert (forall ((?v0 State$) (?v1 Rule_stream$)) (=> (and (member$b ?v0 s$) (fair$ rules$ ?v1)) (exists ((?v2 Nat$)) (fun_app$b (fun_app$e (enabled$ eff$) (shd$ (sdrop$ ?v2 ?v1))) ?v0) )) ))
(assert (forall ((?v0 State$) (?v1 Rule_stream$)) (=> (and (member$b ?v0 s$) (fair$ rules$ ?v1)) (fun_app$b (fun_app$e (enabled$ eff$) (shd$ (trim$ eff$ ?v1 ?v0))) ?v0)) ))
(assert (forall ((?v0 State$) (?v1 Rule_stream$)) (=> (and (member$b ?v0 s$) (fair$ rules$ ?v1)) (member$c (shd$ (trim$ eff$ ?v1 ?v0)) (sset$ rules$))) ))
(assert (forall ((?v0 Rule_stream$) (?v1 Rule$)) (=> (and (fair$ rules$ ?v0) (member$c ?v1 (sset$ rules$))) (= (shd$ (sdrop$ (pos$ ?v0 ?v1) ?v0)) ?v1)) ))
(assert (forall ((?v0 State$) (?v1 Rule$) (?v2 State_fset$) (?v3 State$)) (=> (and (member$b ?v0 s$) (and (member$c ?v1 (sset$ rules$)) (and (fun_app$f (fun_app$g (fun_app$h eff$ ?v1) ?v0) ?v2) (fmember$ ?v3 ?v2)))) (member$b ?v3 s$)) ))
(assert (forall ((?v0 Nat$) (?v1 Rule_stream$) (?v2 State$)) (=> (fun_app$b (fun_app$e (enabled$ eff$) (shd$ (sdrop$ ?v0 ?v1))) ?v2) (fun_app$d (less_eq$ (minWait$ eff$ ?v1 ?v2)) ?v0)) ))
(assert (= (root$ (mkTree$ eff$ rsa$ sa$)) (shd$a stepsa$)))
(assert (forall ((?v0 Nat$) (?v1 Rule_rule_prod_stream$) (?v2 Rule_rule_prod$)) (=> (= (shd$b (sdrop$a ?v0 ?v1)) ?v2) (fun_app$d (less_eq$ (pos$a ?v1 ?v2)) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 State_state_rule_prod_prod_stream$) (?v2 State_state_rule_prod_prod$)) (=> (= (shd$c (sdrop$b ?v0 ?v1)) ?v2) (fun_app$d (less_eq$ (pos$b ?v1 ?v2)) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Rule_state_rule_prod_prod_stream$) (?v2 Rule_state_rule_prod_prod$)) (=> (= (shd$d (sdrop$c ?v0 ?v1)) ?v2) (fun_app$d (less_eq$ (pos$c ?v1 ?v2)) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 State_stream$) (?v2 State$)) (=> (= (shd$e (sdrop$d ?v0 ?v1)) ?v2) (fun_app$d (less_eq$ (pos$d ?v1 ?v2)) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 State_rule_prod_stream$) (?v2 State_rule_prod$)) (=> (= (shd$a (sdrop$e ?v0 ?v1)) ?v2) (fun_app$d (less_eq$ (pos$e ?v1 ?v2)) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Rule_stream$) (?v2 Rule$)) (=> (= (shd$ (sdrop$ ?v0 ?v1)) ?v2) (fun_app$d (less_eq$ (pos$ ?v1 ?v2)) ?v0)) ))
(assert (forall ((?v0 State_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 State$) (?v5 Rule_fset$) (?v6 Rule$)) (=> (and (ruleSystem$a ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$k (fun_app$l (fun_app$t ?v0 ?v4) ?v3) ?v5) (fmember$a ?v6 ?v5))))) (member$c ?v6 ?v2)) ))
(assert (forall ((?v0 State_state_state_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_set$) (?v3 State$) (?v4 State$) (?v5 State_fset$) (?v6 State$)) (=> (and (ruleSystem$b ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$f (fun_app$g (fun_app$u ?v0 ?v4) ?v3) ?v5) (fmember$ ?v6 ?v5))))) (member$b ?v6 ?v2)) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 Rule$) (?v5 Rule_fset$) (?v6 Rule$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$k (fun_app$l (fun_app$m ?v0 ?v4) ?v3) ?v5) (fmember$a ?v6 ?v5))))) (member$c ?v6 ?v2)) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 State$) (?v4 Rule$) (?v5 State_fset$) (?v6 State$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$f (fun_app$g (fun_app$h ?v0 ?v4) ?v3) ?v5) (fmember$ ?v6 ?v5))))) (member$b ?v6 ?v2)) ))
(assert (forall ((?v0 State_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_rule_prod_tree_set$) (?v3 State_rule_prod_tree$) (?v4 State$) (?v5 State_rule_prod_tree_fset$) (?v6 State_rule_prod_tree$)) (=> (and (ruleSystem$d ?v0 ?v1 ?v2) (and (member$ ?v3 ?v2) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$v (fun_app$w (fun_app$x ?v0 ?v4) ?v3) ?v5) (fmember$b ?v6 ?v5))))) (member$ ?v6 ?v2)) ))
(assert (forall ((?v0 Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_tree_set$) (?v3 State_rule_prod_tree$) (?v4 Rule$) (?v5 State_rule_prod_tree_fset$) (?v6 State_rule_prod_tree$)) (=> (and (ruleSystem$e ?v0 ?v1 ?v2) (and (member$ ?v3 ?v2) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$v (fun_app$w (fun_app$y ?v0 ?v4) ?v3) ?v5) (fmember$b ?v6 ?v5))))) (member$ ?v6 ?v2)) ))
(assert (forall ((?v0 Rule_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_set$) (?v3 State_rule_prod$) (?v4 Rule$) (?v5 State_rule_prod_fset$) (?v6 State_rule_prod$)) (=> (and (ruleSystem$f ?v0 ?v1 ?v2) (and (member$a ?v3 ?v2) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$z (fun_app$aa (fun_app$ab ?v0 ?v4) ?v3) ?v5) (fmember$c ?v6 ?v5))))) (member$a ?v6 ?v2)) ))
(assert (forall ((?v0 State_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_rule_prod_set$) (?v3 State_rule_prod$) (?v4 State$) (?v5 State_rule_prod_fset$) (?v6 State_rule_prod$)) (=> (and (ruleSystem$g ?v0 ?v1 ?v2) (and (member$a ?v3 ?v2) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$z (fun_app$aa (fun_app$ac ?v0 ?v4) ?v3) ?v5) (fmember$c ?v6 ?v5))))) (member$a ?v6 ?v2)) ))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_set$) (?v3 State$) (?v4 State_rule_prod$) (?v5 State_fset$) (?v6 State$)) (=> (and (ruleSystem$h ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (and (member$a ?v4 (sset$b ?v1)) (and (fun_app$f (fun_app$g (fun_app$o ?v0 ?v4) ?v3) ?v5) (fmember$ ?v6 ?v5))))) (member$b ?v6 ?v2)) ))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 State_rule_prod$) (?v5 Rule_fset$) (?v6 Rule$)) (=> (and (ruleSystem$i ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (and (member$a ?v4 (sset$b ?v1)) (and (fun_app$k (fun_app$l (fun_app$q ?v0 ?v4) ?v3) ?v5) (fmember$a ?v6 ?v5))))) (member$c ?v6 ?v2)) ))
(assert (forall ((?v0 Rule_set$) (?v1 State_stream$) (?v2 State_rule_rule_fset_bool_fun_fun_fun$)) (=> (and (forall ((?v3 Rule$) (?v4 State$) (?v5 Rule_fset$) (?v6 Rule$)) (=> (and (member$c ?v3 ?v0) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$k (fun_app$l (fun_app$t ?v2 ?v4) ?v3) ?v5) (fmember$a ?v6 ?v5)))) (member$c ?v6 ?v0)) ) (forall ((?v3 Rule$)) (=> (member$c ?v3 ?v0) (exists ((?v4 State$)) (and (member$b ?v4 (sset$a ?v1)) (exists ((?v5 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$t ?v2 ?v4) ?v3) ?v5) )) )) )) (ruleSystem$a ?v2 ?v1 ?v0)) ))
(assert (forall ((?v0 State_set$) (?v1 State_stream$) (?v2 State_state_state_fset_bool_fun_fun_fun$)) (=> (and (forall ((?v3 State$) (?v4 State$) (?v5 State_fset$) (?v6 State$)) (=> (and (member$b ?v3 ?v0) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$f (fun_app$g (fun_app$u ?v2 ?v4) ?v3) ?v5) (fmember$ ?v6 ?v5)))) (member$b ?v6 ?v0)) ) (forall ((?v3 State$)) (=> (member$b ?v3 ?v0) (exists ((?v4 State$)) (and (member$b ?v4 (sset$a ?v1)) (exists ((?v5 State_fset$)) (fun_app$f (fun_app$g (fun_app$u ?v2 ?v4) ?v3) ?v5) )) )) )) (ruleSystem$b ?v2 ?v1 ?v0)) ))
(assert (forall ((?v0 Rule_set$) (?v1 Rule_stream$) (?v2 Rule_rule_rule_fset_bool_fun_fun_fun$)) (=> (and (forall ((?v3 Rule$) (?v4 Rule$) (?v5 Rule_fset$) (?v6 Rule$)) (=> (and (member$c ?v3 ?v0) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$k (fun_app$l (fun_app$m ?v2 ?v4) ?v3) ?v5) (fmember$a ?v6 ?v5)))) (member$c ?v6 ?v0)) ) (forall ((?v3 Rule$)) (=> (member$c ?v3 ?v0) (exists ((?v4 Rule$)) (and (member$c ?v4 (sset$ ?v1)) (exists ((?v5 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$m ?v2 ?v4) ?v3) ?v5) )) )) )) (ruleSystem$c ?v2 ?v1 ?v0)) ))
(assert (forall ((?v0 State_set$) (?v1 Rule_stream$) (?v2 Rule_state_state_fset_bool_fun_fun_fun$)) (=> (and (forall ((?v3 State$) (?v4 Rule$) (?v5 State_fset$) (?v6 State$)) (=> (and (member$b ?v3 ?v0) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$f (fun_app$g (fun_app$h ?v2 ?v4) ?v3) ?v5) (fmember$ ?v6 ?v5)))) (member$b ?v6 ?v0)) ) (forall ((?v3 State$)) (=> (member$b ?v3 ?v0) (exists ((?v4 Rule$)) (and (member$c ?v4 (sset$ ?v1)) (exists ((?v5 State_fset$)) (fun_app$f (fun_app$g (fun_app$h ?v2 ?v4) ?v3) ?v5) )) )) )) (ruleSystem$ ?v2 ?v1 ?v0)) ))
(assert (forall ((?v0 State_rule_prod_tree_set$) (?v1 State_stream$) (?v2 State_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$)) (=> (and (forall ((?v3 State_rule_prod_tree$) (?v4 State$) (?v5 State_rule_prod_tree_fset$) (?v6 State_rule_prod_tree$)) (=> (and (member$ ?v3 ?v0) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$v (fun_app$w (fun_app$x ?v2 ?v4) ?v3) ?v5) (fmember$b ?v6 ?v5)))) (member$ ?v6 ?v0)) ) (forall ((?v3 State_rule_prod_tree$)) (=> (member$ ?v3 ?v0) (exists ((?v4 State$)) (and (member$b ?v4 (sset$a ?v1)) (exists ((?v5 State_rule_prod_tree_fset$)) (fun_app$v (fun_app$w (fun_app$x ?v2 ?v4) ?v3) ?v5) )) )) )) (ruleSystem$d ?v2 ?v1 ?v0)) ))
(assert (forall ((?v0 State_rule_prod_tree_set$) (?v1 Rule_stream$) (?v2 Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$)) (=> (and (forall ((?v3 State_rule_prod_tree$) (?v4 Rule$) (?v5 State_rule_prod_tree_fset$) (?v6 State_rule_prod_tree$)) (=> (and (member$ ?v3 ?v0) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$v (fun_app$w (fun_app$y ?v2 ?v4) ?v3) ?v5) (fmember$b ?v6 ?v5)))) (member$ ?v6 ?v0)) ) (forall ((?v3 State_rule_prod_tree$)) (=> (member$ ?v3 ?v0) (exists ((?v4 Rule$)) (and (member$c ?v4 (sset$ ?v1)) (exists ((?v5 State_rule_prod_tree_fset$)) (fun_app$v (fun_app$w (fun_app$y ?v2 ?v4) ?v3) ?v5) )) )) )) (ruleSystem$e ?v2 ?v1 ?v0)) ))
(assert (forall ((?v0 State_rule_prod_set$) (?v1 Rule_stream$) (?v2 Rule_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$)) (=> (and (forall ((?v3 State_rule_prod$) (?v4 Rule$) (?v5 State_rule_prod_fset$) (?v6 State_rule_prod$)) (=> (and (member$a ?v3 ?v0) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$z (fun_app$aa (fun_app$ab ?v2 ?v4) ?v3) ?v5) (fmember$c ?v6 ?v5)))) (member$a ?v6 ?v0)) ) (forall ((?v3 State_rule_prod$)) (=> (member$a ?v3 ?v0) (exists ((?v4 Rule$)) (and (member$c ?v4 (sset$ ?v1)) (exists ((?v5 State_rule_prod_fset$)) (fun_app$z (fun_app$aa (fun_app$ab ?v2 ?v4) ?v3) ?v5) )) )) )) (ruleSystem$f ?v2 ?v1 ?v0)) ))
(assert (forall ((?v0 State_rule_prod_set$) (?v1 State_stream$) (?v2 State_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$)) (=> (and (forall ((?v3 State_rule_prod$) (?v4 State$) (?v5 State_rule_prod_fset$) (?v6 State_rule_prod$)) (=> (and (member$a ?v3 ?v0) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$z (fun_app$aa (fun_app$ac ?v2 ?v4) ?v3) ?v5) (fmember$c ?v6 ?v5)))) (member$a ?v6 ?v0)) ) (forall ((?v3 State_rule_prod$)) (=> (member$a ?v3 ?v0) (exists ((?v4 State$)) (and (member$b ?v4 (sset$a ?v1)) (exists ((?v5 State_rule_prod_fset$)) (fun_app$z (fun_app$aa (fun_app$ac ?v2 ?v4) ?v3) ?v5) )) )) )) (ruleSystem$g ?v2 ?v1 ?v0)) ))
(assert (forall ((?v0 State_set$) (?v1 State_rule_prod_stream$) (?v2 State_rule_prod_state_state_fset_bool_fun_fun_fun$)) (=> (and (forall ((?v3 State$) (?v4 State_rule_prod$) (?v5 State_fset$) (?v6 State$)) (=> (and (member$b ?v3 ?v0) (and (member$a ?v4 (sset$b ?v1)) (and (fun_app$f (fun_app$g (fun_app$o ?v2 ?v4) ?v3) ?v5) (fmember$ ?v6 ?v5)))) (member$b ?v6 ?v0)) ) (forall ((?v3 State$)) (=> (member$b ?v3 ?v0) (exists ((?v4 State_rule_prod$)) (and (member$a ?v4 (sset$b ?v1)) (exists ((?v5 State_fset$)) (fun_app$f (fun_app$g (fun_app$o ?v2 ?v4) ?v3) ?v5) )) )) )) (ruleSystem$h ?v2 ?v1 ?v0)) ))
(assert (forall ((?v0 Rule_set$) (?v1 State_rule_prod_stream$) (?v2 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$)) (=> (and (forall ((?v3 Rule$) (?v4 State_rule_prod$) (?v5 Rule_fset$) (?v6 Rule$)) (=> (and (member$c ?v3 ?v0) (and (member$a ?v4 (sset$b ?v1)) (and (fun_app$k (fun_app$l (fun_app$q ?v2 ?v4) ?v3) ?v5) (fmember$a ?v6 ?v5)))) (member$c ?v6 ?v0)) ) (forall ((?v3 Rule$)) (=> (member$c ?v3 ?v0) (exists ((?v4 State_rule_prod$)) (and (member$a ?v4 (sset$b ?v1)) (exists ((?v5 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$q ?v2 ?v4) ?v3) ?v5) )) )) )) (ruleSystem$i ?v2 ?v1 ?v0)) ))
(assert (forall ((?v0 State_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 Rule_set$)) (= (ruleSystem$a ?v0 ?v1 ?v2) (and (forall ((?v3 Rule$) (?v4 State$) (?v5 Rule_fset$) (?v6 Rule$)) (=> (and (member$c ?v3 ?v2) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$k (fun_app$l (fun_app$t ?v0 ?v4) ?v3) ?v5) (fmember$a ?v6 ?v5)))) (member$c ?v6 ?v2)) ) (forall ((?v3 Rule$)) (=> (member$c ?v3 ?v2) (exists ((?v4 State$)) (and (member$b ?v4 (sset$a ?v1)) (exists ((?v5 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$t ?v0 ?v4) ?v3) ?v5) )) )) ))) ))
(assert (forall ((?v0 State_state_state_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_set$)) (= (ruleSystem$b ?v0 ?v1 ?v2) (and (forall ((?v3 State$) (?v4 State$) (?v5 State_fset$) (?v6 State$)) (=> (and (member$b ?v3 ?v2) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$f (fun_app$g (fun_app$u ?v0 ?v4) ?v3) ?v5) (fmember$ ?v6 ?v5)))) (member$b ?v6 ?v2)) ) (forall ((?v3 State$)) (=> (member$b ?v3 ?v2) (exists ((?v4 State$)) (and (member$b ?v4 (sset$a ?v1)) (exists ((?v5 State_fset$)) (fun_app$f (fun_app$g (fun_app$u ?v0 ?v4) ?v3) ?v5) )) )) ))) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$)) (= (ruleSystem$c ?v0 ?v1 ?v2) (and (forall ((?v3 Rule$) (?v4 Rule$) (?v5 Rule_fset$) (?v6 Rule$)) (=> (and (member$c ?v3 ?v2) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$k (fun_app$l (fun_app$m ?v0 ?v4) ?v3) ?v5) (fmember$a ?v6 ?v5)))) (member$c ?v6 ?v2)) ) (forall ((?v3 Rule$)) (=> (member$c ?v3 ?v2) (exists ((?v4 Rule$)) (and (member$c ?v4 (sset$ ?v1)) (exists ((?v5 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$m ?v0 ?v4) ?v3) ?v5) )) )) ))) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$)) (= (ruleSystem$ ?v0 ?v1 ?v2) (and (forall ((?v3 State$) (?v4 Rule$) (?v5 State_fset$) (?v6 State$)) (=> (and (member$b ?v3 ?v2) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$f (fun_app$g (fun_app$h ?v0 ?v4) ?v3) ?v5) (fmember$ ?v6 ?v5)))) (member$b ?v6 ?v2)) ) (forall ((?v3 State$)) (=> (member$b ?v3 ?v2) (exists ((?v4 Rule$)) (and (member$c ?v4 (sset$ ?v1)) (exists ((?v5 State_fset$)) (fun_app$f (fun_app$g (fun_app$h ?v0 ?v4) ?v3) ?v5) )) )) ))) ))
(assert (forall ((?v0 State_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_rule_prod_tree_set$)) (= (ruleSystem$d ?v0 ?v1 ?v2) (and (forall ((?v3 State_rule_prod_tree$) (?v4 State$) (?v5 State_rule_prod_tree_fset$) (?v6 State_rule_prod_tree$)) (=> (and (member$ ?v3 ?v2) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$v (fun_app$w (fun_app$x ?v0 ?v4) ?v3) ?v5) (fmember$b ?v6 ?v5)))) (member$ ?v6 ?v2)) ) (forall ((?v3 State_rule_prod_tree$)) (=> (member$ ?v3 ?v2) (exists ((?v4 State$)) (and (member$b ?v4 (sset$a ?v1)) (exists ((?v5 State_rule_prod_tree_fset$)) (fun_app$v (fun_app$w (fun_app$x ?v0 ?v4) ?v3) ?v5) )) )) ))) ))
(assert (forall ((?v0 Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_tree_set$)) (= (ruleSystem$e ?v0 ?v1 ?v2) (and (forall ((?v3 State_rule_prod_tree$) (?v4 Rule$) (?v5 State_rule_prod_tree_fset$) (?v6 State_rule_prod_tree$)) (=> (and (member$ ?v3 ?v2) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$v (fun_app$w (fun_app$y ?v0 ?v4) ?v3) ?v5) (fmember$b ?v6 ?v5)))) (member$ ?v6 ?v2)) ) (forall ((?v3 State_rule_prod_tree$)) (=> (member$ ?v3 ?v2) (exists ((?v4 Rule$)) (and (member$c ?v4 (sset$ ?v1)) (exists ((?v5 State_rule_prod_tree_fset$)) (fun_app$v (fun_app$w (fun_app$y ?v0 ?v4) ?v3) ?v5) )) )) ))) ))
(assert (forall ((?v0 Rule_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_set$)) (= (ruleSystem$f ?v0 ?v1 ?v2) (and (forall ((?v3 State_rule_prod$) (?v4 Rule$) (?v5 State_rule_prod_fset$) (?v6 State_rule_prod$)) (=> (and (member$a ?v3 ?v2) (and (member$c ?v4 (sset$ ?v1)) (and (fun_app$z (fun_app$aa (fun_app$ab ?v0 ?v4) ?v3) ?v5) (fmember$c ?v6 ?v5)))) (member$a ?v6 ?v2)) ) (forall ((?v3 State_rule_prod$)) (=> (member$a ?v3 ?v2) (exists ((?v4 Rule$)) (and (member$c ?v4 (sset$ ?v1)) (exists ((?v5 State_rule_prod_fset$)) (fun_app$z (fun_app$aa (fun_app$ab ?v0 ?v4) ?v3) ?v5) )) )) ))) ))
(assert (forall ((?v0 State_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_rule_prod_set$)) (= (ruleSystem$g ?v0 ?v1 ?v2) (and (forall ((?v3 State_rule_prod$) (?v4 State$) (?v5 State_rule_prod_fset$) (?v6 State_rule_prod$)) (=> (and (member$a ?v3 ?v2) (and (member$b ?v4 (sset$a ?v1)) (and (fun_app$z (fun_app$aa (fun_app$ac ?v0 ?v4) ?v3) ?v5) (fmember$c ?v6 ?v5)))) (member$a ?v6 ?v2)) ) (forall ((?v3 State_rule_prod$)) (=> (member$a ?v3 ?v2) (exists ((?v4 State$)) (and (member$b ?v4 (sset$a ?v1)) (exists ((?v5 State_rule_prod_fset$)) (fun_app$z (fun_app$aa (fun_app$ac ?v0 ?v4) ?v3) ?v5) )) )) ))) ))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_set$)) (= (ruleSystem$h ?v0 ?v1 ?v2) (and (forall ((?v3 State$) (?v4 State_rule_prod$) (?v5 State_fset$) (?v6 State$)) (=> (and (member$b ?v3 ?v2) (and (member$a ?v4 (sset$b ?v1)) (and (fun_app$f (fun_app$g (fun_app$o ?v0 ?v4) ?v3) ?v5) (fmember$ ?v6 ?v5)))) (member$b ?v6 ?v2)) ) (forall ((?v3 State$)) (=> (member$b ?v3 ?v2) (exists ((?v4 State_rule_prod$)) (and (member$a ?v4 (sset$b ?v1)) (exists ((?v5 State_fset$)) (fun_app$f (fun_app$g (fun_app$o ?v0 ?v4) ?v3) ?v5) )) )) ))) ))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 Rule_set$)) (= (ruleSystem$i ?v0 ?v1 ?v2) (and (forall ((?v3 Rule$) (?v4 State_rule_prod$) (?v5 Rule_fset$) (?v6 Rule$)) (=> (and (member$c ?v3 ?v2) (and (member$a ?v4 (sset$b ?v1)) (and (fun_app$k (fun_app$l (fun_app$q ?v0 ?v4) ?v3) ?v5) (fmember$a ?v6 ?v5)))) (member$c ?v6 ?v2)) ) (forall ((?v3 Rule$)) (=> (member$c ?v3 ?v2) (exists ((?v4 State_rule_prod$)) (and (member$a ?v4 (sset$b ?v1)) (exists ((?v5 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$q ?v0 ?v4) ?v3) ?v5) )) )) ))) ))
(assert (forall ((?v0 State_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 Rule_set$) (?v3 Rule$)) (=> (and (ruleSystem$a ?v0 ?v1 ?v2) (member$c ?v3 ?v2)) (exists ((?v4 State$)) (and (member$b ?v4 (sset$a ?v1)) (exists ((?v5 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$t ?v0 ?v4) ?v3) ?v5) )) )) ))
(assert (forall ((?v0 State_state_state_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_set$) (?v3 State$)) (=> (and (ruleSystem$b ?v0 ?v1 ?v2) (member$b ?v3 ?v2)) (exists ((?v4 State$)) (and (member$b ?v4 (sset$a ?v1)) (exists ((?v5 State_fset$)) (fun_app$f (fun_app$g (fun_app$u ?v0 ?v4) ?v3) ?v5) )) )) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Rule$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (member$c ?v3 ?v2)) (exists ((?v4 Rule$)) (and (member$c ?v4 (sset$ ?v1)) (exists ((?v5 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$m ?v0 ?v4) ?v3) ?v5) )) )) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 State$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (member$b ?v3 ?v2)) (exists ((?v4 Rule$)) (and (member$c ?v4 (sset$ ?v1)) (exists ((?v5 State_fset$)) (fun_app$f (fun_app$g (fun_app$h ?v0 ?v4) ?v3) ?v5) )) )) ))
(assert (forall ((?v0 Rule_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_set$) (?v3 State_rule_prod$)) (=> (and (ruleSystem$f ?v0 ?v1 ?v2) (member$a ?v3 ?v2)) (exists ((?v4 Rule$)) (and (member$c ?v4 (sset$ ?v1)) (exists ((?v5 State_rule_prod_fset$)) (fun_app$z (fun_app$aa (fun_app$ab ?v0 ?v4) ?v3) ?v5) )) )) ))
(assert (forall ((?v0 State_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_rule_prod_set$) (?v3 State_rule_prod$)) (=> (and (ruleSystem$g ?v0 ?v1 ?v2) (member$a ?v3 ?v2)) (exists ((?v4 State$)) (and (member$b ?v4 (sset$a ?v1)) (exists ((?v5 State_rule_prod_fset$)) (fun_app$z (fun_app$aa (fun_app$ac ?v0 ?v4) ?v3) ?v5) )) )) ))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 Rule_set$) (?v3 Rule$)) (=> (and (ruleSystem$i ?v0 ?v1 ?v2) (member$c ?v3 ?v2)) (exists ((?v4 State_rule_prod$)) (and (member$a ?v4 (sset$b ?v1)) (exists ((?v5 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$q ?v0 ?v4) ?v3) ?v5) )) )) ))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_set$) (?v3 State$)) (=> (and (ruleSystem$h ?v0 ?v1 ?v2) (member$b ?v3 ?v2)) (exists ((?v4 State_rule_prod$)) (and (member$a ?v4 (sset$b ?v1)) (exists ((?v5 State_fset$)) (fun_app$f (fun_app$g (fun_app$o ?v0 ?v4) ?v3) ?v5) )) )) ))
(assert (forall ((?v0 State_rule_prod_tree_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_tree_stream$) (?v2 Rule_set$) (?v3 Rule$)) (=> (and (ruleSystem$j ?v0 ?v1 ?v2) (member$c ?v3 ?v2)) (exists ((?v4 State_rule_prod_tree$)) (and (member$ ?v4 (sset$c ?v1)) (exists ((?v5 Rule_fset$)) (fun_app$k (fun_app$l (fun_app$ad ?v0 ?v4) ?v3) ?v5) )) )) ))
(assert (forall ((?v0 State_rule_prod_tree_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_tree_stream$) (?v2 State_set$) (?v3 State$)) (=> (and (ruleSystem$k ?v0 ?v1 ?v2) (member$b ?v3 ?v2)) (exists ((?v4 State_rule_prod_tree$)) (and (member$ ?v4 (sset$c ?v1)) (exists ((?v5 State_fset$)) (fun_app$f (fun_app$g (fun_app$ae ?v0 ?v4) ?v3) ?v5) )) )) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 Rule_stream$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$ ?v1 ?v4))) (wf$a ?v0 ?v1 (mkTree$a ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 State$) (?v4 Rule_stream$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$ ?v1 ?v4))) (fun_app$ (fun_app$s (wf$ ?v0) ?v1) (mkTree$ ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 State_state_state_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_set$) (?v3 State$) (?v4 State_stream$)) (=> (and (ruleSystem$b ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$d ?v1 ?v4))) (wf$b ?v0 ?v1 (mkTree$b ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 State_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 State_stream$)) (=> (and (ruleSystem$a ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$d ?v1 ?v4))) (wf$c ?v0 ?v1 (mkTree$c ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 Rule_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_set$) (?v3 State_rule_prod$) (?v4 Rule_stream$)) (=> (and (ruleSystem$f ?v0 ?v1 ?v2) (and (member$a ?v3 ?v2) (fair$ ?v1 ?v4))) (wf$d ?v0 ?v1 (mkTree$d ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 State_state_rule_prod_state_rule_prod_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_rule_prod_set$) (?v3 State_rule_prod$) (?v4 State_stream$)) (=> (and (ruleSystem$g ?v0 ?v1 ?v2) (and (member$a ?v3 ?v2) (fair$d ?v1 ?v4))) (wf$e ?v0 ?v1 (mkTree$e ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_set$) (?v3 State$) (?v4 State_rule_prod_stream$)) (=> (and (ruleSystem$h ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$e ?v1 ?v4))) (wf$f ?v0 ?v1 (mkTree$f ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 State_rule_prod_stream$)) (=> (and (ruleSystem$i ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$e ?v1 ?v4))) (wf$g ?v0 ?v1 (mkTree$g ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 State_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_rule_prod_tree_set$) (?v3 State_rule_prod_tree$) (?v4 State_stream$)) (=> (and (ruleSystem$d ?v0 ?v1 ?v2) (and (member$ ?v3 ?v2) (fair$d ?v1 ?v4))) (wf$h ?v0 ?v1 (mkTree$h ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_tree_set$) (?v3 State_rule_prod_tree$) (?v4 Rule_stream$)) (=> (and (ruleSystem$e ?v0 ?v1 ?v2) (and (member$ ?v3 ?v2) (fair$ ?v1 ?v4))) (wf$i ?v0 ?v1 (mkTree$i ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 Nat$) (?v4 Rule_stream$) (?v5 Rule$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (= (shd$ (sdrop$ ?v3 ?v4)) ?v5)) (fun_app$d (less_eq$ (pos$ ?v4 ?v5)) ?v3)) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 Nat$) (?v4 State_rule_prod_stream$) (?v5 State_rule_prod$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (= (shd$a (sdrop$e ?v3 ?v4)) ?v5)) (fun_app$d (less_eq$ (pos$e ?v4 ?v5)) ?v3)) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 Nat$) (?v4 State_stream$) (?v5 State$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (= (shd$e (sdrop$d ?v3 ?v4)) ?v5)) (fun_app$d (less_eq$ (pos$d ?v4 ?v5)) ?v3)) ))
(assert (forall ((?v0 State_state_state_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_set$) (?v3 Nat$) (?v4 State_stream$) (?v5 State$)) (=> (and (ruleSystem$b ?v0 ?v1 ?v2) (= (shd$e (sdrop$d ?v3 ?v4)) ?v5)) (fun_app$d (less_eq$ (pos$d ?v4 ?v5)) ?v3)) ))
(assert (forall ((?v0 State_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 Rule_set$) (?v3 Nat$) (?v4 State_stream$) (?v5 State$)) (=> (and (ruleSystem$a ?v0 ?v1 ?v2) (= (shd$e (sdrop$d ?v3 ?v4)) ?v5)) (fun_app$d (less_eq$ (pos$d ?v4 ?v5)) ?v3)) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Nat$) (?v4 State_stream$) (?v5 State$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (= (shd$e (sdrop$d ?v3 ?v4)) ?v5)) (fun_app$d (less_eq$ (pos$d ?v4 ?v5)) ?v3)) ))
(assert (forall ((?v0 State_state_state_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_set$) (?v3 Nat$) (?v4 Rule_stream$) (?v5 Rule$)) (=> (and (ruleSystem$b ?v0 ?v1 ?v2) (= (shd$ (sdrop$ ?v3 ?v4)) ?v5)) (fun_app$d (less_eq$ (pos$ ?v4 ?v5)) ?v3)) ))
(assert (forall ((?v0 State_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 Rule_set$) (?v3 Nat$) (?v4 Rule_stream$) (?v5 Rule$)) (=> (and (ruleSystem$a ?v0 ?v1 ?v2) (= (shd$ (sdrop$ ?v3 ?v4)) ?v5)) (fun_app$d (less_eq$ (pos$ ?v4 ?v5)) ?v3)) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Nat$) (?v4 Rule_stream$) (?v5 Rule$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (= (shd$ (sdrop$ ?v3 ?v4)) ?v5)) (fun_app$d (less_eq$ (pos$ ?v4 ?v5)) ?v3)) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 Nat$) (?v4 Rule_rule_prod_stream$) (?v5 Rule_rule_prod$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (= (shd$b (sdrop$a ?v3 ?v4)) ?v5)) (fun_app$d (less_eq$ (pos$a ?v4 ?v5)) ?v3)) ))
(assert (forall ((?v0 State_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_rule_prod_tree_set$) (?v3 State_rule_prod_tree$) (?v4 State_stream$)) (=> (and (ruleSystem$d ?v0 ?v1 ?v2) (and (member$ ?v3 ?v2) (fair$d ?v1 ?v4))) (member$b (shd$e (trim$a ?v0 ?v4 ?v3)) (sset$a ?v1))) ))
(assert (forall ((?v0 Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_tree_set$) (?v3 State_rule_prod_tree$) (?v4 Rule_stream$)) (=> (and (ruleSystem$e ?v0 ?v1 ?v2) (and (member$ ?v3 ?v2) (fair$ ?v1 ?v4))) (member$c (shd$ (trim$b ?v0 ?v4 ?v3)) (sset$ ?v1))) ))
(assert (forall ((?v0 State_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 State_stream$)) (=> (and (ruleSystem$a ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$d ?v1 ?v4))) (member$b (shd$e (trim$c ?v0 ?v4 ?v3)) (sset$a ?v1))) ))
(assert (forall ((?v0 State_state_state_fset_bool_fun_fun_fun$) (?v1 State_stream$) (?v2 State_set$) (?v3 State$) (?v4 State_stream$)) (=> (and (ruleSystem$b ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$d ?v1 ?v4))) (member$b (shd$e (trim$d ?v0 ?v4 ?v3)) (sset$a ?v1))) ))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 State_rule_prod_stream$)) (=> (and (ruleSystem$i ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$e ?v1 ?v4))) (member$a (shd$a (trim$e ?v0 ?v4 ?v3)) (sset$b ?v1))) ))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_set$) (?v3 State$) (?v4 State_rule_prod_stream$)) (=> (and (ruleSystem$h ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$e ?v1 ?v4))) (member$a (shd$a (trim$f ?v0 ?v4 ?v3)) (sset$b ?v1))) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 Rule_stream$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$ ?v1 ?v4))) (member$c (shd$ (trim$g ?v0 ?v4 ?v3)) (sset$ ?v1))) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 State$) (?v4 Rule_stream$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$ ?v1 ?v4))) (member$c (shd$ (trim$ ?v0 ?v4 ?v3)) (sset$ ?v1))) ))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 State_rule_prod_stream$)) (=> (and (ruleSystem$i ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$e ?v1 ?v4))) (exists ((?v5 Nat$)) (fun_app$c (fun_app$p (enabled$c ?v0) (shd$a (sdrop$e ?v5 ?v4))) ?v3) )) ))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_set$) (?v3 State$) (?v4 State_rule_prod_stream$)) (=> (and (ruleSystem$h ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$e ?v1 ?v4))) (exists ((?v5 Nat$)) (fun_app$b (fun_app$n (enabled$b ?v0) (shd$a (sdrop$e ?v5 ?v4))) ?v3) )) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 Rule_stream$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$ ?v1 ?v4))) (exists ((?v5 Nat$)) (fun_app$c (fun_app$j (enabled$a ?v0) (shd$ (sdrop$ ?v5 ?v4))) ?v3) )) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 State$) (?v4 Rule_stream$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$ ?v1 ?v4))) (exists ((?v5 Nat$)) (fun_app$b (fun_app$e (enabled$ ?v0) (shd$ (sdrop$ ?v5 ?v4))) ?v3) )) ))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 State_rule_prod_stream$)) (=> (and (ruleSystem$i ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$e ?v1 ?v4))) (fun_app$c (fun_app$p (enabled$c ?v0) (shd$a (trim$e ?v0 ?v4 ?v3))) ?v3)) ))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_set$) (?v3 State$) (?v4 State_rule_prod_stream$)) (=> (and (ruleSystem$h ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$e ?v1 ?v4))) (fun_app$b (fun_app$n (enabled$b ?v0) (shd$a (trim$f ?v0 ?v4 ?v3))) ?v3)) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 Rule_stream$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$ ?v1 ?v4))) (fun_app$c (fun_app$j (enabled$a ?v0) (shd$ (trim$g ?v0 ?v4 ?v3))) ?v3)) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 State$) (?v4 Rule_stream$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$ ?v1 ?v4))) (fun_app$b (fun_app$e (enabled$ ?v0) (shd$ (trim$ ?v0 ?v4 ?v3))) ?v3)) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 Rule_stream$) (?v4 Rule$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (and (fair$ ?v1 ?v3) (member$c ?v4 (sset$ ?v1)))) (= (shd$ (sdrop$ (pos$ ?v3 ?v4) ?v3)) ?v4)) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 Nat$) (?v4 Rule_stream$) (?v5 State$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (fun_app$b (fun_app$e (enabled$ ?v0) (shd$ (sdrop$ ?v3 ?v4))) ?v5)) (fun_app$d (less_eq$ (minWait$ ?v0 ?v4 ?v5)) ?v3)) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_stream$)) (= (saturated$ ?v0 ?v1 ?v2) (forall ((?v3 Rule$)) (=> (member$c ?v3 (sset$ ?v1)) (saturated$a ?v0 ?v3 ?v2)) )) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 Rule_stream$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$ ?v1 ?v4))) (fair$ ?v1 (trim$g ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 State$) (?v4 Rule_stream$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$ ?v1 ?v4))) (fair$ ?v1 (trim$ ?v0 ?v4 ?v3))) ))
(assert (forall ((?v0 Rule_stream$)) (= (sset$ (fenum$ ?v0)) (sset$ ?v0)) ))
(assert (forall ((?v0 Rule_stream$)) (fair$ ?v0 (fenum$ ?v0)) ))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 State_rule_prod_stream$)) (=> (and (ruleSystem$i ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$e ?v1 ?v4))) (= (trim$e ?v0 ?v4 ?v3) (sdrop$e (minWait$a ?v0 ?v4 ?v3) ?v4))) ))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_set$) (?v3 State$) (?v4 State_rule_prod_stream$)) (=> (and (ruleSystem$h ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$e ?v1 ?v4))) (= (trim$f ?v0 ?v4 ?v3) (sdrop$e (minWait$b ?v0 ?v4 ?v3) ?v4))) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 Rule_stream$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (fair$ ?v1 ?v4))) (= (trim$g ?v0 ?v4 ?v3) (sdrop$ (minWait$c ?v0 ?v4 ?v3) ?v4))) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 State$) (?v4 Rule_stream$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (fair$ ?v1 ?v4))) (= (trim$ ?v0 ?v4 ?v3) (sdrop$ (minWait$ ?v0 ?v4 ?v3) ?v4))) ))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 State_rule_prod_stream$) (?v5 Rule_state_rule_prod_prod_stream$) (?v6 Nat$)) (=> (and (ruleSystem$i ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (and (fair$e ?v1 ?v4) (ipath$a (mkTree$g ?v0 ?v4 ?v3) ?v5)))) (exists ((?v7 Nat$) (?v8 Rule$)) (and (member$c ?v8 ?v2) (ipath$a (mkTree$g ?v0 (sdrop$e ?v7 ?v4) ?v8) (sdrop$c ?v6 ?v5))) )) ))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_set$) (?v3 State$) (?v4 State_rule_prod_stream$) (?v5 State_state_rule_prod_prod_stream$) (?v6 Nat$)) (=> (and (ruleSystem$h ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (and (fair$e ?v1 ?v4) (ipath$b (mkTree$f ?v0 ?v4 ?v3) ?v5)))) (exists ((?v7 Nat$) (?v8 State$)) (and (member$b ?v8 ?v2) (ipath$b (mkTree$f ?v0 (sdrop$e ?v7 ?v4) ?v8) (sdrop$b ?v6 ?v5))) )) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 Rule_stream$) (?v5 Rule_rule_prod_stream$) (?v6 Nat$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (and (fair$ ?v1 ?v4) (ipath$c (mkTree$a ?v0 ?v4 ?v3) ?v5)))) (exists ((?v7 Nat$) (?v8 Rule$)) (and (member$c ?v8 ?v2) (ipath$c (mkTree$a ?v0 (sdrop$ ?v7 ?v4) ?v8) (sdrop$a ?v6 ?v5))) )) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 State$) (?v4 Rule_stream$) (?v5 State_rule_prod_stream$) (?v6 Nat$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (and (fair$ ?v1 ?v4) (ipath$ (mkTree$ ?v0 ?v4 ?v3) ?v5)))) (exists ((?v7 Nat$) (?v8 State$)) (and (member$b ?v8 ?v2) (ipath$ (mkTree$ ?v0 (sdrop$ ?v7 ?v4) ?v8) (sdrop$e ?v6 ?v5))) )) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 Rule_stream$) (?v4 Rule$) (?v5 State$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (and (fair$ ?v1 ?v3) (and (member$c ?v4 (sset$ ?v1)) (fun_app$b (fun_app$e (enabled$ ?v0) ?v4) ?v5)))) (fun_app$d (less_eq$ (minWait$ ?v0 ?v3 ?v5)) (pos$ ?v3 ?v4))) ))
(assert (forall ((?v0 State_rule_prod_tree$) (?v1 State_rule_prod_stream$)) (=> (and (fun_app$ (fun_app$s (wf$ eff$) rules$) ?v0) (ipath$ ?v0 ?v1)) (epath$ eff$ rules$ ?v1)) ))
(assert (forall ((?v0 Rule_stream$) (?v1 State$)) (= (root$ (mkTree$ eff$ ?v0 ?v1)) (pair$ ?v1 (shd$ (trim$ eff$ ?v0 ?v1)))) ))
(assert (ipath$ (mkTree$ eff$ (stl$ (trim$ eff$ rsa$ sa$)) s$a) (stl$a stepsa$)))
(assert (=> (forall ((?v0 State_rule_prod_tree$) (?v1 State$)) (=> (and (= (root$ (mkTree$ eff$ rsa$ sa$)) (shd$a stepsa$)) (and (ipath$ (mkTree$ eff$ (stl$ (trim$ eff$ rsa$ sa$)) ?v1) (stl$a stepsa$)) (member$b ?v1 s$))) false) ) false))
(assert (not (= (sset$ rules$) bot$)))
(assert (forall ((?v0 Nat$)) (fun_app$d (less_eq$ ?v0) ?v0) ))
(assert (forall ((?v0 State_stream$)) (member$b (shd$e ?v0) (sset$a ?v0)) ))
(assert (forall ((?v0 State_rule_prod_stream$)) (member$a (shd$a ?v0) (sset$b ?v0)) ))
(assert (forall ((?v0 Rule_stream$)) (member$c (shd$ ?v0) (sset$ ?v0)) ))
(assert (forall ((?v0 Rule_stream$)) (=> (fair$ rules$ ?v0) (fair$ rules$ (stl$ ?v0))) ))
(assert (forall ((?v0 Rule_stream_rule_stream_bool_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_stream$)) (=> (and (fun_app$af (fun_app$ag ?v0 ?v1) ?v2) (forall ((?v3 Rule_stream$) (?v4 Rule_stream$)) (=> (fun_app$af (fun_app$ag ?v0 ?v3) ?v4) (and (= (shd$ ?v3) (shd$ ?v4)) (fun_app$af (fun_app$ag ?v0 (stl$ ?v3)) (stl$ ?v4)))) )) (= ?v1 ?v2)) ))
(assert (forall ((?v0 State_rule_prod_stream_state_rule_prod_stream_bool_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_rule_prod_stream$)) (=> (and (fun_app$ah (fun_app$ai ?v0 ?v1) ?v2) (forall ((?v3 State_rule_prod_stream$) (?v4 State_rule_prod_stream$)) (=> (fun_app$ah (fun_app$ai ?v0 ?v3) ?v4) (and (= (shd$a ?v3) (shd$a ?v4)) (fun_app$ah (fun_app$ai ?v0 (stl$a ?v3)) (stl$a ?v4)))) )) (= ?v1 ?v2)) ))
(assert (forall ((?v0 Rule_stream_rule_stream_bool_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_stream$)) (=> (and (fun_app$af (fun_app$ag ?v0 ?v1) ?v2) (forall ((?v3 Rule_stream$) (?v4 Rule_stream$)) (=> (fun_app$af (fun_app$ag ?v0 ?v3) ?v4) (and (= (shd$ ?v3) (shd$ ?v4)) (or (fun_app$af (fun_app$ag ?v0 (stl$ ?v3)) (stl$ ?v4)) (= (stl$ ?v3) (stl$ ?v4))))) )) (= ?v1 ?v2)) ))
(assert (forall ((?v0 State_rule_prod_stream_state_rule_prod_stream_bool_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_rule_prod_stream$)) (=> (and (fun_app$ah (fun_app$ai ?v0 ?v1) ?v2) (forall ((?v3 State_rule_prod_stream$) (?v4 State_rule_prod_stream$)) (=> (fun_app$ah (fun_app$ai ?v0 ?v3) ?v4) (and (= (shd$a ?v3) (shd$a ?v4)) (or (fun_app$ah (fun_app$ai ?v0 (stl$a ?v3)) (stl$a ?v4)) (= (stl$a ?v3) (stl$a ?v4))))) )) (= ?v1 ?v2)) ))
(assert (forall ((?v0 Rule_stream$) (?v1 Rule_stream$)) (=> (and (= (shd$ ?v0) (shd$ ?v1)) (= (stl$ ?v0) (stl$ ?v1))) (= ?v0 ?v1)) ))
(assert (forall ((?v0 State_rule_prod_stream$) (?v1 State_rule_prod_stream$)) (=> (and (= (shd$a ?v0) (shd$a ?v1)) (= (stl$a ?v0) (stl$a ?v1))) (= ?v0 ?v1)) ))
(assert (forall ((?v0 Rule_set$)) (less_eq$a bot$ ?v0) ))
(assert (forall ((?v0 Nat$)) (fun_app$d (less_eq$ bot$a) ?v0) ))
(assert (forall ((?v0 Rule_set$)) (=> (less_eq$a ?v0 bot$) (= ?v0 bot$)) ))
(assert (forall ((?v0 Nat$)) (=> (fun_app$d (less_eq$ ?v0) bot$a) (= ?v0 bot$a)) ))
(assert (forall ((?v0 Rule_set$)) (= (less_eq$a ?v0 bot$) (= ?v0 bot$)) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$d (less_eq$ ?v0) bot$a) (= ?v0 bot$a)) ))
(assert (forall ((?v0 Rule_set$)) (= (not (= ?v0 bot$)) (less$a bot$ ?v0)) ))
(assert (forall ((?v0 Nat$)) (= (not (= ?v0 bot$a)) (fun_app$d (less$ bot$a) ?v0)) ))
(assert (forall ((?v0 Rule_set$)) (not (less$a ?v0 bot$)) ))
(assert (forall ((?v0 Nat$)) (not (fun_app$d (less$ ?v0) bot$a)) ))
(assert (forall ((?v0 State$) (?v1 State_stream$)) (=> (member$b ?v0 (sset$a (stl$e ?v1))) (member$b ?v0 (sset$a ?v1))) ))
(assert (forall ((?v0 State_rule_prod$) (?v1 State_rule_prod_stream$)) (=> (member$a ?v0 (sset$b (stl$a ?v1))) (member$a ?v0 (sset$b ?v1))) ))
(assert (forall ((?v0 Rule$) (?v1 Rule_stream$)) (=> (member$c ?v0 (sset$ (stl$ ?v1))) (member$c ?v0 (sset$ ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Rule_stream$)) (= (sdrop$ ?v0 (stl$ ?v1)) (stl$ (sdrop$ ?v0 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 State_rule_prod_stream$)) (= (sdrop$e ?v0 (stl$a ?v1)) (stl$a (sdrop$e ?v0 ?v1))) ))
(assert (forall ((?v0 State_rule_prod_stream$) (?v1 State_rule_prod_stream$)) (=> (fair$e ?v0 ?v1) (fair$e ?v0 (stl$a ?v1))) ))
(assert (forall ((?v0 Rule_stream$) (?v1 Rule_stream$)) (=> (fair$ ?v0 ?v1) (fair$ ?v0 (stl$ ?v1))) ))
(assert (forall ((?v0 Rule_stream$)) (not (= (sset$ ?v0) bot$)) ))
(assert (forall ((?v0 State$) (?v1 State_stream$) (?v2 State_state_stream_bool_fun_fun$)) (=> (and (member$b ?v0 (sset$a ?v1)) (and (forall ((?v3 State_stream$)) (fun_app$aj (fun_app$ak ?v2 (shd$e ?v3)) ?v3) ) (forall ((?v3 State_stream$) (?v4 State$)) (=> (and (member$b ?v4 (sset$a (stl$e ?v3))) (fun_app$aj (fun_app$ak ?v2 ?v4) (stl$e ?v3))) (fun_app$aj (fun_app$ak ?v2 ?v4) ?v3)) ))) (fun_app$aj (fun_app$ak ?v2 ?v0) ?v1)) ))
(assert (forall ((?v0 State_rule_prod$) (?v1 State_rule_prod_stream$) (?v2 State_rule_prod_state_rule_prod_stream_bool_fun_fun$)) (=> (and (member$a ?v0 (sset$b ?v1)) (and (forall ((?v3 State_rule_prod_stream$)) (fun_app$ah (fun_app$al ?v2 (shd$a ?v3)) ?v3) ) (forall ((?v3 State_rule_prod_stream$) (?v4 State_rule_prod$)) (=> (and (member$a ?v4 (sset$b (stl$a ?v3))) (fun_app$ah (fun_app$al ?v2 ?v4) (stl$a ?v3))) (fun_app$ah (fun_app$al ?v2 ?v4) ?v3)) ))) (fun_app$ah (fun_app$al ?v2 ?v0) ?v1)) ))
(assert (forall ((?v0 Rule$) (?v1 Rule_stream$) (?v2 Rule_rule_stream_bool_fun_fun$)) (=> (and (member$c ?v0 (sset$ ?v1)) (and (forall ((?v3 Rule_stream$)) (fun_app$af (fun_app$am ?v2 (shd$ ?v3)) ?v3) ) (forall ((?v3 Rule_stream$) (?v4 Rule$)) (=> (and (member$c ?v4 (sset$ (stl$ ?v3))) (fun_app$af (fun_app$am ?v2 ?v4) (stl$ ?v3))) (fun_app$af (fun_app$am ?v2 ?v4) ?v3)) ))) (fun_app$af (fun_app$am ?v2 ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (= ?v0 ?v1) (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (=> (fun_app$d (less_eq$ ?v0) ?v1) false) (=> (fun_app$d (less_eq$ ?v1) ?v0) false)) false) ))
(assert (forall ((?v0 Nat_nat_bool_fun_fun$) (?v1 Nat$) (?v2 Nat$)) (=> (and (forall ((?v3 Nat$) (?v4 Nat$)) (=> (fun_app$d (less_eq$ ?v3) ?v4) (fun_app$d (fun_app$i ?v0 ?v3) ?v4)) ) (forall ((?v3 Nat$) (?v4 Nat$)) (=> (fun_app$d (fun_app$i ?v0 ?v4) ?v3) (fun_app$d (fun_app$i ?v0 ?v3) ?v4)) )) (fun_app$d (fun_app$i ?v0 ?v1) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_nat_fun$) (?v2 Nat$) (?v3 Nat$)) (=> (and (= ?v0 (fun_app$r ?v1 ?v2)) (and (fun_app$d (less_eq$ ?v2) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less_eq$ ?v4) ?v5) (fun_app$d (less_eq$ (fun_app$r ?v1 ?v4)) (fun_app$r ?v1 ?v5))) ))) (fun_app$d (less_eq$ ?v0) (fun_app$r ?v1 ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (= ?v0 ?v1) (fun_app$d (less_eq$ ?v1) ?v2)) (fun_app$d (less_eq$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (= ?v0 ?v1) (fun_app$d (less_eq$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_fun$) (?v3 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (and (= (fun_app$r ?v2 ?v1) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less_eq$ ?v4) ?v5) (fun_app$d (less_eq$ (fun_app$r ?v2 ?v4)) (fun_app$r ?v2 ?v5))) ))) (fun_app$d (less_eq$ (fun_app$r ?v2 ?v0)) ?v3)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (= ?v1 ?v2)) (fun_app$d (less_eq$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_fun$) (?v3 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (and (fun_app$d (less_eq$ (fun_app$r ?v2 ?v1)) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less_eq$ ?v4) ?v5) (fun_app$d (less_eq$ (fun_app$r ?v2 ?v4)) (fun_app$r ?v2 ?v5))) ))) (fun_app$d (less_eq$ (fun_app$r ?v2 ?v0)) ?v3)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_nat_fun$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) (fun_app$r ?v1 ?v2)) (and (fun_app$d (less_eq$ ?v2) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less_eq$ ?v4) ?v5) (fun_app$d (less_eq$ (fun_app$r ?v1 ?v4)) (fun_app$r ?v1 ?v5))) ))) (fun_app$d (less_eq$ ?v0) (fun_app$r ?v1 ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v0)) (= ?v1 ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v0)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v0)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less_eq$ ?v2) ?v0)) (fun_app$d (less_eq$ ?v2) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v2)) (fun_app$d (less_eq$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v2)) (fun_app$d (less_eq$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (=> (fun_app$d (less_eq$ ?v0) ?v1) (= (fun_app$d (less_eq$ ?v1) ?v0) (= ?v1 ?v0))) :pattern ((fun_app$d (less_eq$ ?v1) ?v0)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (or (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v0)) ))
(assert (forall ((?v0 Nat$)) (fun_app$d (less_eq$ ?v0) ?v0) ))
(assert (forall ((?v0 Nat$)) (not (fun_app$d (less$ ?v0) ?v0)) ))
(assert (forall ((?v0 Nat$)) (not (fun_app$d (less$ ?v0) ?v0)) ))
(assert (forall ((?v0 Nat$)) (exists ((?v1 Nat$)) (fun_app$d (less$ ?v0) ?v1) ) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (or (fun_app$d (less$ ?v0) ?v1) (or (= ?v0 ?v1) (fun_app$d (less$ ?v1) ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (not (fun_app$d (less$ ?v0) ?v1)) (= (not (fun_app$d (less$ ?v1) ?v0)) (= ?v1 ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (not (= ?v0 ?v1)) (and (=> (fun_app$d (less$ ?v0) ?v1) false) (=> (fun_app$d (less$ ?v1) ?v0) false))) false) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (not (fun_app$d (less$ ?v1) ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (not (= ?v0 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (not (= ?v0 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (not (= ?v1 ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (= (not (fun_app$d (less$ ?v1) ?v0)) true)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Bool)) (=> (fun_app$d (less$ ?v0) ?v1) (= (=> (fun_app$d (less$ ?v1) ?v0) ?v2) true)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (= (= ?v0 ?v1) false)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (= (= ?v1 ?v0) false)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less$ ?v1) ?v0)) false) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less$ ?v1) ?v0)) false) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less$ ?v1) ?v0)) false) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less$ ?v1) ?v2)) (fun_app$d (less$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less$ ?v1) ?v2)) (fun_app$d (less$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less$ ?v2) ?v0)) (fun_app$d (less$ ?v2) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_nat_fun$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$d (less$ ?v0) (fun_app$r ?v1 ?v2)) (and (fun_app$d (less$ ?v2) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less$ ?v4) ?v5) (fun_app$d (less$ (fun_app$r ?v1 ?v4)) (fun_app$r ?v1 ?v5))) ))) (fun_app$d (less$ ?v0) (fun_app$r ?v1 ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_fun$) (?v3 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (and (fun_app$d (less$ (fun_app$r ?v2 ?v1)) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less$ ?v4) ?v5) (fun_app$d (less$ (fun_app$r ?v2 ?v4)) (fun_app$r ?v2 ?v5))) ))) (fun_app$d (less$ (fun_app$r ?v2 ?v0)) ?v3)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (= ?v1 ?v2)) (fun_app$d (less$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_fun$) (?v3 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (and (= (fun_app$r ?v2 ?v1) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less$ ?v4) ?v5) (fun_app$d (less$ (fun_app$r ?v2 ?v4)) (fun_app$r ?v2 ?v5))) ))) (fun_app$d (less$ (fun_app$r ?v2 ?v0)) ?v3)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (=> (not false) (fun_app$d (less$ ?v1) ?v0))) false) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (= ?v0 ?v1) (fun_app$d (less$ ?v1) ?v2)) (fun_app$d (less$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_nat_fun$) (?v2 Nat$) (?v3 Nat$)) (=> (and (= ?v0 (fun_app$r ?v1 ?v2)) (and (fun_app$d (less$ ?v2) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less$ ?v4) ?v5) (fun_app$d (less$ (fun_app$r ?v1 ?v4)) (fun_app$r ?v1 ?v5))) ))) (fun_app$d (less$ ?v0) (fun_app$r ?v1 ?v3))) ))
(assert (forall ((?v0 Nat_bool_fun$) (?v1 Nat$)) (=> (forall ((?v2 Nat$)) (=> (forall ((?v3 Nat$)) (=> (fun_app$d (less$ ?v3) ?v2) (fun_app$d ?v0 ?v3)) ) (fun_app$d ?v0 ?v2)) ) (fun_app$d ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (=> (fun_app$d (less$ ?v0) ?v1) false) (and (=> (= ?v0 ?v1) false) (=> (fun_app$d (less$ ?v1) ?v0) false))) false) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (not (fun_app$d (less$ ?v0) ?v1)) (or (fun_app$d (less$ ?v1) ?v0) (= ?v0 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (not (= ?v0 ?v1)) (or (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less$ ?v1) ?v0))) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State$)) (= (root$ (mkTree$ ?v0 ?v1 ?v2)) (pair$ ?v2 (shd$ (trim$ ?v0 ?v1 ?v2)))) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_tree$) (?v3 State_rule_prod_stream$)) (=> (and (fun_app$ (fun_app$s (wf$ ?v0) ?v1) ?v2) (ipath$ ?v2 ?v3)) (epath$ ?v0 ?v1 ?v3)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (or (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less$ ?v1) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (not (fun_app$d (less_eq$ ?v0) ?v1)) (fun_app$d (less$ ?v1) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (not (fun_app$d (less$ ?v0) ?v1)) (fun_app$d (less_eq$ ?v1) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (=> (not (fun_app$d (less$ ?v0) ?v1)) (= (fun_app$d (less_eq$ ?v0) ?v1) (= ?v0 ?v1))) :pattern ((fun_app$d (less_eq$ ?v0) ?v1)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (not (= ?v0 ?v1)) (fun_app$d (less_eq$ ?v0) ?v1)) (fun_app$d (less$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less_eq$ ?v0) ?v1) (not (fun_app$d (less$ ?v1) ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less_eq$ ?v0) ?v1) (or (fun_app$d (less$ ?v0) ?v1) (= ?v0 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less_eq$ ?v0) ?v1) (= (not (fun_app$d (less$ ?v0) ?v1)) (= ?v0 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (not (= ?v0 ?v1))) (fun_app$d (less$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less$ ?v1) ?v2)) (fun_app$d (less$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less$ ?v1) ?v2)) (fun_app$d (less$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (fun_app$d (less$ ?v2) ?v0)) (fun_app$d (less$ ?v2) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_nat_fun$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) (fun_app$r ?v1 ?v2)) (and (fun_app$d (less$ ?v2) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less$ ?v4) ?v5) (fun_app$d (less$ (fun_app$r ?v1 ?v4)) (fun_app$r ?v1 ?v5))) ))) (fun_app$d (less$ ?v0) (fun_app$r ?v1 ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_fun$) (?v3 Nat$)) (=> (and (fun_app$d (less_eq$ ?v0) ?v1) (and (fun_app$d (less$ (fun_app$r ?v2 ?v1)) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less_eq$ ?v4) ?v5) (fun_app$d (less_eq$ (fun_app$r ?v2 ?v4)) (fun_app$r ?v2 ?v5))) ))) (fun_app$d (less$ (fun_app$r ?v2 ?v0)) ?v3)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less_eq$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less_eq$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less_eq$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v2)) (fun_app$d (less$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less_eq$ ?v1) ?v2)) (fun_app$d (less$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less_eq$ ?v2) ?v0)) (fun_app$d (less$ ?v2) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat_nat_fun$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$d (less$ ?v0) (fun_app$r ?v1 ?v2)) (and (fun_app$d (less_eq$ ?v2) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less_eq$ ?v4) ?v5) (fun_app$d (less_eq$ (fun_app$r ?v1 ?v4)) (fun_app$r ?v1 ?v5))) ))) (fun_app$d (less$ ?v0) (fun_app$r ?v1 ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_fun$) (?v3 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v1) (and (fun_app$d (less_eq$ (fun_app$r ?v2 ?v1)) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$d (less$ ?v4) ?v5) (fun_app$d (less$ (fun_app$r ?v2 ?v4)) (fun_app$r ?v2 ?v5))) ))) (fun_app$d (less$ (fun_app$r ?v2 ?v0)) ?v3)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (not (fun_app$d (less_eq$ ?v0) ?v1)) (fun_app$d (less$ ?v1) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (not (fun_app$d (less$ ?v0) ?v1)) (fun_app$d (less_eq$ ?v1) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less_eq$ ?v0) ?v1) (or (fun_app$d (less$ ?v0) ?v1) (= ?v0 ?v1))) :pattern ((fun_app$d (less_eq$ ?v0) ?v1)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less_eq$ ?v0) ?v1) (or (fun_app$d (less$ ?v0) ?v1) (= ?v0 ?v1))) :pattern ((fun_app$d (less_eq$ ?v0) ?v1)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less_eq$ ?v0) ?v1) (or (fun_app$d (less$ ?v0) ?v1) (= ?v1 ?v0))) :pattern ((fun_app$d (less_eq$ ?v0) ?v1)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less$ ?v0) ?v1) (and (fun_app$d (less_eq$ ?v0) ?v1) (not (fun_app$d (less_eq$ ?v1) ?v0)))) :pattern ((fun_app$d (less$ ?v0) ?v1)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less$ ?v0) ?v1) (and (fun_app$d (less_eq$ ?v0) ?v1) (not (= ?v0 ?v1)))) :pattern ((fun_app$d (less$ ?v0) ?v1)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less$ ?v0) ?v1) (and (fun_app$d (less_eq$ ?v0) ?v1) (not (= ?v0 ?v1)))) :pattern ((fun_app$d (less$ ?v0) ?v1)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less$ ?v0) ?v1) (and (fun_app$d (less_eq$ ?v0) ?v1) (not (= ?v1 ?v0)))) :pattern ((fun_app$d (less$ ?v0) ?v1)))))
(assert (forall ((?v0 State$) (?v1 Rule_stream$) (?v2 State_rule_prod_tree$)) (=> (and (member$b ?v0 s$) (and (fair$ rules$ ?v1) (fmember$b ?v2 (cont$ (mkTree$ eff$ ?v1 ?v0))))) (exists ((?v3 State_fset$) (?v4 State$)) (and (member$b ?v4 s$) (and (fun_app$f (fun_app$g (fun_app$h eff$ (shd$ (trim$ eff$ ?v1 ?v0))) ?v0) ?v3) (and (fmember$ ?v4 ?v3) (= ?v2 (mkTree$ eff$ (stl$ (trim$ eff$ ?v1 ?v0)) ?v4))))) )) ))
(assert (forall ((?v0 Rule_stream$) (?v1 State$) (?v2 Rule$)) (=> (and (fair$ rules$ ?v0) (and (fun_app$d (less$ (minWait$ eff$ ?v0 ?v1)) (pos$ ?v0 ?v2)) (and (member$c ?v2 (sset$ rules$)) (member$b ?v1 s$)))) (= (pos$ (stl$ (trim$ eff$ ?v0 ?v1)) ?v2) (fun_app$r (minus$ (pos$ ?v0 ?v2)) (suc$ (minWait$ eff$ ?v0 ?v1))))) ))
(assert (forall ((?v0 State_fset$) (?v1 State_fset$)) (=> (forall ((?v2 State$)) (=> (fmember$ ?v2 ?v0) (fmember$ ?v2 ?v1)) ) (less_eq$b ?v0 ?v1)) ))
(assert (forall ((?v0 State_rule_prod_tree_fset$) (?v1 State_rule_prod_tree_fset$)) (=> (forall ((?v2 State_rule_prod_tree$)) (=> (fmember$b ?v2 ?v0) (fmember$b ?v2 ?v1)) ) (less_eq$c ?v0 ?v1)) ))
(assert (forall ((?v0 State_rule_prod_rule_rule_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 State_rule_prod_stream$) (?v5 Rule_state_rule_prod_prod_tree$)) (=> (and (ruleSystem$i ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (and (fair$e ?v1 ?v4) (fmember$d ?v5 (cont$a (mkTree$g ?v0 ?v4 ?v3)))))) (exists ((?v6 Rule_fset$) (?v7 Rule$)) (and (member$c ?v7 ?v2) (and (fun_app$k (fun_app$l (fun_app$q ?v0 (shd$a (trim$e ?v0 ?v4 ?v3))) ?v3) ?v6) (and (fmember$a ?v7 ?v6) (= ?v5 (mkTree$g ?v0 (stl$a (trim$e ?v0 ?v4 ?v3)) ?v7))))) )) ))
(assert (forall ((?v0 State_rule_prod_state_state_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_set$) (?v3 State$) (?v4 State_rule_prod_stream$) (?v5 State_state_rule_prod_prod_tree$)) (=> (and (ruleSystem$h ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (and (fair$e ?v1 ?v4) (fmember$e ?v5 (cont$b (mkTree$f ?v0 ?v4 ?v3)))))) (exists ((?v6 State_fset$) (?v7 State$)) (and (member$b ?v7 ?v2) (and (fun_app$f (fun_app$g (fun_app$o ?v0 (shd$a (trim$f ?v0 ?v4 ?v3))) ?v3) ?v6) (and (fmember$ ?v7 ?v6) (= ?v5 (mkTree$f ?v0 (stl$a (trim$f ?v0 ?v4 ?v3)) ?v7))))) )) ))
(assert (forall ((?v0 State_rule_prod_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$) (?v1 State_rule_prod_stream$) (?v2 State_rule_prod_tree_set$) (?v3 State_rule_prod_tree$) (?v4 State_rule_prod_stream$) (?v5 State_rule_prod_tree_state_rule_prod_prod_tree$)) (=> (and (ruleSystem$l ?v0 ?v1 ?v2) (and (member$ ?v3 ?v2) (and (fair$e ?v1 ?v4) (fmember$f ?v5 (cont$c (mkTree$j ?v0 ?v4 ?v3)))))) (exists ((?v6 State_rule_prod_tree_fset$) (?v7 State_rule_prod_tree$)) (and (member$ ?v7 ?v2) (and (fun_app$v (fun_app$w (fun_app$an ?v0 (shd$a (trim$h ?v0 ?v4 ?v3))) ?v3) ?v6) (and (fmember$b ?v7 ?v6) (= ?v5 (mkTree$j ?v0 (stl$a (trim$h ?v0 ?v4 ?v3)) ?v7))))) )) ))
(assert (forall ((?v0 Rule_rule_rule_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 Rule_set$) (?v3 Rule$) (?v4 Rule_stream$) (?v5 Rule_rule_prod_tree$)) (=> (and (ruleSystem$c ?v0 ?v1 ?v2) (and (member$c ?v3 ?v2) (and (fair$ ?v1 ?v4) (fmember$g ?v5 (cont$d (mkTree$a ?v0 ?v4 ?v3)))))) (exists ((?v6 Rule_fset$) (?v7 Rule$)) (and (member$c ?v7 ?v2) (and (fun_app$k (fun_app$l (fun_app$m ?v0 (shd$ (trim$g ?v0 ?v4 ?v3))) ?v3) ?v6) (and (fmember$a ?v7 ?v6) (= ?v5 (mkTree$a ?v0 (stl$ (trim$g ?v0 ?v4 ?v3)) ?v7))))) )) ))
(assert (forall ((?v0 Rule_state_rule_prod_tree_state_rule_prod_tree_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_rule_prod_tree_set$) (?v3 State_rule_prod_tree$) (?v4 Rule_stream$) (?v5 State_rule_prod_tree_rule_prod_tree$)) (=> (and (ruleSystem$e ?v0 ?v1 ?v2) (and (member$ ?v3 ?v2) (and (fair$ ?v1 ?v4) (fmember$h ?v5 (cont$e (mkTree$i ?v0 ?v4 ?v3)))))) (exists ((?v6 State_rule_prod_tree_fset$) (?v7 State_rule_prod_tree$)) (and (member$ ?v7 ?v2) (and (fun_app$v (fun_app$w (fun_app$y ?v0 (shd$ (trim$b ?v0 ?v4 ?v3))) ?v3) ?v6) (and (fmember$b ?v7 ?v6) (= ?v5 (mkTree$i ?v0 (stl$ (trim$b ?v0 ?v4 ?v3)) ?v7))))) )) ))
(assert (forall ((?v0 Rule_state_state_fset_bool_fun_fun_fun$) (?v1 Rule_stream$) (?v2 State_set$) (?v3 State$) (?v4 Rule_stream$) (?v5 State_rule_prod_tree$)) (=> (and (ruleSystem$ ?v0 ?v1 ?v2) (and (member$b ?v3 ?v2) (and (fair$ ?v1 ?v4) (fmember$b ?v5 (cont$ (mkTree$ ?v0 ?v4 ?v3)))))) (exists ((?v6 State_fset$) (?v7 State$)) (and (member$b ?v7 ?v2) (and (fun_app$f (fun_app$g (fun_app$h ?v0 (shd$ (trim$ ?v0 ?v4 ?v3))) ?v3) ?v6) (and (fmember$ ?v7 ?v6) (= ?v5 (mkTree$ ?v0 (stl$ (trim$ ?v0 ?v4 ?v3)) ?v7))))) )) ))
(assert (forall ((?v0 Rule_bool_fun$)) (= (= (collect$a ?v0) bot$) (forall ((?v1 Rule$)) (not (fun_app$c ?v0 ?v1)) )) ))
(assert (forall ((?v0 State_set$)) (= (forall ((?v1 State$)) (not (member$b ?v1 ?v0)) ) (= ?v0 bot$b)) ))
(assert (forall ((?v0 Rule_set$)) (= (forall ((?v1 Rule$)) (not (member$c ?v1 ?v0)) ) (= ?v0 bot$)) ))
(assert (forall ((?v0 Rule_set$)) (= (less_eq$a ?v0 bot$) (= ?v0 bot$)) ))
(assert (forall ((?v0 Rule_set$)) (less_eq$a bot$ ?v0) ))
(assert (forall ((?v0 State$)) (= (member$b ?v0 bot$b) false) ))
(assert (forall ((?v0 Rule$)) (= (member$c ?v0 bot$) false) ))
(assert (forall ((?v0 Rule_bool_fun$)) (= (= bot$ (collect$a ?v0)) (forall ((?v1 Rule$)) (not (fun_app$c ?v0 ?v1)) )) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (= (suc$ ?v0) (suc$ ?v1)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (= (suc$ ?v0) (suc$ ?v1)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 State$)) (= (fmember$ ?v0 bot$c) false) ))
(assert (forall ((?v0 State_rule_prod_tree$)) (= (fmember$b ?v0 bot$d) false) ))
(assert (forall ((?v0 State_fset$)) (= (forall ((?v1 State$)) (not (fmember$ ?v1 ?v0)) ) (= ?v0 bot$c)) ))
(assert (forall ((?v0 State_rule_prod_tree_fset$)) (= (forall ((?v1 State_rule_prod_tree$)) (not (fmember$b ?v1 ?v0)) ) (= ?v0 bot$d)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less$ (suc$ ?v0)) (suc$ ?v1)) (fun_app$d (less$ ?v0) ?v1)) :pattern ((fun_app$d (less$ (suc$ ?v0)) (suc$ ?v1))))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (fun_app$d (less$ (suc$ ?v0)) (suc$ ?v1))) ))
(assert (forall ((?v0 Nat$)) (fun_app$d (less$ ?v0) (suc$ ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less_eq$ (suc$ ?v0)) (suc$ ?v1)) (fun_app$d (less_eq$ ?v0) ?v1)) :pattern ((fun_app$d (less_eq$ (suc$ ?v0)) (suc$ ?v1))))))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$r (minus$ (fun_app$r (minus$ (suc$ ?v0)) ?v1)) (suc$ ?v2)) (fun_app$r (minus$ (fun_app$r (minus$ ?v0) ?v1)) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$r (minus$ (suc$ ?v0)) (suc$ ?v1)) (fun_app$r (minus$ ?v0) ?v1)) :pattern ((fun_app$r (minus$ (suc$ ?v0)) (suc$ ?v1))))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less_eq$ ?v0) ?v1) (= (fun_app$r (minus$ ?v1) (fun_app$r (minus$ ?v1) ?v0)) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Rule_stream$)) (= (stl$ (sdrop$ ?v0 ?v1)) (sdrop$ (suc$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 State_rule_prod_stream$)) (= (stl$a (sdrop$e ?v0 ?v1)) (sdrop$e (suc$ ?v0) ?v1)) ))
(assert (forall ((?v0 State_fset$) (?v1 State_fset$) (?v2 State$)) (=> (and (less$b ?v0 ?v1) (fmember$ ?v2 ?v0)) (fmember$ ?v2 ?v1)) ))
(assert (forall ((?v0 State_rule_prod_tree_fset$) (?v1 State_rule_prod_tree_fset$) (?v2 State_rule_prod_tree$)) (=> (and (less$c ?v0 ?v1) (fmember$b ?v2 ?v0)) (fmember$b ?v2 ?v1)) ))
(assert (forall ((?v0 State$)) (=> (fmember$ ?v0 bot$c) false) ))
(assert (forall ((?v0 State_rule_prod_tree$)) (=> (fmember$b ?v0 bot$d) false) ))
(assert (forall ((?v0 State_fset$) (?v1 State$)) (=> (= ?v0 bot$c) (not (fmember$ ?v1 ?v0))) ))
(assert (forall ((?v0 State_rule_prod_tree_fset$) (?v1 State_rule_prod_tree$)) (=> (= ?v0 bot$d) (not (fmember$b ?v1 ?v0))) ))
(assert (forall ((?v0 State_fset$)) (=> (forall ((?v1 State$)) (=> (fmember$ ?v1 ?v0) false) ) (= ?v0 bot$c)) ))
(assert (forall ((?v0 State_rule_prod_tree_fset$)) (=> (forall ((?v1 State_rule_prod_tree$)) (=> (fmember$b ?v1 ?v0) false) ) (= ?v0 bot$d)) ))
(assert (forall ((?v0 State_fset$)) (= (exists ((?v1 State$)) (fmember$ ?v1 ?v0) ) (not (= ?v0 bot$c))) ))
(assert (forall ((?v0 State_rule_prod_tree_fset$)) (= (exists ((?v1 State_rule_prod_tree$)) (fmember$b ?v1 ?v0) ) (not (= ?v0 bot$d))) ))
(assert (= bot$ (collect$a bot$e)))
(assert (forall ((?v0 Rule_set$)) (not (less$a ?v0 bot$)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (=> (fun_app$d (less_eq$ ?v0) ?v1) (= (fun_app$r (minus$ (suc$ ?v1)) ?v0) (suc$ (fun_app$r (minus$ ?v1) ?v0)))) :pattern ((fun_app$r (minus$ (suc$ ?v1)) ?v0)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$r (minus$ (fun_app$r (minus$ ?v0) ?v1)) ?v2) (fun_app$r (minus$ (fun_app$r (minus$ ?v0) ?v2)) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (= (suc$ ?v0) (suc$ ?v1)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ ?v0) ?v1) (= (suc$ (fun_app$r (minus$ ?v1) (suc$ ?v0))) (fun_app$r (minus$ ?v1) ?v0))) ))
(assert (forall ((?v0 Nat_bool_fun$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$d ?v0 ?v1) (forall ((?v3 Nat$)) (=> (fun_app$d ?v0 (suc$ ?v3)) (fun_app$d ?v0 ?v3)) )) (fun_app$d ?v0 (fun_app$r (minus$ ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$)) (not (= ?v0 (suc$ ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (fun_app$d (less$ (fun_app$r (minus$ ?v0) ?v1)) (suc$ ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (less$ ?v0) (suc$ ?v1)) (or (fun_app$d (less$ ?v0) ?v1) (= ?v0 ?v1))) :pattern ((fun_app$d (less$ ?v0) (suc$ ?v1))))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$d (less$ (suc$ ?v0)) ?v1) (exists ((?v2 Nat$)) (and (= ?v1 (suc$ ?v2)) (fun_app$d (less$ ?v0) ?v2)) )) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (not (fun_app$d (less$ ?v0) ?v1)) (fun_app$d (less$ ?v1) (suc$ ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ (suc$ ?v0)) (suc$ ?v1)) (fun_app$d (less$ ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$d (less$ (suc$ ?v0)) ?v1) (forall ((?v2 Nat$)) (=> (and (fun_app$d (less$ ?v0) ?v2) (= ?v1 (suc$ ?v2))) false) )) false) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$d (less$ (suc$ ?v0)) ?v1) (fun_app$d (less$ ?v0) ?v1)) ))
(check-sat)
(exit)

