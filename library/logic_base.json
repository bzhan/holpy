{
    "content": [
        {
            "ascii_op": "&",
            "name": "conj",
            "ty": "def.ax",
            "type": "bool ⇒ bool ⇒ bool",
            "unicode_op": "∧"
        },
        {
            "ascii_op": "|",
            "name": "disj",
            "ty": "def.ax",
            "type": "bool => bool => bool",
            "unicode_op": "∨"
        },
        {
            "ascii_op": "~",
            "name": "neg",
            "ty": "def.ax",
            "type": "bool => bool",
            "unicode_op": "¬"
        },
        {
            "name": "true",
            "ty": "def.ax",
            "type": "bool"
        },
        {
            "name": "false",
            "ty": "def.ax",
            "type": "bool"
        },
        {
            "name": "exists",
            "ty": "def.ax",
            "type": "('a => bool) => bool"
        },
        {
            "name": "IF",
            "ty": "def.ax",
            "type": "bool => 'a => 'a => 'a"
        },
        {
            "hint_backward": "true",
            "hint_rewrite": "true",
            "name": "conjI",
            "num_gaps": 1,
            "proof": [
                {
                    "args": "A",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "A ⊢ A"
                },
                {
                    "args": "B",
                    "id": "1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "B ⊢ B"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "sorry",
                    "th": "A, B ⊢ A ∧ B"
                },
                {
                    "args": "B",
                    "id": "3",
                    "prevs": [
                        "2"
                    ],
                    "rule": "implies_intr",
                    "th": "A ⊢ B ⟶ A ∧ B"
                },
                {
                    "args": "A",
                    "id": "4",
                    "prevs": [
                        "1"
                    ],
                    "rule": "implies_intr",
                    "th": "B ⊢ A ⟶ B"
                }
            ],
<<<<<<< HEAD
            "prop": "A ⟶ B ⟶ A ∧ B",
=======
            "prop": "A --> B --> A & B",
>>>>>>> c331dca663806a01f58e21d54b62c4109bcb8ad1
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "hint_backward": "true",
            "name": "conjD1",
            "prop": "A ∧ B ⟶ A",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "conjD2",
            "prop": "A & B --> B",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "disjI1",
            "prop": "A --> A | B",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "disjI2",
            "prop": "B --> A | B",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "disjE",
            "prop": "A | B --> (A --> C) --> (B --> C) --> C",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool",
                "C": "bool"
            }
        },
        {
            "name": "negI",
            "prop": "(A --> false) --> ~A",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "negE",
            "prop": "~A --> A --> false",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "trueI",
            "prop": "true",
            "ty": "thm",
            "vars": {}
        },
        {
            "name": "falseE",
            "prop": "false --> A",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "exI",
            "prop": "P a --> ?a. P a",
            "ty": "thm",
            "vars": {
                "P": "'a => bool",
                "a": "'a"
            }
        },
        {
            "name": "exE",
            "prop": "(?a. P a) --> (!a. P a --> C) --> C",
            "ty": "thm",
            "vars": {
                "C": "bool",
                "P": "'a => bool",
                "a": "'a"
            }
        },
        {
            "name": "classical",
            "prop": "A | ~A",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "extension",
            "prop": "(!x. f x = g x) --> f = g",
            "ty": "thm",
            "vars": {
                "f": "'a => 'b",
                "g": "'a => 'b"
            }
        },
        {
            "name": "if_P",
            "prop": "P --> (if P then x else y) = x",
            "ty": "thm",
            "vars": {
                "P": "bool",
                "x": "'a",
                "y": "'a"
            }
        },
        {
            "name": "if_not_P",
            "num_gaps": 1,
            "proof": [
                {
                    "args": "¬P",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "¬P ⊢ ¬P"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "sorry",
                    "th": "¬P ⊢ (if P then x else y) = y"
                },
                {
                    "args": "¬P",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "implies_intr",
                    "th": "⊢ ¬P ⟶ (if P then x else y) = y"
                }
            ],
            "prop": "~P --> (if P then x else y) = y",
            "ty": "thm",
            "vars": {
                "P": "bool",
                "x": "'a",
                "y": "'a"
            }
        },
        {
            "name": "arg_combination",
            "ty": "macro"
        },
        {
            "name": "fun_combination",
            "ty": "macro"
        },
        {
            "name": "beta_norm",
            "ty": "macro"
        },
        {
            "name": "apply_theorem",
            "ty": "macro"
        },
        {
            "name": "apply_theorem_for",
            "ty": "macro"
        },
        {
            "name": "rewrite_goal",
            "ty": "macro"
        },
        {
            "name": "rewrite_back_goal",
            "ty": "macro"
        }
    ],
    "description": "Foundation of higher-order logic",
    "imports": [],
    "name": "logic_base"
}