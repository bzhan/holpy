{
    "content": [
        {
            "depth": 0,
            "name": "Basic definitions",
            "ty": "header"
        },
        {
            "name": "zero",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a"
        },
        {
            "name": "one",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a"
        },
        {
            "args": [],
            "constrs": [
                {
                    "args": [],
                    "name": "zero",
                    "type": "nat"
                },
                {
                    "args": [
                        "n"
                    ],
                    "name": "Suc",
                    "type": "nat => nat"
                }
            ],
            "name": "nat",
            "ty": "type.ind"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "one",
            "prop": "1 = Suc 0",
            "ty": "def",
            "type": "nat"
        },
        {
            "name": "of_nat",
            "overloaded": true,
            "ty": "def.ax",
            "type": "nat => 'a "
        },
        {
            "name": "of_nat",
            "prop": "of_nat n = n",
            "ty": "def",
            "type": "nat ⇒ nat"
        },
        {
            "name": "Pre",
            "rules": [
                {
                    "prop": "Pre 0 = 0"
                },
                {
                    "prop": "Pre (Suc n) = n"
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat"
        },
        {
            "ascii_op": "+",
            "name": "plus",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a => 'a => 'a"
        },
        {
            "ascii_op": "-",
            "name": "minus",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a => 'a => 'a"
        },
        {
            "ascii_op": "*",
            "name": "times",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a => 'a => 'a"
        },
        {
            "ascii_op": "^",
            "name": "power",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a => 'b => 'a"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "plus",
            "rules": [
                {
                    "prop": "0 + n = n"
                },
                {
                    "prop": "Suc m + n = Suc (m + n)"
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat => nat"
        },
        {
            "ascii_op": "*",
            "name": "times",
            "rules": [
                {
                    "prop": "0 * (n::nat) = 0"
                },
                {
                    "prop": "Suc m * n = n + m * n"
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat => nat"
        },
        {
            "ascii_op": "^",
            "name": "power",
            "rules": [
                {
                    "prop": "(n::nat) ^ 0 = 1"
                },
                {
                    "prop": "n ^ Suc m = n * n ^ m"
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat => nat"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "add_0_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_plus_def_1, (0::nat) + 0 = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ (0::nat) + 0 = 0"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n + 0 = n ⟶ Suc n + 0 = Suc n"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "n + 0 = n",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n + 0 = n ⊢ n + 0 = n"
                },
                {
                    "args": "Suc (n + 0) = Suc n",
                    "id": "1.2",
                    "prevs": [
                        "1.1",
                        "1.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n + 0 = n ⊢ Suc (n + 0) = Suc n"
                },
                {
                    "args": "nat_plus_def_2, Suc n + 0 = Suc n",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n + 0 = n ⊢ Suc n + 0 = Suc n"
                },
                {
                    "args": "",
                    "id": "1.4",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n + 0 = n ⟶ Suc n + 0 = Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λx::nat. x + 0 = x, x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + 0 = x"
                }
            ],
            "prop": "x + 0 = x",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_1"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_2"
                },
                {
                    "fact_ids": [
                        "1.1"
                    ],
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal_with_prev"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "name": "add_1_left",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_plus_def_1, Suc (0 + x) = Suc x",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc (0 + x) = Suc x"
                },
                {
                    "args": "nat_plus_def_2, Suc 0 + x = Suc x",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc 0 + x = Suc x"
                },
                {
                    "args": "nat_one_def, 1 + x = Suc x",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 1 + x = Suc x"
                }
            ],
            "prop": "1 + x = Suc x",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_one_def"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_2"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_1"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "name": "add_1_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_one_def, 1 = Suc 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 1 = Suc 0"
                },
                {
                    "args": "nat_plus_def_1, 0 + 1 = Suc 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 + 1 = Suc 0"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n + 1 = Suc n ⟶ Suc n + 1 = Suc (Suc n)"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "n + 1 = Suc n",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n + 1 = Suc n ⊢ n + 1 = Suc n"
                },
                {
                    "args": "Suc (n + 1) = Suc (Suc n)",
                    "id": "2.2",
                    "prevs": [
                        "2.1",
                        "2.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n + 1 = Suc n ⊢ Suc (n + 1) = Suc (Suc n)"
                },
                {
                    "args": "nat_plus_def_2, Suc n + 1 = Suc (Suc n)",
                    "id": "2.3",
                    "prevs": [
                        "2.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n + 1 = Suc n ⊢ Suc n + 1 = Suc (Suc n)"
                },
                {
                    "args": "",
                    "id": "2.4",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n + 1 = Suc n ⟶ Suc n + 1 = Suc (Suc n)"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x + 1 = Suc x, x: x}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + 1 = Suc x"
                }
            ],
            "prop": "x + 1 = Suc x",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_one_def"
                },
                {
                    "goal_id": "2",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_2"
                },
                {
                    "fact_ids": [
                        "2.1"
                    ],
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal_with_prev"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "add_Suc_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_plus_def_1, 0 + Suc y = Suc (0 + y)",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 + Suc y = Suc (0 + y)"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n + Suc y = Suc (n + y) ⟶ Suc n + Suc y = Suc (Suc n + y)"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "n + Suc y = Suc (n + y)",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n + Suc y = Suc (n + y) ⊢ n + Suc y = Suc (n + y)"
                },
                {
                    "args": "Suc (n + Suc y) = Suc (Suc (n + y))",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n + Suc y = Suc (n + y) ⊢ Suc (n + Suc y) = Suc (Suc (n + y))"
                },
                {
                    "args": "nat_plus_def_2, Suc n + Suc y = Suc (Suc n + y)",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n + Suc y = Suc (n + y) ⊢ Suc n + Suc y = Suc (Suc n + y)"
                },
                {
                    "args": "",
                    "id": "1.4",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n + Suc y = Suc (n + y) ⟶ Suc n + Suc y = Suc (Suc n + y)"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x + Suc y = Suc (x + y), x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + Suc y = Suc (x + y)"
                }
            ],
            "prop": "x + Suc y = Suc (x + y)",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "add_comm",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_plus_def_1, 0 + y = y",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 + y = y"
                },
                {
                    "args": "add_0_right, 0 + y = y + 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 + y = y + 0"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n + y = y + n ⟶ Suc n + y = y + Suc n"
                },
                {
                    "args": "x, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR x"
                },
                {
                    "args": "x + y = y + x",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "x + y = y + x ⊢ x + y = y + x"
                },
                {
                    "args": "Suc (x + y) = Suc (y + x)",
                    "id": "2.2",
                    "prevs": [
                        "2.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "x + y = y + x ⊢ Suc (x + y) = Suc (y + x)"
                },
                {
                    "args": "add_Suc_right, Suc (x + y) = y + Suc x",
                    "id": "2.3",
                    "prevs": [
                        "2.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x + y = y + x ⊢ Suc (x + y) = y + Suc x"
                },
                {
                    "args": "nat_plus_def_2, Suc x + y = y + Suc x",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x + y = y + x ⊢ Suc x + y = y + Suc x"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀x. x + y = y + x ⟶ Suc x + y = y + Suc x"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x + y = y + x, x: x}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + y = y + x"
                }
            ],
            "prop": "x + y = y + x",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "add_0_right"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_1"
                },
                {
                    "goal_id": "2",
                    "method_name": "introduction",
                    "names": "x"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_2"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "theorem": "add_Suc_right"
                },
                {
                    "fact_ids": [
                        "2.1"
                    ],
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal_with_prev"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "add_assoc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_plus_def_1, 0 + y + z = 0 + (y + z)",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 + y + z = 0 + (y + z)"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n + y + z = n + (y + z) ⟶ Suc n + y + z = Suc n + (y + z)"
                },
                {
                    "args": "x, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR x"
                },
                {
                    "args": "x + y + z = x + (y + z)",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "x + y + z = x + (y + z) ⊢ x + y + z = x + (y + z)"
                },
                {
                    "args": "Suc (x + y + z) = Suc (x + (y + z))",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "x + y + z = x + (y + z) ⊢ Suc (x + y + z) = Suc (x + (y + z))"
                },
                {
                    "args": "nat_plus_def_2, Suc (x + y) + z = Suc (x + (y + z))",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x + y + z = x + (y + z) ⊢ Suc (x + y) + z = Suc (x + (y + z))"
                },
                {
                    "args": "nat_plus_def_2, Suc x + y + z = Suc x + (y + z)",
                    "id": "1.4",
                    "prevs": [
                        "1.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x + y + z = x + (y + z) ⊢ Suc x + y + z = Suc x + (y + z)"
                },
                {
                    "args": "",
                    "id": "1.5",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀x. x + y + z = x + (y + z) ⟶ Suc x + y + z = Suc x + (y + z)"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x + y + z = x + (y + z), x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + y + z = x + (y + z)"
                }
            ],
            "prop": "x + y + z = x + (y + z)",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_1"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction",
                    "names": "x"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_2"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_2"
                },
                {
                    "fact_ids": [
                        "1.1"
                    ],
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal_with_prev"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "mult_0_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_times_def_1, (0::nat) * 0 = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ (0::nat) * 0 = 0"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * 0 = 0 ⟶ Suc n * 0 = 0"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "n * 0 = 0",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n * 0 = 0 ⊢ n * 0 = 0"
                },
                {
                    "args": "nat_plus_def_1, 0 + n * 0 = 0",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * 0 = 0 ⊢ 0 + n * 0 = 0"
                },
                {
                    "args": "nat_times_def_2, Suc n * 0 = 0",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * 0 = 0 ⊢ Suc n * 0 = 0"
                },
                {
                    "args": "",
                    "id": "1.4",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n * 0 = 0 ⟶ Suc n * 0 = 0"
                },
                {
                    "args": "nat_induct, {}, {P: λx::nat. x * 0 = 0, x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * 0 = 0"
                }
            ],
            "prop": "x * 0 = 0",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_1"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_2"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_1"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "mult_1_left",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "x + 0 = x",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ x + 0 = x"
                },
                {
                    "args": "nat_times_def_1, x + 0 * x = x",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ x + 0 * x = x"
                },
                {
                    "args": "nat_times_def_2, Suc 0 * x = x",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc 0 * x = x"
                },
                {
                    "args": "nat_one_def, 1 * x = x",
                    "id": "3",
                    "prevs": [
                        "2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 1 * x = x"
                }
            ],
            "prop": "1 * x = x",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_one_def"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_2"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "nat_norm"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "mult_1_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_times_def_1, (0::nat) * 1 = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ (0::nat) * 1 = 0"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * 1 = n ⟶ Suc n * 1 = Suc n"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "n * 1 = n",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n * 1 = n ⊢ n * 1 = n"
                },
                {
                    "args": "1 + n = Suc n",
                    "id": "1.2",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ 1 + n = Suc n"
                },
                {
                    "args": "1 + n * 1 = Suc n",
                    "id": "1.3",
                    "prevs": [
                        "1.1",
                        "1.2",
                        "1.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n * 1 = n ⊢ 1 + n * 1 = Suc n"
                },
                {
                    "args": "nat_times_def_2, Suc n * 1 = Suc n",
                    "id": "1.4",
                    "prevs": [
                        "1.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * 1 = n ⊢ Suc n * 1 = Suc n"
                },
                {
                    "args": "",
                    "id": "1.5",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n * 1 = n ⟶ Suc n * 1 = Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λx::nat. x * 1 = x, x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * 1 = x"
                }
            ],
            "prop": "x * 1 = x",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_1"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_2"
                },
                {
                    "fact_ids": [
                        "1.1"
                    ],
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "nat_norm"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "mult_Suc_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_times_def_1, 0 * Suc y = 0 * y",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * Suc y = 0 * y"
                },
                {
                    "args": "nat_plus_def_1, 0 * Suc y = 0 + 0 * y",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * Suc y = 0 + 0 * y"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * Suc y = n + n * y ⟶ Suc n * Suc y = Suc n + Suc n * y"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "n * Suc y = n + n * y",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n * Suc y = n + n * y ⊢ n * Suc y = n + n * y"
                },
                {
                    "args": "Suc (y + (n + n * y)) = Suc (n + (y + n * y))",
                    "id": "2.2",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ Suc (y + (n + n * y)) = Suc (n + (y + n * y))"
                },
                {
                    "args": "Suc (y + n * Suc y) = Suc (n + (y + n * y))",
                    "id": "2.3",
                    "prevs": [
                        "2.1",
                        "2.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n * Suc y = n + n * y ⊢ Suc (y + n * Suc y) = Suc (n + (y + n * y))"
                },
                {
                    "args": "nat_plus_def_2, Suc y + n * Suc y = Suc n + (y + n * y)",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * Suc y = n + n * y ⊢ Suc y + n * Suc y = Suc n + (y + n * y)"
                },
                {
                    "args": "nat_times_def_2, Suc n * Suc y = Suc n + Suc n * y",
                    "id": "2.5",
                    "prevs": [
                        "2.4"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * Suc y = n + n * y ⊢ Suc n * Suc y = Suc n + Suc n * y"
                },
                {
                    "args": "",
                    "id": "2.6",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.5"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n * Suc y = n + n * y ⟶ Suc n * Suc y = Suc n + Suc n * y"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x * Suc y = x + x * y, x: x}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * Suc y = x + x * y"
                }
            ],
            "prop": "x * Suc y = x + x * y",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite",
                "hint_rewrite_sym"
            ],
            "name": "distrib_l",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "add_0_right, 0 = 0 + 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 = 0 + 0"
                },
                {
                    "args": "nat_times_def_1, 0 * (y + z) = 0 * y + 0 * z",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * (y + z) = 0 * y + 0 * z"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * (y + z) = n * y + n * z ⟶ Suc n * (y + z) = Suc n * y + Suc n * z"
                },
                {
                    "args": "x, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR x"
                },
                {
                    "args": "x * (y + z) = x * y + x * z",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "x * (y + z) = x * y + x * z ⊢ x * (y + z) = x * y + x * z"
                },
                {
                    "args": "y + z + (x * y + x * z) = y + x * y + (z + x * z)",
                    "id": "2.2",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ y + z + (x * y + x * z) = y + x * y + (z + x * z)"
                },
                {
                    "args": "y + z + x * (y + z) = y + x * y + (z + x * z)",
                    "id": "2.3",
                    "prevs": [
                        "2.1",
                        "2.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "x * (y + z) = x * y + x * z ⊢ y + z + x * (y + z) = y + x * y + (z + x * z)"
                },
                {
                    "args": "nat_times_def_2, Suc x * (y + z) = Suc x * y + Suc x * z",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x * (y + z) = x * y + x * z ⊢ Suc x * (y + z) = Suc x * y + Suc x * z"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀x. x * (y + z) = x * y + x * z ⟶ Suc x * (y + z) = Suc x * y + Suc x * z"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x * (y + z) = x * y + x * z, x: x}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * (y + z) = x * y + x * z"
                }
            ],
            "prop": "x * (y + z) = x * y + x * z",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "add_0_right"
                },
                {
                    "goal_id": "2",
                    "method_name": "introduction",
                    "names": "x"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_2"
                },
                {
                    "fact_ids": [
                        "2.1"
                    ],
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "nat_norm"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "name": "distrib_r",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "add_0_right, (0::nat) = 0 + 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ (0::nat) = 0 + 0"
                },
                {
                    "args": "mult_0_right, (x + y) * 0 = x * 0 + y * 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ (x + y) * 0 = x * 0 + y * 0"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. (x + y) * n = x * n + y * n ⟶ (x + y) * Suc n = x * Suc n + y * Suc n"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "(x + y) * n = x * n + y * n",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "(x + y) * n = x * n + y * n ⊢ (x + y) * n = x * n + y * n"
                },
                {
                    "args": "x + y + (x * n + y * n) = x + x * n + (y + y * n)",
                    "id": "2.2",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ x + y + (x * n + y * n) = x + x * n + (y + y * n)"
                },
                {
                    "args": "x + y + (x + y) * n = x + x * n + (y + y * n)",
                    "id": "2.3",
                    "prevs": [
                        "2.1",
                        "2.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "(x + y) * n = x * n + y * n ⊢ x + y + (x + y) * n = x + x * n + (y + y * n)"
                },
                {
                    "args": "mult_Suc_right, (x + y) * Suc n = x * Suc n + y * Suc n",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "(x + y) * n = x * n + y * n ⊢ (x + y) * Suc n = x * Suc n + y * Suc n"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. (x + y) * n = x * n + y * n ⟶ (x + y) * Suc n = x * Suc n + y * Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λz. (x + y) * z = x * z + y * z, x: z}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ (x + y) * z = x * z + y * z"
                },
                {
                    "args": "",
                    "id": "4",
                    "prevs": [
                        "3"
                    ],
                    "rule": "intros",
                    "th": "⊢ (x + y) * z = x * z + y * z"
                }
            ],
            "prop": "(x + y) * z = x * z + y * z",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "z"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "mult_0_right"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "add_0_right"
                },
                {
                    "goal_id": "2",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "mult_Suc_right"
                },
                {
                    "fact_ids": [
                        "2.1"
                    ],
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "nat_norm"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite",
                "hint_rewrite_sym"
            ],
            "name": "mult_assoc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_times_def_1, 0 * z = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * z = 0"
                },
                {
                    "args": "nat_times_def_1, 0 * y * z = 0 * (y * z)",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * y * z = 0 * (y * z)"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * y * z = n * (y * z) ⟶ Suc n * y * z = Suc n * (y * z)"
                },
                {
                    "args": "x, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR x"
                },
                {
                    "args": "x * y * z = x * (y * z)",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "x * y * z = x * (y * z) ⊢ x * y * z = x * (y * z)"
                },
                {
                    "args": "y * z + x * y * z = y * z + x * (y * z)",
                    "id": "2.2",
                    "prevs": [
                        "2.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "x * y * z = x * (y * z) ⊢ y * z + x * y * z = y * z + x * (y * z)"
                },
                {
                    "args": "distrib_r, (y + x * y) * z = y * z + x * (y * z)",
                    "id": "2.3",
                    "prevs": [
                        "2.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x * y * z = x * (y * z) ⊢ (y + x * y) * z = y * z + x * (y * z)"
                },
                {
                    "args": "nat_times_def_2, Suc x * y * z = Suc x * (y * z)",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x * y * z = x * (y * z) ⊢ Suc x * y * z = Suc x * (y * z)"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀x. x * y * z = x * (y * z) ⟶ Suc x * y * z = Suc x * (y * z)"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x * y * z = x * (y * z), x: x}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * y * z = x * (y * z)"
                }
            ],
            "prop": "x * y * z = x * (y * z)",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_1"
                },
                {
                    "goal_id": "2",
                    "method_name": "introduction",
                    "names": "x"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_2"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "theorem": "distrib_r"
                },
                {
                    "fact_ids": [
                        "2.1"
                    ],
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal_with_prev"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "mult_comm",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_times_def_1, 0 * y = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * y = 0"
                },
                {
                    "args": "mult_0_right, 0 * y = y * 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * y = y * 0"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * y = y * n ⟶ Suc n * y = y * Suc n"
                },
                {
                    "args": "x, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR x"
                },
                {
                    "args": "x * y = y * x",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "x * y = y * x ⊢ x * y = y * x"
                },
                {
                    "args": "mult_Suc_right, y + y * x = y * Suc x",
                    "id": "2.2",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ y + y * x = y * Suc x"
                },
                {
                    "args": "y + x * y = y * Suc x",
                    "id": "2.3",
                    "prevs": [
                        "2.1",
                        "2.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "x * y = y * x ⊢ y + x * y = y * Suc x"
                },
                {
                    "args": "nat_times_def_2, Suc x * y = y * Suc x",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x * y = y * x ⊢ Suc x * y = y * Suc x"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀x. x * y = y * x ⟶ Suc x * y = y * Suc x"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x * y = y * x, x: x}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * y = y * x"
                }
            ],
            "prop": "x * y = y * x",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "mult_0_right"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_1"
                },
                {
                    "goal_id": "2",
                    "method_name": "introduction",
                    "names": "x"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_times_def_2"
                },
                {
                    "fact_ids": [
                        "2.1"
                    ],
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "theorem": "mult_Suc_right"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "attributes": [
                "hint_backward",
                "hint_forward"
            ],
            "name": "add_cancel_left",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "",
                    "id": "0",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ 0 + y = 0 + z ⟶ y = z"
                },
                {
                    "args": "0 + y = 0 + z",
                    "id": "0.0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "0 + y = 0 + z ⊢ 0 + y = 0 + z"
                },
                {
                    "args": "nat_plus_def_1",
                    "id": "0.1",
                    "prevs": [
                        "0.0"
                    ],
                    "rule": "rewrite_fact",
                    "th": "0 + y = 0 + z ⊢ y = z"
                },
                {
                    "args": "",
                    "id": "0.2",
                    "prevs": [
                        "0.0",
                        "0.1"
                    ],
                    "rule": "intros",
                    "th": "⊢ 0 + y = 0 + z ⟶ y = z"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. (n + y = n + z ⟶ y = z) ⟶ Suc n + y = Suc n + z ⟶ y = z"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "n + y = n + z ⟶ y = z",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n + y = n + z ⟶ y = z ⊢ n + y = n + z ⟶ y = z"
                },
                {
                    "args": "Suc n + y = Suc n + z",
                    "id": "1.2",
                    "prevs": [],
                    "rule": "assume",
                    "th": "Suc n + y = Suc n + z ⊢ Suc n + y = Suc n + z"
                },
                {
                    "args": "nat_plus_def_2",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_fact",
                    "th": "Suc n + y = Suc n + z ⊢ Suc (n + y) = Suc (n + z)"
                },
                {
                    "args": "nat_Suc_inject",
                    "id": "1.4",
                    "prevs": [
                        "1.3"
                    ],
                    "rule": "apply_theorem",
                    "th": "n + y = n + z ⟶ y = z, Suc n + y = Suc n + z ⊢ n + y = n + z"
                },
                {
                    "args": "",
                    "id": "1.5",
                    "prevs": [
                        "1.1",
                        "1.4"
                    ],
                    "rule": "apply_fact",
                    "th": "n + y = n + z ⟶ y = z, Suc n + y = Suc n + z ⊢ y = z"
                },
                {
                    "args": "",
                    "id": "1.6",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.2",
                        "1.5"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. (n + y = n + z ⟶ y = z) ⟶ Suc n + y = Suc n + z ⟶ y = z"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x + y = x + z ⟶ y = z, x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + y = x + z ⟶ y = z"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [
                        "2"
                    ],
                    "rule": "intros",
                    "th": "⊢ x + y = x + z ⟶ y = z"
                }
            ],
            "prop": "x + y = x + z ⟶ y = z",
            "steps": [
                {
                    "fact_ids": [
                        "0"
                    ],
                    "goal_id": "1",
                    "method_name": "revert_intro"
                },
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "introduction"
                },
                {
                    "fact_ids": [
                        "0.0"
                    ],
                    "goal_id": "0.1",
                    "method_name": "rewrite_fact",
                    "sym": "false",
                    "theorem": "nat_plus_def_1"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "fact_ids": [
                        "1.1"
                    ],
                    "goal_id": "1.3",
                    "method_name": "apply_prev"
                },
                {
                    "fact_ids": [
                        "1.2"
                    ],
                    "goal_id": "1.3",
                    "method_name": "rewrite_fact",
                    "sym": "false",
                    "theorem": "nat_plus_def_2"
                },
                {
                    "goal_id": "1.4",
                    "method_name": "apply_backward_step",
                    "theorem": "nat_Suc_inject"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "attributes": [
                "hint_backward",
                "hint_forward"
            ],
            "name": "add_cancel_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "x + z = y + z",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "x + z = y + z ⊢ x + z = y + z"
                },
                {
                    "args": "add_comm",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_fact",
                    "th": "x + z = y + z ⊢ z + x = z + y"
                },
                {
                    "args": "add_cancel_left",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "apply_theorem",
                    "th": "x + z = y + z ⊢ x = y"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [
                        "0",
                        "2"
                    ],
                    "rule": "intros",
                    "th": "⊢ x + z = y + z ⟶ x = y"
                }
            ],
            "prop": "x + z = y + z ⟶ x = y",
            "steps": [
                {
                    "fact_ids": [
                        "0"
                    ],
                    "goal_id": "1",
                    "method_name": "rewrite_fact",
                    "theorem": "add_comm"
                },
                {
                    "fact_ids": [
                        "1"
                    ],
                    "goal_id": "2",
                    "method_name": "apply_backward_step",
                    "theorem": "add_cancel_left"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "add_right_eq_zero",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "x + y = x",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "x + y = x ⊢ x + y = x"
                },
                {
                    "args": "add_0_right, x + y = x + 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x + y = x ⊢ x + y = x + 0"
                },
                {
                    "args": "add_cancel_left",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "apply_theorem",
                    "th": "x + y = x ⊢ y = 0"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [
                        "0",
                        "2"
                    ],
                    "rule": "intros",
                    "th": "⊢ x + y = x ⟶ y = 0"
                }
            ],
            "prop": "x + y = x --> y = 0",
            "steps": [
                {
                    "goal": "x + y = x + 0",
                    "goal_id": "1",
                    "method_name": "cut"
                },
                {
                    "goal_id": "1",
                    "method_name": "rewrite_goal",
                    "theorem": "add_0_right"
                },
                {
                    "fact_ids": [
                        "1"
                    ],
                    "goal_id": "2",
                    "method_name": "apply_backward_step",
                    "theorem": "add_cancel_left"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "add_left_eq_zero",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "x + y = y",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "x + y = y ⊢ x + y = y"
                },
                {
                    "args": "nat_plus_def_1, x + y = 0 + y",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x + y = y ⊢ x + y = 0 + y"
                },
                {
                    "args": "add_cancel_right",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "apply_theorem",
                    "th": "x + y = y ⊢ x = 0"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [
                        "0",
                        "2"
                    ],
                    "rule": "intros",
                    "th": "⊢ x + y = y ⟶ x = 0"
                }
            ],
            "prop": "x + y = y --> x = 0",
            "steps": [
                {
                    "goal": "x + y = 0 + y",
                    "goal_id": "1",
                    "method_name": "cut"
                },
                {
                    "goal_id": "1",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_def_1"
                },
                {
                    "fact_ids": [
                        "1"
                    ],
                    "goal_id": "2",
                    "method_name": "apply_backward_step",
                    "theorem": "add_cancel_right"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "add_is_zero",
            "prop": "x + y = 0 --> x = 0 & y = 0",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "mult_nonzero",
            "prop": "x * y = 0 --> x = 0 | y = 0",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "depth": 0,
            "name": "Binary representation",
            "ty": "header"
        },
        {
            "attributes": [],
            "name": "bit0",
            "prop": "bit0 n = n + n",
            "ty": "def",
            "type": "nat ⇒ nat"
        },
        {
            "name": "bit1",
            "prop": "bit1 n = n + n + 1",
            "ty": "def",
            "type": "nat ⇒ nat"
        },
        {
            "name": "one_Suc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "Suc 1 = 1 + 1",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ Suc 1 = 1 + 1"
                },
                {
                    "args": "bit0_def, Suc 1 = bit0 1",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc 1 = bit0 1"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "intros",
                    "th": "⊢ Suc 1 = bit0 1"
                }
            ],
            "prop": "Suc 1 = bit0 1",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "",
                    "theorem": "bit0_def"
                },
                {
                    "goal_id": "0",
                    "method_name": "nat_norm"
                }
            ],
            "ty": "thm",
            "vars": {}
        },
        {
            "attributes": [
                "hint_rewrite",
                "hint_rewrite_sym"
            ],
            "name": "bit0_Suc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "Suc (n + n) = n + n + 1",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ Suc (n + n) = n + n + 1"
                },
                {
                    "args": "bit1_def, Suc (n + n) = bit1 n",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc (n + n) = bit1 n"
                },
                {
                    "args": "bit0_def, Suc (bit0 n) = bit1 n",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc (bit0 n) = bit1 n"
                }
            ],
            "prop": "Suc (bit0 n) = bit1 n",
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "bit1_Suc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "Suc (n + n + 1) = Suc n + Suc n",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ Suc (n + n + 1) = Suc n + Suc n"
                },
                {
                    "args": "bit1_def, Suc (bit1 n) = Suc n + Suc n",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc (bit1 n) = Suc n + Suc n"
                },
                {
                    "args": "bit0_def, Suc (bit1 n) = bit0 (Suc n)",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc (bit1 n) = bit0 (Suc n)"
                }
            ],
            "prop": "Suc (bit1 n) = bit0 (Suc n)",
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "name": "bit0_bit0_add",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "m + m + (n + n) = m + n + (m + n)",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ m + m + (n + n) = m + n + (m + n)"
                },
                {
                    "args": "bit0_def, bit0 m + bit0 n = bit0 (m + n)",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit0 m + bit0 n = bit0 (m + n)"
                }
            ],
            "prop": "bit0 m + bit0 n = bit0 (m + n)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_bit1_add",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "m + m + (n + n + 1) = m + n + (m + n) + 1",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ m + m + (n + n + 1) = m + n + (m + n) + 1"
                },
                {
                    "args": "bit1_def, m + m + bit1 n = bit1 (m + n)",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ m + m + bit1 n = bit1 (m + n)"
                },
                {
                    "args": "bit0_def, bit0 m + bit1 n = bit1 (m + n)",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit0 m + bit1 n = bit1 (m + n)"
                }
            ],
            "prop": "bit0 m + bit1 n = bit1 (m + n)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit1_bit0_add",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "m + m + 1 + (n + n) = m + n + (m + n) + 1",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ m + m + 1 + (n + n) = m + n + (m + n) + 1"
                },
                {
                    "args": "bit1_def, bit1 m + (n + n) = bit1 (m + n)",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m + (n + n) = bit1 (m + n)"
                },
                {
                    "args": "bit0_def, bit1 m + bit0 n = bit1 (m + n)",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m + bit0 n = bit1 (m + n)"
                }
            ],
            "prop": "bit1 m + bit0 n = bit1 (m + n)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit1_bit1_add",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "m + m + 1 + (n + n + 1) = Suc (m + n) + Suc (m + n)",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ m + m + 1 + (n + n + 1) = Suc (m + n) + Suc (m + n)"
                },
                {
                    "args": "bit1_def, bit1 m + bit1 n = Suc (m + n) + Suc (m + n)",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m + bit1 n = Suc (m + n) + Suc (m + n)"
                },
                {
                    "args": "bit0_def, bit1 m + bit1 n = bit0 (Suc (m + n))",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m + bit1 n = bit0 (Suc (m + n))"
                }
            ],
            "prop": "bit1 m + bit1 n = bit0 (Suc (m + n))",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_bit0_mult",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "(m + m) * (n + n) = m * n + m * n + (m * n + m * n)",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ (m + m) * (n + n) = m * n + m * n + (m * n + m * n)"
                },
                {
                    "args": "bit0_def, (m + m) * (n + n) = bit0 (m * n) + bit0 (m * n)",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ (m + m) * (n + n) = bit0 (m * n) + bit0 (m * n)"
                },
                {
                    "args": "bit0_def, bit0 m * bit0 n = bit0 (bit0 (m * n))",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit0 m * bit0 n = bit0 (bit0 (m * n))"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [
                        "2"
                    ],
                    "rule": "intros",
                    "th": "⊢ bit0 m * bit0 n = bit0 (bit0 (m * n))"
                }
            ],
            "prop": "bit0 m * bit0 n = bit0 (bit0 (m * n))",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "",
                    "theorem": "bit0_def"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "",
                    "theorem": "bit0_def"
                },
                {
                    "goal_id": "0",
                    "method_name": "nat_norm"
                }
            ],
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_bit1_mult",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "(m + m) * (n + n + 1) = m * (n + n + 1) + m * (n + n + 1)",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ (m + m) * (n + n + 1) = m * (n + n + 1) + m * (n + n + 1)"
                },
                {
                    "args": "bit1_def, (m + m) * bit1 n = m * bit1 n + m * bit1 n",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ (m + m) * bit1 n = m * bit1 n + m * bit1 n"
                },
                {
                    "args": "bit0_def, bit0 m * bit1 n = bit0 (m * bit1 n)",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit0 m * bit1 n = bit0 (m * bit1 n)"
                }
            ],
            "prop": "bit0 m * bit1 n = bit0 (m * bit1 n)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit1_bit0_mult",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "(m + m + 1) * (n + n) = (m + m + 1) * n + (m + m + 1) * n",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ (m + m + 1) * (n + n) = (m + m + 1) * n + (m + m + 1) * n"
                },
                {
                    "args": "bit1_def, bit1 m * (n + n) = bit1 m * n + bit1 m * n",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m * (n + n) = bit1 m * n + bit1 m * n"
                },
                {
                    "args": "bit0_def, bit1 m * bit0 n = bit0 (bit1 m * n)",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m * bit0 n = bit0 (bit1 m * n)"
                }
            ],
            "prop": "bit1 m * bit0 n = bit0 (bit1 m * n)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit1_bit1_mult",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "(m + m + 1) * (n + n + 1) = m + n + (m * n + m * n) + (m + n + (m * n + m * n)) + 1",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ (m + m + 1) * (n + n + 1) = m + n + (m * n + m * n) + (m + n + (m * n + m * n)) + 1"
                },
                {
                    "args": "bit1_def, bit1 m * bit1 n = bit1 (m + n + (m * n + m * n))",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m * bit1 n = bit1 (m + n + (m * n + m * n))"
                },
                {
                    "args": "bit0_def, bit1 m * bit1 n = bit1 (m + n + bit0 (m * n))",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m * bit1 n = bit1 (m + n + bit0 (m * n))"
                }
            ],
            "prop": "bit1 m * bit1 n = bit1 (m + n + bit0 (m * n))",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_nonzero",
            "prop": "~ m = 0 --> ~ (bit0 m = 0)",
            "ty": "thm",
            "vars": {
                "m": "nat"
            }
        },
        {
            "name": "bit1_nonzero",
            "prop": "~ bit1 m = 0",
            "ty": "thm",
            "vars": {
                "m": "nat"
            }
        },
        {
            "name": "one_nonzero",
            "prop": "~ (1::nat) = 0",
            "ty": "thm",
            "vars": {}
        },
        {
            "name": "bit0_neq",
            "prop": "~ m = n --> ~ bit0 m = bit0 n",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit1_neq",
            "prop": "~ m = n --> ~bit1 m = bit1 n",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_bit1_neq",
            "prop": "~ bit0 m = bit1 n",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_neq_one",
            "prop": "~ bit0 m = 1",
            "ty": "thm",
            "vars": {
                "m": "nat"
            }
        },
        {
            "name": "bit1_neq_one",
            "prop": "~ m = 0 --> ~ bit1 m = 1",
            "ty": "thm",
            "vars": {
                "m": "nat"
            }
        },
        {
            "depth": 0,
            "name": "Test of macros",
            "ty": "header"
        },
        {
            "name": "nat_norm_test1",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "x + y + (y + z) = y * 2 + (x + z)",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ x + y + (y + z) = y * 2 + (x + z)"
                }
            ],
            "prop": "(x + y) + (y + z) = y * 2 + (x + z)",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "name": "nat_const_ineq_test1",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "¬((12::nat) = 13)",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_const_ineq",
                    "th": "⊢ ¬((12::nat) = 13)"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "intros",
                    "th": "⊢ ¬((12::nat) = 13)"
                }
            ],
            "prop": "~ (12::nat) = 13",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "nat_const_ineq"
                }
            ],
            "ty": "thm",
            "vars": {}
        },
        {
            "name": "Sigma",
            "rules": [
                {
                    "prop": "Sigma f 0 = 0"
                },
                {
                    "prop": "Sigma f (Suc n) = Sigma f n + f n"
                }
            ],
            "ty": "def.ind",
            "type": "(nat => nat) => nat => nat"
        },
        {
            "name": "Sigma_plus",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "add_0_right, (0::nat) = 0 + 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ (0::nat) = 0 + 0"
                },
                {
                    "args": "Sigma_def_1, Sigma (λx. f x + g x) 0 = Sigma f 0 + Sigma g 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Sigma (λx. f x + g x) 0 = Sigma f 0 + Sigma g 0"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. Sigma (λx. f x + g x) n = Sigma f n + Sigma g n ⟶ Sigma (λx. f x + g x) (Suc n) = Sigma f (Suc n) + Sigma g (Suc n)"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "Sigma (λx. f x + g x) n = Sigma f n + Sigma g n",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "Sigma (λx. f x + g x) n = Sigma f n + Sigma g n ⊢ Sigma (λx. f x + g x) n = Sigma f n + Sigma g n"
                },
                {
                    "args": "Sigma f n + Sigma g n + (f n + g n) = Sigma f n + f n + (Sigma g n + g n)",
                    "id": "2.2",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ Sigma f n + Sigma g n + (f n + g n) = Sigma f n + f n + (Sigma g n + g n)"
                },
                {
                    "args": "Sigma (λx. f x + g x) n + (f n + g n) = Sigma f n + f n + (Sigma g n + g n)",
                    "id": "2.3",
                    "prevs": [
                        "2.1",
                        "2.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "Sigma (λx. f x + g x) n = Sigma f n + Sigma g n ⊢ Sigma (λx. f x + g x) n + (f n + g n) = Sigma f n + f n + (Sigma g n + g n)"
                },
                {
                    "args": "Sigma_def_2, Sigma (λx. f x + g x) (Suc n) = Sigma f (Suc n) + Sigma g (Suc n)",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "Sigma (λx. f x + g x) n = Sigma f n + Sigma g n ⊢ Sigma (λx. f x + g x) (Suc n) = Sigma f (Suc n) + Sigma g (Suc n)"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. Sigma (λx. f x + g x) n = Sigma f n + Sigma g n ⟶ Sigma (λx. f x + g x) (Suc n) = Sigma f (Suc n) + Sigma g (Suc n)"
                },
                {
                    "args": "nat_induct, {}, {P: λn. Sigma (λx. f x + g x) n = Sigma f n + Sigma g n, x: n}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ Sigma (λx. f x + g x) n = Sigma f n + Sigma g n"
                },
                {
                    "args": "",
                    "id": "4",
                    "prevs": [
                        "3"
                    ],
                    "rule": "intros",
                    "th": "⊢ Sigma (λx. f x + g x) n = Sigma f n + Sigma g n"
                }
            ],
            "prop": "Sigma (%x. f x + g x) n = Sigma f n + Sigma g n",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "n"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "Sigma_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "add_0_right"
                },
                {
                    "goal_id": "2",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "Sigma_def_2"
                },
                {
                    "fact_ids": [
                        "2.1"
                    ],
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "nat_norm"
                }
            ],
            "ty": "thm",
            "vars": {
                "f": "nat => nat",
                "g": "nat => nat",
                "n": "nat"
            }
        },
        {
            "ascii_op": "<=",
            "name": "less_eq",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a => 'a => bool"
        },
        {
            "ascii_op": "<",
            "name": "less",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a => 'a => bool"
        },
        {
            "ascii_op": ">=",
            "name": "greater_eq",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a => 'a => bool"
        },
        {
            "ascii_op": ">",
            "name": "greater",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a => 'a => bool"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "less_eq",
            "rules": [
                {
                    "prop": "m ≤ 0 ⟷ m = 0"
                },
                {
                    "prop": "m ≤ Suc n ⟷ m = Suc n ∨ m ≤ n"
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat => bool"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "less",
            "rules": [
                {
                    "prop": "m < 0 ⟷ false"
                },
                {
                    "prop": "m < Suc n ⟷ m = n ∨ m < n"
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat => bool"
        },
        {
            "name": "greater_eq",
            "prop": "greater_eq m n = less_eq n m",
            "ty": "def",
            "type": "nat ⇒ nat ⇒ bool"
        },
        {
            "name": "greater",
            "prop": "greater m n = less n m",
            "ty": "def",
            "type": "nat ⇒ nat ⇒ bool"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "lesseq_Suc_less",
            "num_gaps": 2,
            "proof": [
                {
                    "args": "",
                    "id": "0",
                    "prevs": [],
                    "rule": "sorry",
                    "th": "⊢ Suc m = 0 ⟷ false"
                },
                {
                    "args": "nat_less_eq_def_1, Suc m ≤ 0 ⟷ false",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc m ≤ 0 ⟷ false"
                },
                {
                    "args": "nat_less_def_1, Suc m ≤ 0 ⟷ m < 0",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc m ≤ 0 ⟷ m < 0"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [],
                    "rule": "sorry",
                    "th": "⊢ ∀n. Suc m ≤ n ⟷ m < n ⟶ Suc m ≤ Suc n ⟷ m < Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λn. Suc m ≤ n ⟷ m < n, x: n}",
                    "id": "4",
                    "prevs": [
                        "2",
                        "3"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ Suc m ≤ n ⟷ m < n"
                }
            ],
            "prop": "Suc m ≤ n ⟷ m < n",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "n"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_less_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_less_eq_def_1"
                }
            ],
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "less_Suc_lesseq",
            "num_gaps": 2,
            "proof": [
                {
                    "args": "",
                    "id": "0",
                    "prevs": [],
                    "rule": "sorry",
                    "th": "⊢ m = 0 ∨ false ⟷ m = 0"
                },
                {
                    "args": "nat_less_def_1, m = 0 ∨ m < 0 ⟷ m = 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ m = 0 ∨ m < 0 ⟷ m = 0"
                },
                {
                    "args": "nat_less_def_2, m < Suc 0 ⟷ m = 0",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ m < Suc 0 ⟷ m = 0"
                },
                {
                    "args": "nat_less_eq_def_1, m < Suc 0 ⟷ m ≤ 0",
                    "id": "3",
                    "prevs": [
                        "2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ m < Suc 0 ⟷ m ≤ 0"
                },
                {
                    "args": "",
                    "id": "4",
                    "prevs": [],
                    "rule": "sorry",
                    "th": "⊢ ∀n. m < Suc n ⟷ m ≤ n ⟶ m < Suc (Suc n) ⟷ m ≤ Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λn. m < Suc n ⟷ m ≤ n, x: n}",
                    "id": "5",
                    "prevs": [
                        "3",
                        "4"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ m < Suc n ⟷ m ≤ n"
                }
            ],
            "prop": "m < Suc n <--> m <= n",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "n"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_less_eq_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_less_def_2"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_less_def_1"
                }
            ],
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "le_suc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "less_Suc_lesseq, m < Suc n ⟷ m ≤ n",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ m < Suc n ⟷ m ≤ n"
                },
                {
                    "args": "lesseq_Suc_less, Suc m ≤ Suc n ⟷ m ≤ n",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc m ≤ Suc n ⟷ m ≤ n"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "intros",
                    "th": "⊢ Suc m ≤ Suc n ⟷ m ≤ n"
                }
            ],
            "prop": "(Suc m <= Suc n) <--> (m <= n)",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "lesseq_Suc_less"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "less_Suc_lesseq"
                }
            ],
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "lt_suc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "lesseq_Suc_less, Suc m ≤ n ⟷ m < n",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc m ≤ n ⟷ m < n"
                },
                {
                    "args": "less_Suc_lesseq, Suc m < Suc n ⟷ m < n",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc m < Suc n ⟷ m < n"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "intros",
                    "th": "⊢ Suc m < Suc n ⟷ m < n"
                }
            ],
            "prop": "Suc m < Suc n ⟷ m < n",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "less_Suc_lesseq"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "lesseq_Suc_less"
                }
            ],
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_backward",
                "hint_forward"
            ],
            "name": "lt_imp_le",
            "prop": "m < n --> m <= n",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_backward",
                "hint_forward"
            ],
            "name": "le_1_1",
            "prop": "¬(n = 0) ⟶ 0 < n",
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_backward",
                "hint_forward"
            ],
            "name": "le_1_2",
            "prop": "¬(n = 0) ⟶ 1 <= n",
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "less_eq_exist",
            "prop": "m ≤ n ⟷ (∃p. n = m + p)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "less_exist",
            "prop": "m<n <--> (?d. n = m+Suc d)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "less_lesseq",
            "prop": "less m n = (less_eq m n & ~(m = n))",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [],
            "name": "less_lesseqI",
            "prop": "m <= n --> ~m = n --> m < n",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_resolve",
                "hint_rewrite",
                "hint_backward"
            ],
            "name": "le_0",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_less_eq_def_1, (0::nat) ≤ 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ (0::nat) ≤ 0"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. 0 ≤ n ⟶ 0 ≤ Suc n"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "0 ≤ n",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "0 ≤ n ⊢ 0 ≤ n"
                },
                {
                    "args": "disjI2, {}, {A: 0 = Suc n, B: 0 ≤ n}",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "0 ≤ n ⊢ 0 = Suc n ∨ 0 ≤ n"
                },
                {
                    "args": "nat_less_eq_def_2, 0 ≤ Suc n",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "0 ≤ n ⊢ 0 ≤ Suc n"
                },
                {
                    "args": "",
                    "id": "1.4",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. 0 ≤ n ⟶ 0 ≤ Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λn::nat. 0 ≤ n, x: n}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ 0 ≤ n"
                }
            ],
            "prop": "0 ≤ n",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "n"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_less_eq_def_1"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_less_eq_def_2"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "apply_backward_step",
                    "theorem": "disjI2"
                }
            ],
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "attributes": [],
            "name": "less_0",
            "prop": "0 < Suc n",
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "less_eq_refl",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "n = n + 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ n = n + 0"
                },
                {
                    "args": "exI, {a: nat}, {P: λp. n = n + p, a: (0::nat)}",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ ∃a. n = n + a"
                },
                {
                    "args": "less_eq_exist, n ≤ n",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ n ≤ n"
                }
            ],
            "prop": "n ≤ n",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "less_eq_exist"
                },
                {
                    "goal_id": "0",
                    "method_name": "inst_exists_goal",
                    "s": "(0::nat)"
                },
                {
                    "goal_id": "0",
                    "method_name": "nat_norm"
                }
            ],
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "attributes": [],
            "name": "less_eq_trans",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "k ≤ m",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "k ≤ m ⊢ k ≤ m"
                },
                {
                    "args": "m ≤ n",
                    "id": "1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "m ≤ n ⊢ m ≤ n"
                },
                {
                    "args": "less_eq_exist",
                    "id": "2",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_fact",
                    "th": "k ≤ m ⊢ ∃p. m = k + p"
                },
                {
                    "args": "less_eq_exist",
                    "id": "3",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_fact",
                    "th": "m ≤ n ⊢ ∃p. n = m + p"
                },
                {
                    "args": "p, nat",
                    "id": "4",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR p"
                },
                {
                    "args": "m = k + p",
                    "id": "5",
                    "prevs": [],
                    "rule": "assume",
                    "th": "m = k + p ⊢ m = k + p"
                },
                {
                    "args": "q, nat",
                    "id": "6",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR q"
                },
                {
                    "args": "n = m + q",
                    "id": "7",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n = m + q ⊢ n = m + q"
                },
                {
                    "args": "k + p + q = k + (p + q)",
                    "id": "8",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ k + p + q = k + (p + q)"
                },
                {
                    "args": "m + q = k + (p + q)",
                    "id": "9",
                    "prevs": [
                        "5",
                        "8"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "m = k + p, k ≤ m, m ≤ n, n = m + q ⊢ m + q = k + (p + q)"
                },
                {
                    "args": "n = k + (p + q)",
                    "id": "10",
                    "prevs": [
                        "7",
                        "9"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n = m + q, k ≤ m, m ≤ n, m = k + p ⊢ n = k + (p + q)"
                },
                {
                    "args": "exI, {a: nat}, {P: λp. n = k + p, a: p + q}",
                    "id": "11",
                    "prevs": [
                        "10"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "k ≤ m, m ≤ n, m = k + p, n = m + q ⊢ ∃a. n = k + a"
                },
                {
                    "args": "less_eq_exist, k ≤ n",
                    "id": "12",
                    "prevs": [
                        "11"
                    ],
                    "rule": "rewrite_goal",
                    "th": "k ≤ m, m ≤ n, m = k + p, n = m + q ⊢ k ≤ n"
                },
                {
                    "args": "∃p. n = m + p, ∃p. m = k + p",
                    "id": "13",
                    "prevs": [
                        "0",
                        "1",
                        "2",
                        "4",
                        "5",
                        "3",
                        "6",
                        "7",
                        "12"
                    ],
                    "rule": "intros",
                    "th": "⊢ k ≤ m ⟶ m ≤ n ⟶ k ≤ n"
                }
            ],
            "prop": "k <= m --> m <= n --> k <= n",
            "steps": [
                {
                    "fact_ids": [
                        "0"
                    ],
                    "goal_id": "2",
                    "method_name": "rewrite_fact",
                    "theorem": "less_eq_exist"
                },
                {
                    "fact_ids": [
                        "1"
                    ],
                    "goal_id": "3",
                    "method_name": "rewrite_fact",
                    "theorem": "less_eq_exist"
                },
                {
                    "fact_ids": [
                        "2"
                    ],
                    "goal_id": "4",
                    "method_name": "exists_elim",
                    "names": "p"
                },
                {
                    "fact_ids": [
                        "3"
                    ],
                    "goal_id": "6",
                    "method_name": "exists_elim",
                    "names": "q"
                },
                {
                    "goal_id": "8",
                    "method_name": "rewrite_goal",
                    "theorem": "less_eq_exist"
                },
                {
                    "goal_id": "8",
                    "method_name": "inst_exists_goal",
                    "s": "p + q"
                },
                {
                    "fact_ids": [
                        "7"
                    ],
                    "goal_id": "8",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "fact_ids": [
                        "5"
                    ],
                    "goal_id": "8",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "goal_id": "8",
                    "method_name": "nat_norm"
                }
            ],
            "ty": "thm",
            "vars": {
                "k": "nat",
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "not_le",
            "num_gaps": 1,
            "proof": [
                {
                    "args": "",
                    "id": "0",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ¬((0::nat) = 0) ⟶ false"
                },
                {
                    "args": "¬((0::nat) = 0)",
                    "id": "0.0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "¬((0::nat) = 0) ⊢ ¬((0::nat) = 0)"
                },
                {
                    "args": "eq_refl, {a: nat}, {x: (0::nat)}",
                    "id": "0.1",
                    "prevs": [],
                    "rule": "apply_theorem_for",
                    "th": "⊢ (0::nat) = 0"
                },
                {
                    "args": "negE",
                    "id": "0.2",
                    "prevs": [
                        "0.0",
                        "0.1"
                    ],
                    "rule": "apply_theorem",
                    "th": "¬((0::nat) = 0) ⊢ false"
                },
                {
                    "args": "",
                    "id": "0.3",
                    "prevs": [
                        "0.0",
                        "0.2"
                    ],
                    "rule": "intros",
                    "th": "⊢ ¬((0::nat) = 0) ⟶ false"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ false ⟶ ¬((0::nat) = 0)"
                },
                {
                    "args": "false",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "false ⊢ false"
                },
                {
                    "args": "not_false_res, ¬((0::nat) = 0)",
                    "id": "1.1",
                    "prevs": [
                        "1.0"
                    ],
                    "rule": "resolve_theorem",
                    "th": "false ⊢ ¬((0::nat) = 0)"
                },
                {
                    "args": "",
                    "id": "1.2",
                    "prevs": [
                        "1.0",
                        "1.1"
                    ],
                    "rule": "intros",
                    "th": "⊢ false ⟶ ¬((0::nat) = 0)"
                },
                {
                    "args": "iffI",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem",
                    "th": "⊢ ¬((0::nat) = 0) ⟷ false"
                },
                {
                    "args": "nat_less_def_1, ¬((0::nat) = 0) ⟷ (0::nat) < 0",
                    "id": "3",
                    "prevs": [
                        "2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ ¬((0::nat) = 0) ⟷ (0::nat) < 0"
                },
                {
                    "args": "nat_less_eq_def_1, ¬((0::nat) ≤ 0) ⟷ (0::nat) < 0",
                    "id": "4",
                    "prevs": [
                        "3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ ¬((0::nat) ≤ 0) ⟷ (0::nat) < 0"
                },
                {
                    "args": "",
                    "id": "5",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. ¬(n ≤ 0) ⟷ 0 < n ⟶ ¬(Suc n ≤ 0) ⟷ 0 < Suc n"
                },
                {
                    "args": "n, nat",
                    "id": "5.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "¬(n ≤ 0) ⟷ 0 < n",
                    "id": "5.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "¬(n ≤ 0) ⟷ 0 < n ⊢ ¬(n ≤ 0) ⟷ 0 < n"
                },
                {
                    "args": "",
                    "id": "5.2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "¬(n ≤ 0) ⟷ 0 < n ⊢ ¬false ⟶ 0 ≤ n"
                },
                {
                    "args": "¬false",
                    "id": "5.2.0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "¬false ⊢ ¬false"
                },
                {
                    "args": "le_0, {}, {n: n}",
                    "id": "5.2.1",
                    "prevs": [],
                    "rule": "apply_theorem_for",
                    "th": "⊢ 0 ≤ n"
                },
                {
                    "args": "",
                    "id": "5.2.2",
                    "prevs": [
                        "5.2.0",
                        "5.2.1"
                    ],
                    "rule": "intros",
                    "th": "¬(n ≤ 0) ⟷ 0 < n ⊢ ¬false ⟶ 0 ≤ n"
                },
                {
                    "args": "",
                    "id": "5.3",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "¬(n ≤ 0) ⟷ 0 < n ⊢ 0 ≤ n ⟶ ¬false"
                },
                {
                    "args": "0 ≤ n",
                    "id": "5.3.0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "0 ≤ n ⊢ 0 ≤ n"
                },
                {
                    "args": "false ⟶ false",
                    "id": "5.3.1",
                    "prevs": [],
                    "rule": "trivial",
                    "th": "⊢ false ⟶ false"
                },
                {
                    "args": "negI",
                    "id": "5.3.2",
                    "prevs": [
                        "5.3.1"
                    ],
                    "rule": "apply_theorem",
                    "th": "¬(n ≤ 0) ⟷ 0 < n, 0 ≤ n ⊢ ¬false"
                },
                {
                    "args": "",
                    "id": "5.3.3",
                    "prevs": [
                        "5.3.0",
                        "5.3.2"
                    ],
                    "rule": "intros",
                    "th": "¬(n ≤ 0) ⟷ 0 < n ⊢ 0 ≤ n ⟶ ¬false"
                },
                {
                    "args": "iffI",
                    "id": "5.4",
                    "prevs": [
                        "5.2",
                        "5.3"
                    ],
                    "rule": "apply_theorem",
                    "th": "¬(n ≤ 0) ⟷ 0 < n ⊢ ¬false ⟷ 0 ≤ n"
                },
                {
                    "args": "nat_less_def_1, ¬(n < 0) ⟷ 0 ≤ n",
                    "id": "5.5",
                    "prevs": [
                        "5.4"
                    ],
                    "rule": "rewrite_goal",
                    "th": "¬(n ≤ 0) ⟷ 0 < n ⊢ ¬(n < 0) ⟷ 0 ≤ n"
                },
                {
                    "args": "lesseq_Suc_less, ¬(Suc n ≤ 0) ⟷ 0 ≤ n",
                    "id": "5.6",
                    "prevs": [
                        "5.5"
                    ],
                    "rule": "rewrite_goal",
                    "th": "¬(n ≤ 0) ⟷ 0 < n ⊢ ¬(Suc n ≤ 0) ⟷ 0 ≤ n"
                },
                {
                    "args": "less_Suc_lesseq, ¬(Suc n ≤ 0) ⟷ 0 < Suc n",
                    "id": "5.7",
                    "prevs": [
                        "5.6"
                    ],
                    "rule": "rewrite_goal",
                    "th": "¬(n ≤ 0) ⟷ 0 < n ⊢ ¬(Suc n ≤ 0) ⟷ 0 < Suc n"
                },
                {
                    "args": "",
                    "id": "5.8",
                    "prevs": [
                        "5.0",
                        "5.1",
                        "5.7"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. ¬(n ≤ 0) ⟷ 0 < n ⟶ ¬(Suc n ≤ 0) ⟷ 0 < Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λm::nat. ¬(m ≤ 0) ⟷ 0 < m, x: m}",
                    "id": "6",
                    "prevs": [
                        "4",
                        "5"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ ¬(m ≤ 0) ⟷ 0 < m"
                },
                {
                    "args": "",
                    "id": "7",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. ¬(0 ≤ n) ⟷ n < 0 ⟶ ¬(0 ≤ Suc n) ⟷ Suc n < 0"
                },
                {
                    "args": "n, nat",
                    "id": "7.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "¬(0 ≤ n) ⟷ n < 0",
                    "id": "7.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "¬(0 ≤ n) ⟷ n < 0 ⊢ ¬(0 ≤ n) ⟷ n < 0"
                },
                {
                    "args": "",
                    "id": "7.2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "¬(0 ≤ n) ⟷ n < 0 ⊢ ¬(0 ≤ Suc n) ⟶ false"
                },
                {
                    "args": "¬(0 ≤ Suc n)",
                    "id": "7.2.0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "¬(0 ≤ Suc n) ⊢ ¬(0 ≤ Suc n)"
                },
                {
                    "args": "le_0, {}, {n: Suc n}",
                    "id": "7.2.1",
                    "prevs": [],
                    "rule": "apply_theorem_for",
                    "th": "⊢ 0 ≤ Suc n"
                },
                {
                    "args": "negE",
                    "id": "7.2.2",
                    "prevs": [
                        "7.2.0",
                        "7.2.1"
                    ],
                    "rule": "apply_theorem",
                    "th": "¬(0 ≤ Suc n), ¬(0 ≤ n) ⟷ n < 0 ⊢ false"
                },
                {
                    "args": "",
                    "id": "7.2.3",
                    "prevs": [
                        "7.2.0",
                        "7.2.2"
                    ],
                    "rule": "intros",
                    "th": "¬(0 ≤ n) ⟷ n < 0 ⊢ ¬(0 ≤ Suc n) ⟶ false"
                },
                {
                    "args": "",
                    "id": "7.3",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "¬(0 ≤ n) ⟷ n < 0 ⊢ false ⟶ ¬(0 ≤ Suc n)"
                },
                {
                    "args": "false",
                    "id": "7.3.0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "false ⊢ false"
                },
                {
                    "args": "not_false_res, ¬(0 ≤ Suc n)",
                    "id": "7.3.1",
                    "prevs": [
                        "7.3.0"
                    ],
                    "rule": "resolve_theorem",
                    "th": "false ⊢ ¬(0 ≤ Suc n)"
                },
                {
                    "args": "",
                    "id": "7.3.2",
                    "prevs": [
                        "7.3.0",
                        "7.3.1"
                    ],
                    "rule": "intros",
                    "th": "¬(0 ≤ n) ⟷ n < 0 ⊢ false ⟶ ¬(0 ≤ Suc n)"
                },
                {
                    "args": "iffI",
                    "id": "7.4",
                    "prevs": [
                        "7.2",
                        "7.3"
                    ],
                    "rule": "apply_theorem",
                    "th": "¬(0 ≤ n) ⟷ n < 0 ⊢ ¬(0 ≤ Suc n) ⟷ false"
                },
                {
                    "args": "nat_less_def_1, ¬(0 ≤ Suc n) ⟷ Suc n < 0",
                    "id": "7.5",
                    "prevs": [
                        "7.4"
                    ],
                    "rule": "rewrite_goal",
                    "th": "¬(0 ≤ n) ⟷ n < 0 ⊢ ¬(0 ≤ Suc n) ⟷ Suc n < 0"
                },
                {
                    "args": "",
                    "id": "7.6",
                    "prevs": [
                        "7.0",
                        "7.1",
                        "7.5"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. ¬(0 ≤ n) ⟷ n < 0 ⟶ ¬(0 ≤ Suc n) ⟷ Suc n < 0"
                },
                {
                    "args": "",
                    "id": "8",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. (∀n1. ¬(n ≤ n1) ⟷ n1 < n ⟶ ¬(n ≤ Suc n1) ⟷ Suc n1 < n) ⟶ (∀n1. ¬(Suc n ≤ n1) ⟷ n1 < Suc n ⟶ ¬(Suc n ≤ Suc n1) ⟷ Suc n1 < Suc n)"
                },
                {
                    "args": "n, nat",
                    "id": "8.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "∀n1. ¬(n ≤ n1) ⟷ n1 < n ⟶ ¬(n ≤ Suc n1) ⟷ Suc n1 < n",
                    "id": "8.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "∀n1. ¬(n ≤ n1) ⟷ n1 < n ⟶ ¬(n ≤ Suc n1) ⟷ Suc n1 < n ⊢ ∀n1. ¬(n ≤ n1) ⟷ n1 < n ⟶ ¬(n ≤ Suc n1) ⟷ Suc n1 < n"
                },
                {
                    "args": "",
                    "id": "8.2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "∀n1. ¬(n ≤ n1) ⟷ n1 < n ⟶ ¬(n ≤ Suc n1) ⟷ Suc n1 < n ⊢ ∀n1. ¬(Suc n ≤ n1) ⟷ n1 < Suc n ⟶ ¬(Suc n ≤ Suc n1) ⟷ Suc n1 < Suc n"
                },
                {
                    "args": "m, nat",
                    "id": "8.2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR m"
                },
                {
                    "args": "¬(Suc n ≤ m) ⟷ m < Suc n",
                    "id": "8.2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "¬(Suc n ≤ m) ⟷ m < Suc n ⊢ ¬(Suc n ≤ m) ⟷ m < Suc n"
                },
                {
                    "args": "eq_sym_eq",
                    "id": "8.2.2",
                    "prevs": [
                        "8.1"
                    ],
                    "rule": "rewrite_fact",
                    "th": "∀n1. ¬(n ≤ n1) ⟷ n1 < n ⟶ ¬(n ≤ Suc n1) ⟷ Suc n1 < n ⊢ ∀n1. n1 < n ⟷ ¬(n ≤ n1) ⟶ Suc n1 < n ⟷ ¬(n ≤ Suc n1)"
                },
                {
                    "args": "",
                    "id": "8.2.3",
                    "prevs": [],
                    "rule": "sorry",
                    "th": "∀n1. ¬(n ≤ n1) ⟷ n1 < n ⟶ ¬(n ≤ Suc n1) ⟷ Suc n1 < n, ¬(Suc n ≤ m) ⟷ m < Suc n ⊢ ¬(Suc n ≤ Suc m) ⟷ Suc m < Suc n"
                },
                {
                    "args": "",
                    "id": "8.2.4",
                    "prevs": [
                        "8.2.0",
                        "8.2.1",
                        "8.2.3"
                    ],
                    "rule": "intros",
                    "th": "∀n1. ¬(n ≤ n1) ⟷ n1 < n ⟶ ¬(n ≤ Suc n1) ⟷ Suc n1 < n ⊢ ∀n1. ¬(Suc n ≤ n1) ⟷ n1 < Suc n ⟶ ¬(Suc n ≤ Suc n1) ⟷ Suc n1 < Suc n"
                },
                {
                    "args": "",
                    "id": "8.3",
                    "prevs": [
                        "8.0",
                        "8.1",
                        "8.2"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. (∀n1. ¬(n ≤ n1) ⟷ n1 < n ⟶ ¬(n ≤ Suc n1) ⟷ Suc n1 < n) ⟶ (∀n1. ¬(Suc n ≤ n1) ⟷ n1 < Suc n ⟶ ¬(Suc n ≤ Suc n1) ⟷ Suc n1 < Suc n)"
                },
                {
                    "args": "nat_induct, {}, {P: λm. ∀n. ¬(m ≤ n) ⟷ n < m ⟶ ¬(m ≤ Suc n) ⟷ Suc n < m, x: m}",
                    "id": "9",
                    "prevs": [
                        "7",
                        "8"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ ∀n. ¬(m ≤ n) ⟷ n < m ⟶ ¬(m ≤ Suc n) ⟷ Suc n < m"
                },
                {
                    "args": "nat_induct, {}, {P: λn. ¬(m ≤ n) ⟷ n < m, x: n}",
                    "id": "10",
                    "prevs": [
                        "6",
                        "9"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ ¬(m ≤ n) ⟷ n < m"
                },
                {
                    "args": "",
                    "id": "11",
                    "prevs": [
                        "10"
                    ],
                    "rule": "intros",
                    "th": "⊢ ¬(m ≤ n) ⟷ n < m"
                }
            ],
            "prop": "~(m<=n)<-->n<m",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "n"
                },
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "m"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "nat_less_eq_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "nat_less_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "apply_backward_step",
                    "theorem": "iffI"
                },
                {
                    "goal_id": "0",
                    "method_name": "introduction"
                },
                {
                    "fact_ids": [
                        "0.0"
                    ],
                    "goal_id": "0.1",
                    "method_name": "apply_backward_step",
                    "theorem": "negE"
                },
                {
                    "goal_id": "0.1",
                    "method_name": "apply_backward_step",
                    "theorem": "eq_refl"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction"
                },
                {
                    "fact_ids": [
                        "1.0"
                    ],
                    "goal_id": "1.1",
                    "method_name": "apply_resolve_step",
                    "theorem": "not_false_res"
                },
                {
                    "goal_id": "5",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "5.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "less_Suc_lesseq"
                },
                {
                    "goal_id": "5.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "lesseq_Suc_less"
                },
                {
                    "goal_id": "5.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "nat_less_def_1"
                },
                {
                    "goal_id": "5.2",
                    "method_name": "apply_backward_step",
                    "theorem": "iffI"
                },
                {
                    "goal_id": "5.2",
                    "method_name": "introduction"
                },
                {
                    "goal_id": "5.2.1",
                    "method_name": "apply_backward_step",
                    "theorem": "le_0"
                },
                {
                    "goal_id": "5.3",
                    "method_name": "introduction"
                },
                {
                    "goal_id": "5.3.1",
                    "method_name": "apply_backward_step",
                    "theorem": "negI"
                },
                {
                    "goal_id": "7",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "m"
                },
                {
                    "goal_id": "7",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "7.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "nat_less_def_1"
                },
                {
                    "goal_id": "7.2",
                    "method_name": "apply_backward_step",
                    "theorem": "iffI"
                },
                {
                    "goal_id": "7.2",
                    "method_name": "introduction"
                },
                {
                    "fact_ids": [
                        "7.2.0"
                    ],
                    "goal_id": "7.2.1",
                    "method_name": "apply_backward_step",
                    "theorem": "negE"
                },
                {
                    "goal_id": "7.2.1",
                    "method_name": "apply_backward_step",
                    "theorem": "le_0"
                },
                {
                    "goal_id": "7.3",
                    "method_name": "introduction"
                },
                {
                    "fact_ids": [
                        "7.3.0"
                    ],
                    "goal_id": "7.3.1",
                    "method_name": "apply_resolve_step",
                    "theorem": "not_false_res"
                },
                {
                    "goal_id": "8",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "8.2",
                    "method_name": "introduction",
                    "names": "m"
                },
                {
                    "fact_ids": [
                        "8.1"
                    ],
                    "goal_id": "8.2.2",
                    "method_name": "rewrite_fact",
                    "sym": "false",
                    "theorem": "eq_sym_eq"
                }
            ],
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_backward"
            ],
            "name": "le_add",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "less_eq_refl, {}, {n: m}",
                    "id": "0",
                    "prevs": [],
                    "rule": "apply_theorem_for",
                    "th": "⊢ m ≤ m"
                },
                {
                    "args": "add_0_right, m ≤ m + 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ m ≤ m + 0"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. m ≤ m + n ⟶ m ≤ m + Suc n"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "m ≤ m + n",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "m ≤ m + n ⊢ m ≤ m + n"
                },
                {
                    "args": "add_comm, m ≤ n + m",
                    "id": "2.2",
                    "prevs": [
                        "2.1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "m ≤ m + n ⊢ m ≤ n + m"
                },
                {
                    "args": "disjI2, {}, {A: m = Suc (n + m), B: m ≤ n + m}",
                    "id": "2.3",
                    "prevs": [
                        "2.2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "m ≤ m + n ⊢ m = Suc (n + m) ∨ m ≤ n + m"
                },
                {
                    "args": "nat_less_eq_def_2, m ≤ Suc (n + m)",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "m ≤ m + n ⊢ m ≤ Suc (n + m)"
                },
                {
                    "args": "nat_plus_def_2, m ≤ Suc n + m",
                    "id": "2.5",
                    "prevs": [
                        "2.4"
                    ],
                    "rule": "rewrite_goal",
                    "th": "m ≤ m + n ⊢ m ≤ Suc n + m"
                },
                {
                    "args": "add_comm, m ≤ m + Suc n",
                    "id": "2.6",
                    "prevs": [
                        "2.5"
                    ],
                    "rule": "rewrite_goal",
                    "th": "m ≤ m + n ⊢ m ≤ m + Suc n"
                },
                {
                    "args": "",
                    "id": "2.7",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.6"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. m ≤ m + n ⟶ m ≤ m + Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λn. m ≤ m + n, x: n}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ m ≤ m + n"
                },
                {
                    "args": "",
                    "id": "4",
                    "prevs": [
                        "3"
                    ],
                    "rule": "intros",
                    "th": "⊢ m ≤ m + n"
                }
            ],
            "prop": "m <= m + n",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "n"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "add_0_right"
                },
                {
                    "goal_id": "0",
                    "method_name": "apply_backward_step",
                    "theorem": "less_eq_refl"
                },
                {
                    "goal_id": "2",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "add_comm"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "nat_plus_def_2"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "nat_less_eq_def_2"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "apply_backward_step",
                    "theorem": "disjI2"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "add_comm"
                }
            ],
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite",
                "hint_rewrite_sym"
            ],
            "name": "lt_add",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_plus_def_1, 0 < 0 + n ⟷ 0 < n",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 < 0 + n ⟷ 0 < n"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n1. n1 < n1 + n ⟷ 0 < n ⟶ Suc n1 < Suc n1 + n ⟷ 0 < n"
                },
                {
                    "args": "m, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR m"
                },
                {
                    "args": "m < m + n ⟷ 0 < n",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "m < m + n ⟷ 0 < n ⊢ m < m + n ⟷ 0 < n"
                },
                {
                    "args": "eq_sym_eq",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "rewrite_fact",
                    "th": "m < m + n ⟷ 0 < n ⊢ 0 < n ⟷ m < m + n"
                },
                {
                    "args": "lesseq_Suc_less, Suc m ≤ m + n ⟷ m < m + n",
                    "id": "1.3",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc m ≤ m + n ⟷ m < m + n"
                },
                {
                    "args": "less_Suc_lesseq, Suc m < Suc (m + n) ⟷ m < m + n",
                    "id": "1.4",
                    "prevs": [
                        "1.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "m < m + n ⟷ 0 < n ⊢ Suc m < Suc (m + n) ⟷ m < m + n"
                },
                {
                    "args": "Suc m < Suc (m + n) ⟷ 0 < n",
                    "id": "1.5",
                    "prevs": [
                        "1.2",
                        "1.4"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "m < m + n ⟷ 0 < n ⊢ Suc m < Suc (m + n) ⟷ 0 < n"
                },
                {
                    "args": "nat_plus_def_2, Suc m < Suc m + n ⟷ 0 < n",
                    "id": "1.6",
                    "prevs": [
                        "1.5"
                    ],
                    "rule": "rewrite_goal",
                    "th": "m < m + n ⟷ 0 < n ⊢ Suc m < Suc m + n ⟷ 0 < n"
                },
                {
                    "args": "",
                    "id": "1.7",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.6"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n1. n1 < n1 + n ⟷ 0 < n ⟶ Suc n1 < Suc n1 + n ⟷ 0 < n"
                },
                {
                    "args": "nat_induct, {}, {P: λm. m < m + n ⟷ 0 < n, x: m}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ m < m + n ⟷ 0 < n"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [
                        "2"
                    ],
                    "rule": "intros",
                    "th": "⊢ m < m + n ⟷ 0 < n"
                }
            ],
            "prop": "(m < m + n) <--> (0 < n)",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "m"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "nat_plus_def_1"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction",
                    "names": "m"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "nat_plus_def_2"
                },
                {
                    "fact_ids": [
                        "1.1"
                    ],
                    "goal_id": "1.2",
                    "method_name": "rewrite_fact",
                    "sym": "false",
                    "theorem": "eq_sym_eq"
                },
                {
                    "fact_ids": [
                        "1.2"
                    ],
                    "goal_id": "1.3",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "goal_id": "1.3",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "less_Suc_lesseq"
                },
                {
                    "goal_id": "1.3",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "lesseq_Suc_less"
                }
            ],
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "minus",
            "rules": [
                {
                    "prop": "n - 0 = n"
                },
                {
                    "prop": "n - Suc m = Pre (n - m)"
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat => nat"
        },
        {
            "name": "nat_minus_0",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_minus_def_1, minus 0 0 = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ minus 0 0 = 0"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. minus 0 n = 0 ⟶ minus 0 (Suc n) = 0"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "minus 0 n = 0",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "minus 0 n = 0 ⊢ minus 0 n = 0"
                },
                {
                    "args": "Pre_def_1, Pre 0 = 0",
                    "id": "1.2",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ Pre 0 = 0"
                },
                {
                    "args": "Pre (minus 0 n) = 0",
                    "id": "1.3",
                    "prevs": [
                        "1.1",
                        "1.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "minus 0 n = 0 ⊢ Pre (minus 0 n) = 0"
                },
                {
                    "args": "nat_minus_def_2, minus 0 (Suc n) = 0",
                    "id": "1.4",
                    "prevs": [
                        "1.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "minus 0 n = 0 ⊢ minus 0 (Suc n) = 0"
                },
                {
                    "args": "",
                    "id": "1.5",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. minus 0 n = 0 ⟶ minus 0 (Suc n) = 0"
                },
                {
                    "args": "nat_induct, {}, {P: λx. minus 0 x = 0, x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ minus 0 x = 0"
                },
                {
                    "args": "eq_refl, {a: nat}, {x: x}",
                    "id": "3",
                    "prevs": [],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x = x"
                },
                {
                    "args": "conjI",
                    "id": "4",
                    "prevs": [
                        "2",
                        "3"
                    ],
                    "rule": "apply_theorem",
                    "th": "⊢ minus 0 x = 0 ∧ x = x"
                },
                {
                    "args": "nat_minus_def_1, minus 0 x = 0 ∧ minus x 0 = x",
                    "id": "5",
                    "prevs": [
                        "4"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ minus 0 x = 0 ∧ minus x 0 = x"
                }
            ],
            "prop": "minus 0 x = 0 & minus x 0 = x",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_minus_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "apply_backward_step",
                    "theorem": "conjI"
                },
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_minus_def_1"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_minus_def_2"
                },
                {
                    "fact_ids": [
                        "1.1"
                    ],
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal",
                    "theorem": "Pre_def_1"
                },
                {
                    "goal_id": "3",
                    "method_name": "apply_backward_step",
                    "theorem": "eq_refl"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "name": "nat_minus_presuc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "Pre_def_2, Pre (Suc x) = x",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ Pre (Suc x) = x"
                },
                {
                    "args": "nat_minus_def_1, Pre (minus (Suc x) 0) = minus x 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Pre (minus (Suc x) 0) = minus x 0"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. Pre (minus (Suc x) n) = minus x n ⟶ Pre (minus (Suc x) (Suc n)) = minus x (Suc n)"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "Pre (minus (Suc x) n) = minus x n",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "Pre (minus (Suc x) n) = minus x n ⊢ Pre (minus (Suc x) n) = minus x n"
                },
                {
                    "args": "Pre (Pre (minus (Suc x) n)) = Pre (minus x n)",
                    "id": "2.2",
                    "prevs": [
                        "2.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "Pre (minus (Suc x) n) = minus x n ⊢ Pre (Pre (minus (Suc x) n)) = Pre (minus x n)"
                },
                {
                    "args": "nat_minus_def_2, Pre (minus (Suc x) (Suc n)) = minus x (Suc n)",
                    "id": "2.3",
                    "prevs": [
                        "2.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "Pre (minus (Suc x) n) = minus x n ⊢ Pre (minus (Suc x) (Suc n)) = minus x (Suc n)"
                },
                {
                    "args": "",
                    "id": "2.4",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. Pre (minus (Suc x) n) = minus x n ⟶ Pre (minus (Suc x) (Suc n)) = minus x (Suc n)"
                },
                {
                    "args": "nat_induct, {}, {P: λy. Pre (minus (Suc x) y) = minus x y, x: y}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ Pre (minus (Suc x) y) = minus x y"
                }
            ],
            "prop": "Pre (minus (Suc x) y) = minus x y",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "y"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_minus_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "Pre_def_2"
                },
                {
                    "goal_id": "2",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_minus_def_2"
                },
                {
                    "fact_ids": [
                        "2.1"
                    ],
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal_with_prev"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "nat_minus_suc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "Pre_def_2, Pre (Suc x) = x",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ Pre (Suc x) = x"
                },
                {
                    "args": "nat_minus_def_1, Pre (minus (Suc x) 0) = minus x 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Pre (minus (Suc x) 0) = minus x 0"
                },
                {
                    "args": "nat_minus_def_2, minus (Suc x) 1 = minus x 0",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ minus (Suc x) 1 = minus x 0"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. minus (Suc x) (Suc n) = minus x n ⟶ minus (Suc x) (Suc (Suc n)) = minus x (Suc n)"
                },
                {
                    "args": "n, nat",
                    "id": "3.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "minus (Suc x) (Suc n) = minus x n",
                    "id": "3.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "minus (Suc x) (Suc n) = minus x n ⊢ minus (Suc x) (Suc n) = minus x n"
                },
                {
                    "args": "nat_minus_presuc, Pre (Pre (minus (Suc x) n)) = Pre (minus x n)",
                    "id": "3.2",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ Pre (Pre (minus (Suc x) n)) = Pre (minus x n)"
                },
                {
                    "args": "nat_minus_def_2, minus (Suc x) (Suc (Suc n)) = minus x (Suc n)",
                    "id": "3.3",
                    "prevs": [
                        "3.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "minus (Suc x) (Suc n) = minus x n ⊢ minus (Suc x) (Suc (Suc n)) = minus x (Suc n)"
                },
                {
                    "args": "",
                    "id": "3.4",
                    "prevs": [
                        "3.0",
                        "3.1",
                        "3.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. minus (Suc x) (Suc n) = minus x n ⟶ minus (Suc x) (Suc (Suc n)) = minus x (Suc n)"
                },
                {
                    "args": "nat_induct, {}, {P: λy. minus (Suc x) (Suc y) = minus x y, x: y}",
                    "id": "4",
                    "prevs": [
                        "2",
                        "3"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ minus (Suc x) (Suc y) = minus x y"
                }
            ],
            "prop": "minus (Suc x) (Suc y) = minus x y",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "y"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_minus_def_2"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_minus_def_1"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "Pre_def_2"
                },
                {
                    "goal_id": "3",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "3.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_minus_def_2"
                },
                {
                    "goal_id": "3.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_minus_presuc"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "nat_minus_refl",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_minus_def_1, minus 0 0 = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ minus 0 0 = 0"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. minus n n = 0 ⟶ minus (Suc n) (Suc n) = 0"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "minus n n = 0",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "minus n n = 0 ⊢ minus n n = 0"
                },
                {
                    "args": "nat_minus_suc, minus (Suc n) (Suc n) = 0",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "minus n n = 0 ⊢ minus (Suc n) (Suc n) = 0"
                },
                {
                    "args": "",
                    "id": "1.3",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.2"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. minus n n = 0 ⟶ minus (Suc n) (Suc n) = 0"
                },
                {
                    "args": "nat_induct, {}, {P: λx. minus x x = 0, x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ minus x x = 0"
                }
            ],
            "prop": "minus x x = 0",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "x"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_minus_def_1"
                },
                {
                    "goal_id": "1",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "1.2",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_minus_suc"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "name": "nat_plus_minus",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_minus_def_1, x - 0 = x",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ x - 0 = x"
                },
                {
                    "args": "add_0_right, x + 0 - 0 = x",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ x + 0 - 0 = x"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. x + n - n = x ⟶ x + Suc n - Suc n = x"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "x + n - n = x",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "x + n - n = x ⊢ x + n - n = x"
                },
                {
                    "args": "nat_minus_suc, Suc (x + n) - Suc n = x",
                    "id": "2.2",
                    "prevs": [
                        "2.1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x + n - n = x ⊢ Suc (x + n) - Suc n = x"
                },
                {
                    "args": "add_Suc_right, x + Suc n - Suc n = x",
                    "id": "2.3",
                    "prevs": [
                        "2.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "x + n - n = x ⊢ x + Suc n - Suc n = x"
                },
                {
                    "args": "",
                    "id": "2.4",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. x + n - n = x ⟶ x + Suc n - Suc n = x"
                },
                {
                    "args": "nat_induct, {}, {P: λy. x + y - y = x, x: y}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + y - y = x"
                }
            ],
            "prop": "minus (x + y) y = x",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "y"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "add_0_right"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "nat_minus_def_1"
                },
                {
                    "goal_id": "2",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "sym": "",
                    "theorem": "add_Suc_right"
                },
                {
                    "goal_id": "2.2",
                    "method_name": "rewrite_goal",
                    "sym": "",
                    "theorem": "nat_minus_suc"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "nat_plus_minus_2",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "nat_plus_minus, minus (y + x) x = y",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ minus (y + x) x = y"
                },
                {
                    "args": "add_comm, minus (x + y) x = y",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ minus (x + y) x = y"
                }
            ],
            "prop": "x + y - x = y",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "add_comm"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_plus_minus"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite_sym",
                "hint_rewrite"
            ],
            "name": "sub_eq_0",
            "prop": "x - y = 0 ⟷ x ≤ y",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "add_subr2",
            "prop": "minus x (x + y) = 0",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "add_subr",
            "prop": "y - (x + y) = 0",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "attributes": [
                "hint_backward",
                "hint_forward"
            ],
            "name": "sub_add",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "y ≤ x",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "y ≤ x ⊢ y ≤ x"
                },
                {
                    "args": "less_eq_exist",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_fact",
                    "th": "y ≤ x ⊢ ∃p. x = y + p"
                },
                {
                    "args": "p, nat",
                    "id": "2",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR p"
                },
                {
                    "args": "x = y + p",
                    "id": "3",
                    "prevs": [],
                    "rule": "assume",
                    "th": "x = y + p ⊢ x = y + p"
                },
                {
                    "args": "nat_plus_minus_2, y + (y + p - y) = y + p",
                    "id": "4",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ y + (y + p - y) = y + p"
                },
                {
                    "args": "y + (x - y) = x",
                    "id": "5",
                    "prevs": [
                        "3",
                        "4"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "x = y + p, y ≤ x ⊢ y + (x - y) = x"
                },
                {
                    "args": "add_comm, x - y + y = x",
                    "id": "6",
                    "prevs": [
                        "5"
                    ],
                    "rule": "rewrite_goal",
                    "th": "y ≤ x, x = y + p ⊢ x - y + y = x"
                },
                {
                    "args": "∃p. x = y + p",
                    "id": "7",
                    "prevs": [
                        "0",
                        "1",
                        "2",
                        "3",
                        "6"
                    ],
                    "rule": "intros",
                    "th": "⊢ y ≤ x ⟶ x - y + y = x"
                }
            ],
            "prop": "y <= x --> ((x - y) + y = x)",
            "steps": [
                {
                    "fact_ids": [
                        "0"
                    ],
                    "goal_id": "1",
                    "method_name": "rewrite_fact",
                    "sym": "false",
                    "theorem": "less_eq_exist"
                },
                {
                    "goal_id": "2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "add_comm"
                },
                {
                    "fact_ids": [
                        "1"
                    ],
                    "goal_id": "2",
                    "method_name": "exists_elim",
                    "names": "p"
                },
                {
                    "fact_ids": [
                        "3"
                    ],
                    "goal_id": "4",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "goal_id": "4",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "nat_plus_minus_2"
                }
            ],
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "max",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a => 'a => 'a"
        },
        {
            "name": "max",
            "prop": "max m n = if m <= n then n else m",
            "ty": "def",
            "type": "nat ⇒ nat ⇒ nat"
        },
        {
            "name": "min",
            "overloaded": true,
            "ty": "def.ax",
            "type": "'a => 'a => 'a"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "min",
            "prop": "min m n = (if m ≤ n then m else n)",
            "ty": "def",
            "type": "nat ⇒ nat ⇒ nat"
        },
        {
            "attributes": [],
            "name": "min_simp1",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "m ≤ n",
                    "id": "0",
                    "prevs": [],
                    "rule": "assume",
                    "th": "m ≤ n ⊢ m ≤ n"
                },
                {
                    "args": "if_P, (if m ≤ n then m else n) = m",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "m ≤ n ⊢ (if m ≤ n then m else n) = m"
                },
                {
                    "args": "nat_min_def, min m n = m",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "m ≤ n ⊢ min m n = m"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [
                        "0",
                        "2"
                    ],
                    "rule": "intros",
                    "th": "⊢ m ≤ n ⟶ min m n = m"
                }
            ],
            "prop": "m ≤ n ⟶ min m n = m",
            "steps": [
                {
                    "goal_id": "1",
                    "method_name": "rewrite_goal",
                    "theorem": "nat_min_def"
                },
                {
                    "fact_ids": [
                        "0"
                    ],
                    "goal_id": "1",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "if_P"
                }
            ],
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "even",
            "rules": [
                {
                    "prop": "even 0 ⟷ true"
                },
                {
                    "prop": "even (Suc n) ⟷ ¬(even n)"
                }
            ],
            "ty": "def.ind",
            "type": "nat => bool"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "odd",
            "rules": [
                {
                    "prop": "odd 0 ⟷ false"
                },
                {
                    "prop": "odd (Suc n) ⟷ ¬(odd n)"
                }
            ],
            "ty": "def.ind",
            "type": "nat => bool"
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "arith_even1",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "even_def_1, even 0 ⟷ true",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ even 0 ⟷ true"
                },
                {
                    "args": "add_0_right, even (0 + 0) ⟷ true",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ even (0 + 0) ⟷ true"
                },
                {
                    "args": "bit0_def, even (bit0 0) ⟷ true",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ even (bit0 0) ⟷ true"
                },
                {
                    "args": "",
                    "id": "3",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. even (bit0 n) ⟷ true ⟶ even (bit0 (Suc n)) ⟷ true"
                },
                {
                    "args": "n, nat",
                    "id": "3.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ _VAR n"
                },
                {
                    "args": "even (bit0 n) ⟷ true",
                    "id": "3.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "even (bit0 n) ⟷ true ⊢ even (bit0 n) ⟷ true"
                },
                {
                    "args": "bit0_def",
                    "id": "3.2",
                    "prevs": [
                        "3.1"
                    ],
                    "rule": "rewrite_fact",
                    "th": "even (bit0 n) ⟷ true ⊢ even (n + n) ⟷ true"
                },
                {
                    "args": "double_neg, ¬¬true ⟷ true",
                    "id": "3.3",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ ¬¬true ⟷ true"
                },
                {
                    "args": "¬¬(even (n + n)) ⟷ true",
                    "id": "3.4",
                    "prevs": [
                        "3.2",
                        "3.3"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "even (bit0 n) ⟷ true ⊢ ¬¬(even (n + n)) ⟷ true"
                },
                {
                    "args": "even_def_2, ¬(even (Suc (n + n))) ⟷ true",
                    "id": "3.5",
                    "prevs": [
                        "3.4"
                    ],
                    "rule": "rewrite_goal",
                    "th": "even (bit0 n) ⟷ true ⊢ ¬(even (Suc (n + n))) ⟷ true"
                },
                {
                    "args": "nat_plus_def_2, ¬(even (Suc n + n)) ⟷ true",
                    "id": "3.6",
                    "prevs": [
                        "3.5"
                    ],
                    "rule": "rewrite_goal",
                    "th": "even (bit0 n) ⟷ true ⊢ ¬(even (Suc n + n)) ⟷ true"
                },
                {
                    "args": "even_def_2, even (Suc (Suc n + n)) ⟷ true",
                    "id": "3.7",
                    "prevs": [
                        "3.6"
                    ],
                    "rule": "rewrite_goal",
                    "th": "even (bit0 n) ⟷ true ⊢ even (Suc (Suc n + n)) ⟷ true"
                },
                {
                    "args": "add_Suc_right, even (Suc n + Suc n) ⟷ true",
                    "id": "3.8",
                    "prevs": [
                        "3.7"
                    ],
                    "rule": "rewrite_goal",
                    "th": "even (bit0 n) ⟷ true ⊢ even (Suc n + Suc n) ⟷ true"
                },
                {
                    "args": "bit0_def, even (bit0 (Suc n)) ⟷ true",
                    "id": "3.9",
                    "prevs": [
                        "3.8"
                    ],
                    "rule": "rewrite_goal",
                    "th": "even (bit0 n) ⟷ true ⊢ even (bit0 (Suc n)) ⟷ true"
                },
                {
                    "args": "",
                    "id": "3.10",
                    "prevs": [
                        "3.0",
                        "3.1",
                        "3.9"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. even (bit0 n) ⟷ true ⟶ even (bit0 (Suc n)) ⟷ true"
                },
                {
                    "args": "nat_induct, {}, {P: λn. even (bit0 n) ⟷ true, x: n}",
                    "id": "4",
                    "prevs": [
                        "2",
                        "3"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ even (bit0 n) ⟷ true"
                },
                {
                    "args": "",
                    "id": "5",
                    "prevs": [
                        "4"
                    ],
                    "rule": "intros",
                    "th": "⊢ even (bit0 n) ⟷ true"
                }
            ],
            "prop": "even (bit0 n) = true",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "induction",
                    "theorem": "nat_induct",
                    "var": "n"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "bit0_def"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "add_0_right"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "even_def_1"
                },
                {
                    "goal_id": "3",
                    "method_name": "introduction",
                    "names": "n"
                },
                {
                    "goal_id": "3.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "bit0_def"
                },
                {
                    "goal_id": "3.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "add_Suc_right"
                },
                {
                    "goal_id": "3.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "even_def_2"
                },
                {
                    "goal_id": "3.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "nat_plus_def_2"
                },
                {
                    "goal_id": "3.2",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "even_def_2"
                },
                {
                    "fact_ids": [
                        "3.1"
                    ],
                    "goal_id": "3.2",
                    "method_name": "rewrite_fact",
                    "sym": "false",
                    "theorem": "bit0_def"
                },
                {
                    "fact_ids": [
                        "3.2"
                    ],
                    "goal_id": "3.3",
                    "method_name": "rewrite_goal_with_prev"
                },
                {
                    "goal_id": "3.3",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "double_neg"
                }
            ],
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "attributes": [
                "hint_rewrite"
            ],
            "name": "arith_even2",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "¬true ⟷ false",
                    "id": "0",
                    "prevs": [],
                    "rule": "z3",
                    "th": "⊢ ¬true ⟷ false"
                },
                {
                    "args": "arith_even1, ¬(even (bit0 n)) ⟷ false",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ ¬(even (bit0 n)) ⟷ false"
                },
                {
                    "args": "even_def_2, even (Suc (bit0 n)) ⟷ false",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ even (Suc (bit0 n)) ⟷ false"
                },
                {
                    "args": "bit0_Suc, even (bit1 n) ⟷ false",
                    "id": "3",
                    "prevs": [
                        "2"
                    ],
                    "rule": "rewrite_goal_sym",
                    "th": "⊢ even (bit1 n) ⟷ false"
                },
                {
                    "args": "",
                    "id": "4",
                    "prevs": [
                        "3"
                    ],
                    "rule": "intros",
                    "th": "⊢ even (bit1 n) ⟷ false"
                }
            ],
            "prop": "even (bit1 n) ⟷ false",
            "steps": [
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "true",
                    "theorem": "bit0_Suc"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "even_def_2"
                },
                {
                    "goal_id": "0",
                    "method_name": "rewrite_goal",
                    "sym": "false",
                    "theorem": "arith_even1"
                },
                {
                    "goal_id": "0",
                    "method_name": "z3"
                }
            ],
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "name": "nat_divide",
            "ty": "def.ax",
            "type": "nat => nat => nat"
        },
        {
            "name": "nat_modulus",
            "ty": "def.ax",
            "type": "nat => nat => nat"
        },
        {
            "name": "fact",
            "rules": [
                {
                    "prop": "fact 0 = 1"
                },
                {
                    "prop": "fact (Suc n) = (Suc n) * fact n"
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat"
        }
    ],
    "description": "Natural numbers",
    "imports": [
        "logic"
    ],
    "name": "nat"
}