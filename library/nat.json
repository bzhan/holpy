{
    "content": [
        {
            "depth": 0,
            "name": "Basic definitions",
            "ty": "header"
        },
        {
            "args": [],
            "constrs": [
                {
                    "args": [],
                    "name": "zero",
                    "type": "nat"
                },
                {
                    "args": [
                        "n"
                    ],
                    "name": "Suc",
                    "type": "nat => nat"
                }
            ],
            "name": "nat",
            "ty": "type.ind"
        },
        {
            "ascii_op": "+",
            "name": "plus",
            "rules": [
                {
                    "prop": "0 + n = n"
                },
                {
                    "prop": "Suc m + n = Suc (m + n)"
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat => nat"
        },
        {
            "ascii_op": "*",
            "name": "times",
            "rules": [
                {
                    "prop": "0 * n = 0"
                },
                {
                    "prop": "Suc m * n = n + m * n"
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat => nat"
        },
        {
            "name": "nat_norm",
            "ty": "macro"
        },
        {
            "name": "nat_norm",
            "ty": "method"
        },
        {
            "hint_rewrite": "true",
            "instructions": [
                "Select 0 as goal, choose 'apply induction' from menu, then enter 'nat_induct,x'.",
                "Select 0 as goal, use Ctrl+R with plus_def_1.",
                "Set sorry on 0 to reflexive 0.",
                "Select 2 as goal, use Ctrl+I with n as variable name.",
                "Select 2.2 as goal, use Ctrl+R with plus_def_2.",
                "Set sorry on 2.2 to arg_combination Suc from 2.1."
            ],
            "name": "add_0_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "plus_def_1, 0 + 0 = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 + 0 = 0"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n + 0 = n ⟶ Suc n + 0 = Suc n"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "n + 0 = n",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n + 0 = n ⊢ n + 0 = n"
                },
                {
                    "args": "Suc (n + 0) = Suc n",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n + 0 = n ⊢ Suc (n + 0) = Suc n"
                },
                {
                    "args": "plus_def_2, Suc n + 0 = Suc n",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n + 0 = n ⊢ Suc n + 0 = Suc n"
                },
                {
                    "args": "",
                    "id": "1.4",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n + 0 = n ⟶ Suc n + 0 = Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x + 0 = x, x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + 0 = x"
                }
            ],
            "prop": "x + 0 = x",
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "name": "add_1_left",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "plus_def_1, Suc (0 + x) = Suc x",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc (0 + x) = Suc x"
                },
                {
                    "args": "plus_def_2, 1 + x = Suc x",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 1 + x = Suc x"
                }
            ],
            "prop": "1 + x = Suc x",
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "name": "add_1_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "plus_def_1, 0 + 1 = 1",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 + 1 = 1"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n + 1 = Suc n ⟶ Suc n + 1 = Suc (Suc n)"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "n + 1 = Suc n",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n + 1 = Suc n ⊢ n + 1 = Suc n"
                },
                {
                    "args": "Suc (n + 1) = Suc (Suc n)",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n + 1 = Suc n ⊢ Suc (n + 1) = Suc (Suc n)"
                },
                {
                    "args": "plus_def_2, Suc n + 1 = Suc (Suc n)",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n + 1 = Suc n ⊢ Suc n + 1 = Suc (Suc n)"
                },
                {
                    "args": "",
                    "id": "1.4",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n + 1 = Suc n ⟶ Suc n + 1 = Suc (Suc n)"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x + 1 = Suc x, x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + 1 = Suc x"
                }
            ],
            "prop": "x + 1 = Suc x",
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "name": "add_Suc_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "plus_def_1, 0 + Suc y = Suc (0 + y)",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 + Suc y = Suc (0 + y)"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n + Suc y = Suc (n + y) ⟶ Suc n + Suc y = Suc (Suc n + y)"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "n + Suc y = Suc (n + y)",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n + Suc y = Suc (n + y) ⊢ n + Suc y = Suc (n + y)"
                },
                {
                    "args": "Suc (n + Suc y) = Suc (Suc (n + y))",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n + Suc y = Suc (n + y) ⊢ Suc (n + Suc y) = Suc (Suc (n + y))"
                },
                {
                    "args": "plus_def_2, Suc n + Suc y = Suc (Suc n + y)",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n + Suc y = Suc (n + y) ⊢ Suc n + Suc y = Suc (Suc n + y)"
                },
                {
                    "args": "",
                    "id": "1.4",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n + Suc y = Suc (n + y) ⟶ Suc n + Suc y = Suc (Suc n + y)"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x + Suc y = Suc (x + y), x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + Suc y = Suc (x + y)"
                }
            ],
            "prop": "x + Suc y = Suc (x + y)",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "add_comm",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "plus_def_1, 0 + y = y",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 + y = y"
                },
                {
                    "args": "add_0_right, 0 + y = y + 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 + y = y + 0"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n + y = y + n ⟶ Suc n + y = y + Suc n"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "n + y = y + n",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n + y = y + n ⊢ n + y = y + n"
                },
                {
                    "args": "add_Suc_right, Suc (y + n) = y + Suc n",
                    "id": "2.2",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc (y + n) = y + Suc n"
                },
                {
                    "args": "Suc (n + y) = y + Suc n",
                    "id": "2.3",
                    "prevs": [
                        "2.1",
                        "2.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n + y = y + n ⊢ Suc (n + y) = y + Suc n"
                },
                {
                    "args": "plus_def_2, Suc n + y = y + Suc n",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n + y = y + n ⊢ Suc n + y = y + Suc n"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n + y = y + n ⟶ Suc n + y = y + Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x + y = y + x, x: x}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + y = y + x"
                }
            ],
            "prop": "x + y = y + x",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "add_assoc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "plus_def_1, 0 + y + z = 0 + (y + z)",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 + y + z = 0 + (y + z)"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n + y + z = n + (y + z) ⟶ Suc n + y + z = Suc n + (y + z)"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "n + y + z = n + (y + z)",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n + y + z = n + (y + z) ⊢ n + y + z = n + (y + z)"
                },
                {
                    "args": "Suc (n + y + z) = Suc (n + (y + z))",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n + y + z = n + (y + z) ⊢ Suc (n + y + z) = Suc (n + (y + z))"
                },
                {
                    "args": "plus_def_2, Suc (n + y) + z = Suc (n + (y + z))",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n + y + z = n + (y + z) ⊢ Suc (n + y) + z = Suc (n + (y + z))"
                },
                {
                    "args": "plus_def_2, Suc n + y + z = Suc n + (y + z)",
                    "id": "1.4",
                    "prevs": [
                        "1.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n + y + z = n + (y + z) ⊢ Suc n + y + z = Suc n + (y + z)"
                },
                {
                    "args": "",
                    "id": "1.5",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n + y + z = n + (y + z) ⟶ Suc n + y + z = Suc n + (y + z)"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x + y + z = x + (y + z), x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x + y + z = x + (y + z)"
                }
            ],
            "prop": "x + y + z = x + (y + z)",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "hint_rewrite": "true",
            "instructions": [
                "Select 0 as goal, choose 'apply induction' from menu, then enter 'nat_induct,x'.",
                "Select 0 as goal, use Ctrl+R with times_def_1.",
                "Set sorry on 0 to reflexive 0.",
                "Select 2 as goal, use Ctrl+I with n as variable name.",
                "Select 2.2 as goal, use Ctrl+R with times_def_2.",
                "Select 2.2 as goal, use Ctrl+R with plus_def_1"
            ],
            "name": "mult_0_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "times_def_1, 0 * 0 = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * 0 = 0"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * 0 = 0 ⟶ Suc n * 0 = 0"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "n * 0 = 0",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n * 0 = 0 ⊢ n * 0 = 0"
                },
                {
                    "args": "plus_def_1, 0 + n * 0 = 0",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * 0 = 0 ⊢ 0 + n * 0 = 0"
                },
                {
                    "args": "times_def_2, Suc n * 0 = 0",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * 0 = 0 ⊢ Suc n * 0 = 0"
                },
                {
                    "args": "",
                    "id": "1.4",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.3"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n * 0 = 0 ⟶ Suc n * 0 = 0"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x * 0 = 0, x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * 0 = 0"
                }
            ],
            "prop": "x * 0 = 0",
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "name": "mult_1_left",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "add_0_right, x + 0 = x",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ x + 0 = x"
                },
                {
                    "args": "times_def_1, x + 0 * x = x",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ x + 0 * x = x"
                },
                {
                    "args": "times_def_2, 1 * x = x",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 1 * x = x"
                }
            ],
            "prop": "1 * x = x",
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "name": "mult_1_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "times_def_1, 0 * 1 = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * 1 = 0"
                },
                {
                    "args": "",
                    "id": "1",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * 1 = n ⟶ Suc n * 1 = Suc n"
                },
                {
                    "args": "n, nat",
                    "id": "1.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "n * 1 = n",
                    "id": "1.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n * 1 = n ⊢ n * 1 = n"
                },
                {
                    "args": "Suc (n * 1) = Suc n",
                    "id": "1.2",
                    "prevs": [
                        "1.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n * 1 = n ⊢ Suc (n * 1) = Suc n"
                },
                {
                    "args": "plus_def_1, Suc (0 + n * 1) = Suc n",
                    "id": "1.3",
                    "prevs": [
                        "1.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * 1 = n ⊢ Suc (0 + n * 1) = Suc n"
                },
                {
                    "args": "plus_def_2, 1 + n * 1 = Suc n",
                    "id": "1.4",
                    "prevs": [
                        "1.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * 1 = n ⊢ 1 + n * 1 = Suc n"
                },
                {
                    "args": "times_def_2, Suc n * 1 = Suc n",
                    "id": "1.5",
                    "prevs": [
                        "1.4"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * 1 = n ⊢ Suc n * 1 = Suc n"
                },
                {
                    "args": "",
                    "id": "1.6",
                    "prevs": [
                        "1.0",
                        "1.1",
                        "1.5"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n * 1 = n ⟶ Suc n * 1 = Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x * 1 = x, x: x}",
                    "id": "2",
                    "prevs": [
                        "0",
                        "1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * 1 = x"
                }
            ],
            "prop": "x * 1 = x",
            "ty": "thm",
            "vars": {
                "x": "nat"
            }
        },
        {
            "name": "mult_Suc_right",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "times_def_1, 0 * Suc y = 0 * y",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * Suc y = 0 * y"
                },
                {
                    "args": "plus_def_1, 0 * Suc y = 0 + 0 * y",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * Suc y = 0 + 0 * y"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * Suc y = n + n * y ⟶ Suc n * Suc y = Suc n + Suc n * y"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "n * Suc y = n + n * y",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n * Suc y = n + n * y ⊢ n * Suc y = n + n * y"
                },
                {
                    "args": "Suc (y + (n + n * y)) = Suc (n + (y + n * y))",
                    "id": "2.2",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ Suc (y + (n + n * y)) = Suc (n + (y + n * y))"
                },
                {
                    "args": "Suc (y + n * Suc y) = Suc (n + (y + n * y))",
                    "id": "2.3",
                    "prevs": [
                        "2.1",
                        "2.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n * Suc y = n + n * y ⊢ Suc (y + n * Suc y) = Suc (n + (y + n * y))"
                },
                {
                    "args": "plus_def_2, Suc y + n * Suc y = Suc n + (y + n * y)",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * Suc y = n + n * y ⊢ Suc y + n * Suc y = Suc n + (y + n * y)"
                },
                {
                    "args": "times_def_2, Suc n * Suc y = Suc n + Suc n * y",
                    "id": "2.5",
                    "prevs": [
                        "2.4"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * Suc y = n + n * y ⊢ Suc n * Suc y = Suc n + Suc n * y"
                },
                {
                    "args": "",
                    "id": "2.6",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.5"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n * Suc y = n + n * y ⟶ Suc n * Suc y = Suc n + Suc n * y"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x * Suc y = x + x * y, x: x}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * Suc y = x + x * y"
                }
            ],
            "prop": "x * Suc y = x + x * y",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "distrib_l",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "add_0_right, 0 = 0 + 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 = 0 + 0"
                },
                {
                    "args": "times_def_1, 0 * (y + z) = 0 * y + 0 * z",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * (y + z) = 0 * y + 0 * z"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * (y + z) = n * y + n * z ⟶ Suc n * (y + z) = Suc n * y + Suc n * z"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "n * (y + z) = n * y + n * z",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n * (y + z) = n * y + n * z ⊢ n * (y + z) = n * y + n * z"
                },
                {
                    "args": "y + z + (n * y + n * z) = y + n * y + (z + n * z)",
                    "id": "2.2",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ y + z + (n * y + n * z) = y + n * y + (z + n * z)"
                },
                {
                    "args": "y + z + n * (y + z) = y + n * y + (z + n * z)",
                    "id": "2.3",
                    "prevs": [
                        "2.1",
                        "2.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n * (y + z) = n * y + n * z ⊢ y + z + n * (y + z) = y + n * y + (z + n * z)"
                },
                {
                    "args": "times_def_2, Suc n * (y + z) = Suc n * y + Suc n * z",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * (y + z) = n * y + n * z ⊢ Suc n * (y + z) = Suc n * y + Suc n * z"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n * (y + z) = n * y + n * z ⟶ Suc n * (y + z) = Suc n * y + Suc n * z"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x * (y + z) = x * y + x * z, x: x}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * (y + z) = x * y + x * z"
                }
            ],
            "prop": "x * (y + z) = x * y + x * z",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "name": "distrib_r",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "add_0_right, 0 = 0 + 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 = 0 + 0"
                },
                {
                    "args": "mult_0_right, (x + y) * 0 = x * 0 + y * 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ (x + y) * 0 = x * 0 + y * 0"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. (x + y) * n = x * n + y * n ⟶ (x + y) * Suc n = x * Suc n + y * Suc n"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "(x + y) * n = x * n + y * n",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "(x + y) * n = x * n + y * n ⊢ (x + y) * n = x * n + y * n"
                },
                {
                    "args": "x + y + (x * n + y * n) = x + x * n + (y + y * n)",
                    "id": "2.2",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ x + y + (x * n + y * n) = x + x * n + (y + y * n)"
                },
                {
                    "args": "x + y + (x + y) * n = x + x * n + (y + y * n)",
                    "id": "2.3",
                    "prevs": [
                        "2.1",
                        "2.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "(x + y) * n = x * n + y * n ⊢ x + y + (x + y) * n = x + x * n + (y + y * n)"
                },
                {
                    "args": "mult_Suc_right, (x + y) * Suc n = x * Suc n + y * Suc n",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "(x + y) * n = x * n + y * n ⊢ (x + y) * Suc n = x * Suc n + y * Suc n"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. (x + y) * n = x * n + y * n ⟶ (x + y) * Suc n = x * Suc n + y * Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λz. (x + y) * z = x * z + y * z, x: z}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ (x + y) * z = x * z + y * z"
                }
            ],
            "prop": "(x + y) * z = x * z + y * z",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "name": "mult_assoc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "times_def_1, 0 * z = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * z = 0"
                },
                {
                    "args": "times_def_1, 0 * y * z = 0 * (y * z)",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * y * z = 0 * (y * z)"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * y * z = n * (y * z) ⟶ Suc n * y * z = Suc n * (y * z)"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "n * y * z = n * (y * z)",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n * y * z = n * (y * z) ⊢ n * y * z = n * (y * z)"
                },
                {
                    "args": "y * z + n * y * z = y * z + n * (y * z)",
                    "id": "2.2",
                    "prevs": [
                        "2.1"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n * y * z = n * (y * z) ⊢ y * z + n * y * z = y * z + n * (y * z)"
                },
                {
                    "args": "distrib_r, (y + n * y) * z = y * z + n * (y * z)",
                    "id": "2.3",
                    "prevs": [
                        "2.2"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * y * z = n * (y * z) ⊢ (y + n * y) * z = y * z + n * (y * z)"
                },
                {
                    "args": "times_def_2, Suc n * y * z = Suc n * (y * z)",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * y * z = n * (y * z) ⊢ Suc n * y * z = Suc n * (y * z)"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n * y * z = n * (y * z) ⟶ Suc n * y * z = Suc n * (y * z)"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x * y * z = x * (y * z), x: x}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * y * z = x * (y * z)"
                }
            ],
            "prop": "x * y * z = x * (y * z)",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "name": "mult_comm",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "times_def_1, 0 * y = 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * y = 0"
                },
                {
                    "args": "mult_0_right, 0 * y = y * 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 * y = y * 0"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. n * y = y * n ⟶ Suc n * y = y * Suc n"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "n * y = y * n",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "n * y = y * n ⊢ n * y = y * n"
                },
                {
                    "args": "mult_Suc_right, y + y * n = y * Suc n",
                    "id": "2.2",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ y + y * n = y * Suc n"
                },
                {
                    "args": "y + n * y = y * Suc n",
                    "id": "2.3",
                    "prevs": [
                        "2.1",
                        "2.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "n * y = y * n ⊢ y + n * y = y * Suc n"
                },
                {
                    "args": "times_def_2, Suc n * y = y * Suc n",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "n * y = y * n ⊢ Suc n * y = y * Suc n"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. n * y = y * n ⟶ Suc n * y = y * Suc n"
                },
                {
                    "args": "nat_induct, {}, {P: λx. x * y = y * x, x: x}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ x * y = y * x"
                }
            ],
            "prop": "x * y = y * x",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "add_cancel_left",
            "prop": "x + y = x + z --> y = z",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "name": "add_cancel_right",
            "prop": "x + z = y + z --> x = y",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "name": "add_right_eq_zero",
            "prop": "x + y = x --> y = 0",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "add_left_eq_zero",
            "prop": "x + y = y --> x = 0",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "add_is_zero",
            "prop": "x + y = 0 --> x = 0 & y = 0",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "name": "mult_nonzero",
            "prop": "x * y = 0 --> x = 0 | y = 0",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat"
            }
        },
        {
            "depth": 0,
            "name": "Binary representation",
            "ty": "header"
        },
        {
            "name": "bit0",
            "prop": "bit0 n = n + n",
            "ty": "def",
            "type": "nat => nat"
        },
        {
            "name": "bit1",
            "prop": "bit1 n = n + n + 1",
            "ty": "def",
            "type": "nat => nat"
        },
        {
            "name": "one_Suc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "Suc 1 = 1 + 1",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ Suc 1 = 1 + 1"
                },
                {
                    "args": "bit0_def, Suc 1 = 2",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc 1 = 2"
                }
            ],
            "prop": "Suc 1 = bit0 1",
            "ty": "thm",
            "vars": {}
        },
        {
            "name": "bit0_Suc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "Suc (n + n) = n + n + 1",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ Suc (n + n) = n + n + 1"
                },
                {
                    "args": "bit1_def, Suc (n + n) = bit1 n",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc (n + n) = bit1 n"
                },
                {
                    "args": "bit0_def, Suc (bit0 n) = bit1 n",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc (bit0 n) = bit1 n"
                }
            ],
            "prop": "Suc (bit0 n) = bit1 n",
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "name": "bit1_Suc",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "Suc (n + n + 1) = Suc n + Suc n",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ Suc (n + n + 1) = Suc n + Suc n"
                },
                {
                    "args": "bit1_def, Suc (bit1 n) = Suc n + Suc n",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc (bit1 n) = Suc n + Suc n"
                },
                {
                    "args": "bit0_def, Suc (bit1 n) = bit0 (Suc n)",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Suc (bit1 n) = bit0 (Suc n)"
                }
            ],
            "prop": "Suc (bit1 n) = bit0 (Suc n)",
            "ty": "thm",
            "vars": {
                "n": "nat"
            }
        },
        {
            "name": "bit0_bit0_add",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "m + m + (n + n) = m + n + (m + n)",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ m + m + (n + n) = m + n + (m + n)"
                },
                {
                    "args": "bit0_def, bit0 m + bit0 n = bit0 (m + n)",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit0 m + bit0 n = bit0 (m + n)"
                }
            ],
            "prop": "bit0 m + bit0 n = bit0 (m + n)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_bit1_add",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "m + m + (n + n + 1) = m + n + (m + n) + 1",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ m + m + (n + n + 1) = m + n + (m + n) + 1"
                },
                {
                    "args": "bit1_def, m + m + bit1 n = bit1 (m + n)",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ m + m + bit1 n = bit1 (m + n)"
                },
                {
                    "args": "bit0_def, bit0 m + bit1 n = bit1 (m + n)",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit0 m + bit1 n = bit1 (m + n)"
                }
            ],
            "prop": "bit0 m + bit1 n = bit1 (m + n)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit1_bit0_add",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "m + m + 1 + (n + n) = m + n + (m + n) + 1",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ m + m + 1 + (n + n) = m + n + (m + n) + 1"
                },
                {
                    "args": "bit1_def, bit1 m + (n + n) = bit1 (m + n)",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m + (n + n) = bit1 (m + n)"
                },
                {
                    "args": "bit0_def, bit1 m + bit0 n = bit1 (m + n)",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m + bit0 n = bit1 (m + n)"
                }
            ],
            "prop": "bit1 m + bit0 n = bit1 (m + n)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit1_bit1_add",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "m + m + 1 + (n + n + 1) = Suc (m + n) + Suc (m + n)",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ m + m + 1 + (n + n + 1) = Suc (m + n) + Suc (m + n)"
                },
                {
                    "args": "bit1_def, bit1 m + bit1 n = Suc (m + n) + Suc (m + n)",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m + bit1 n = Suc (m + n) + Suc (m + n)"
                },
                {
                    "args": "bit0_def, bit1 m + bit1 n = bit0 (Suc (m + n))",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m + bit1 n = bit0 (Suc (m + n))"
                }
            ],
            "prop": "bit1 m + bit1 n = bit0 (Suc (m + n))",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_bit0_mult",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "(m + m) * (n + n) = m * n + m * n + (m * n + m * n)",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ (m + m) * (n + n) = m * n + m * n + (m * n + m * n)"
                },
                {
                    "args": "bit0_def, bit0 m * bit0 n = bit0 (bit0 (m * n))",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit0 m * bit0 n = bit0 (bit0 (m * n))"
                }
            ],
            "prop": "bit0 m * bit0 n = bit0 (bit0 (m * n))",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_bit1_mult",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "(m + m) * (n + n + 1) = m * (n + n + 1) + m * (n + n + 1)",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ (m + m) * (n + n + 1) = m * (n + n + 1) + m * (n + n + 1)"
                },
                {
                    "args": "bit1_def, (m + m) * bit1 n = m * bit1 n + m * bit1 n",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ (m + m) * bit1 n = m * bit1 n + m * bit1 n"
                },
                {
                    "args": "bit0_def, bit0 m * bit1 n = bit0 (m * bit1 n)",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit0 m * bit1 n = bit0 (m * bit1 n)"
                }
            ],
            "prop": "bit0 m * bit1 n = bit0 (m * bit1 n)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit1_bit0_mult",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "(m + m + 1) * (n + n) = (m + m + 1) * n + (m + m + 1) * n",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ (m + m + 1) * (n + n) = (m + m + 1) * n + (m + m + 1) * n"
                },
                {
                    "args": "bit1_def, bit1 m * (n + n) = bit1 m * n + bit1 m * n",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m * (n + n) = bit1 m * n + bit1 m * n"
                },
                {
                    "args": "bit0_def, bit1 m * bit0 n = bit0 (bit1 m * n)",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m * bit0 n = bit0 (bit1 m * n)"
                }
            ],
            "prop": "bit1 m * bit0 n = bit0 (bit1 m * n)",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit1_bit1_mult",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "(m + m + 1) * (n + n + 1) = m + n + (m * n + m * n) + (m + n + (m * n + m * n)) + 1",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ (m + m + 1) * (n + n + 1) = m + n + (m * n + m * n) + (m + n + (m * n + m * n)) + 1"
                },
                {
                    "args": "bit1_def, bit1 m * bit1 n = bit1 (m + n + (m * n + m * n))",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m * bit1 n = bit1 (m + n + (m * n + m * n))"
                },
                {
                    "args": "bit0_def, bit1 m * bit1 n = bit1 (m + n + bit0 (m * n))",
                    "id": "2",
                    "prevs": [
                        "1"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ bit1 m * bit1 n = bit1 (m + n + bit0 (m * n))"
                }
            ],
            "prop": "bit1 m * bit1 n = bit1 (m + n + bit0 (m * n))",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_nonzero",
            "prop": "~ m = 0 --> ~ (bit0 m = 0)",
            "ty": "thm",
            "vars": {
                "m": "nat"
            }
        },
        {
            "name": "bit1_nonzero",
            "prop": "~ bit1 m = 0",
            "ty": "thm",
            "vars": {
                "m": "nat"
            }
        },
        {
            "name": "one_nonzero",
            "prop": "~ 1 = 0",
            "ty": "thm",
            "vars": {}
        },
        {
            "name": "bit0_neq",
            "prop": "~ m = n --> ~ bit0 m = bit0 n",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit1_neq",
            "prop": "~ m = n --> ~bit1 m = bit1 n",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_bit1_neq",
            "prop": "~ bit0 m = bit1 n",
            "ty": "thm",
            "vars": {
                "m": "nat",
                "n": "nat"
            }
        },
        {
            "name": "bit0_neq_one",
            "prop": "~ bit0 m = 1",
            "ty": "thm",
            "vars": {
                "m": "nat"
            }
        },
        {
            "name": "bit1_neq_one",
            "prop": "~ m = 0 --> ~ bit1 m = 1",
            "ty": "thm",
            "vars": {
                "m": "nat"
            }
        },
        {
            "name": "nat_const_ineq",
            "ty": "macro"
        },
        {
            "name": "nat_const_ineq",
            "ty": "method"
        },
        {
            "depth": 0,
            "name": "Test of macros",
            "ty": "header"
        },
        {
            "name": "nat_norm_test1",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "x + y + (y + z) = y * 2 + (x + z)",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ x + y + (y + z) = y * 2 + (x + z)"
                }
            ],
            "prop": "(x + y) + (y + z) = y * 2 + (x + z)",
            "ty": "thm",
            "vars": {
                "x": "nat",
                "y": "nat",
                "z": "nat"
            }
        },
        {
            "name": "nat_const_ineq_test1",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "¬12 = 13",
                    "id": "0",
                    "prevs": [],
                    "rule": "nat_const_ineq",
                    "th": "⊢ ¬12 = 13"
                }
            ],
            "prop": "~ 12 = 13",
            "ty": "thm",
            "vars": {}
        },
        {
            "name": "Sigma",
            "rules": [
                {
                    "prop": "Sigma f 0 = 0"
                },
                {
                    "prop": "Sigma f (Suc n) = Sigma f n + f n"
                }
            ],
            "ty": "def.ind",
            "type": "(nat => nat) => nat => nat"
        },
        {
            "name": "Sigma_plus",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "plus_def_1, 0 = 0 + 0",
                    "id": "0",
                    "prevs": [],
                    "rule": "rewrite_goal",
                    "th": "⊢ 0 = 0 + 0"
                },
                {
                    "args": "Sigma_def_1, Sigma (λx. f x + g x) 0 = Sigma f 0 + Sigma g 0",
                    "id": "1",
                    "prevs": [
                        "0"
                    ],
                    "rule": "rewrite_goal",
                    "th": "⊢ Sigma (λx. f x + g x) 0 = Sigma f 0 + Sigma g 0"
                },
                {
                    "args": "",
                    "id": "2",
                    "prevs": [],
                    "rule": "subproof",
                    "th": "⊢ ∀n. Sigma (λx. f x + g x) n = Sigma f n + Sigma g n ⟶ Sigma (λx. f x + g x) (Suc n) = Sigma f (Suc n) + Sigma g (Suc n)"
                },
                {
                    "args": "n, nat",
                    "id": "2.0",
                    "prevs": [],
                    "rule": "variable",
                    "th": "⊢ n = n"
                },
                {
                    "args": "Sigma (λx. f x + g x) n = Sigma f n + Sigma g n",
                    "id": "2.1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "Sigma (λx. f x + g x) n = Sigma f n + Sigma g n ⊢ Sigma (λx. f x + g x) n = Sigma f n + Sigma g n"
                },
                {
                    "args": "Sigma f n + Sigma g n + (f n + g n) = Sigma f n + f n + (Sigma g n + g n)",
                    "id": "2.2",
                    "prevs": [],
                    "rule": "nat_norm",
                    "th": "⊢ Sigma f n + Sigma g n + (f n + g n) = Sigma f n + f n + (Sigma g n + g n)"
                },
                {
                    "args": "Sigma (λx. f x + g x) n + (f n + g n) = Sigma f n + f n + (Sigma g n + g n)",
                    "id": "2.3",
                    "prevs": [
                        "2.1",
                        "2.2"
                    ],
                    "rule": "rewrite_goal_with_prev",
                    "th": "Sigma (λx. f x + g x) n = Sigma f n + Sigma g n ⊢ Sigma (λx. f x + g x) n + (f n + g n) = Sigma f n + f n + (Sigma g n + g n)"
                },
                {
                    "args": "Sigma_def_2, Sigma (λx. f x + g x) (Suc n) = Sigma f (Suc n) + Sigma g (Suc n)",
                    "id": "2.4",
                    "prevs": [
                        "2.3"
                    ],
                    "rule": "rewrite_goal",
                    "th": "Sigma (λx. f x + g x) n = Sigma f n + Sigma g n ⊢ Sigma (λx. f x + g x) (Suc n) = Sigma f (Suc n) + Sigma g (Suc n)"
                },
                {
                    "args": "",
                    "id": "2.5",
                    "prevs": [
                        "2.0",
                        "2.1",
                        "2.4"
                    ],
                    "rule": "intros",
                    "th": "⊢ ∀n. Sigma (λx. f x + g x) n = Sigma f n + Sigma g n ⟶ Sigma (λx. f x + g x) (Suc n) = Sigma f (Suc n) + Sigma g (Suc n)"
                },
                {
                    "args": "nat_induct, {}, {P: λn. Sigma (λx. f x + g x) n = Sigma f n + Sigma g n, x: n}",
                    "id": "3",
                    "prevs": [
                        "1",
                        "2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "⊢ Sigma (λx. f x + g x) n = Sigma f n + Sigma g n"
                }
            ],
            "prop": "Sigma (%x. f x + g x) n = Sigma f n + Sigma g n",
            "ty": "thm",
            "vars": {
                "f": "nat => nat",
                "g": "nat => nat",
                "n": "nat"
            }
        }
    ],
    "description": "Natural numbers",
    "imports": [
        "logic"
    ],
    "name": "nat"
}