{
    "content": [
        {
            "T": "bool => bool => bool",
            "ascii_op": "&",
            "name": "conj",
            "ty": "def.ax",
            "unicode_op": "∧"
        },
        {
            "T": "bool => bool => bool",
            "ascii_op": "|",
            "name": "disj",
            "ty": "def.ax",
            "unicode_op": "∨"
        },
        {
            "T": "bool => bool",
            "ascii_op": "~",
            "name": "neg",
            "ty": "def.ax",
            "unicode_op": "¬"
        },
        {
            "T": "bool",
            "name": "true",
            "ty": "def.ax"
        },
        {
            "T": "bool",
            "name": "false",
            "ty": "def.ax"
        },
        {
            "T": "('a => bool) => bool",
            "name": "exists",
            "ty": "def.ax"
        },
        {
            "name": "conjI",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "A",
                    "id": "A1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "A ⊢ A"
                },
                {
                    "args": "B",
                    "id": "A2",
                    "prevs": [],
                    "rule": "assume",
                    "th": "B ⊢ B"
                },
                {
                    "args": "conjI, {A: A, B: B}",
                    "id": "S1",
                    "prevs": [
                        "A1",
                        "A2"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "A, B ⊢ A ∧ B"
                },
                {
                    "args": "B",
                    "id": "S2",
                    "prevs": [
                        "S1"
                    ],
                    "rule": "implies_intr",
                    "th": "A ⊢ B ⟶ A ∧ B"
                },
                {
                    "args": "A",
                    "id": "S3",
                    "prevs": [
                        "S2"
                    ],
                    "rule": "implies_intr",
                    "th": "⊢ A ⟶ B ⟶ A ∧ B"
                }
            ],
            "prop": "A --> B --> A & B",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "conjD1",
            "num_gaps": 1,
            "proof": [
                {
                    "args": "A ∧ B",
                    "id": "A1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "A ∧ B ⊢ A ∧ B"
                },
                {
                    "args": "",
                    "id": "S1",
                    "prevs": [],
                    "rule": "sorry",
                    "th": "A ∧ B ⊢ A"
                },
                {
                    "args": "A ∧ B",
                    "id": "S2",
                    "prevs": [
                        "S1"
                    ],
                    "rule": "implies_intr",
                    "th": "⊢ A ∧ B ⟶ A"
                }
            ],
            "prop": "A & B --> A",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "conjD2",
            "num_gaps": 0,
            "proof": [
                {
                    "args": "A ∧ B",
                    "id": "A1",
                    "prevs": [],
                    "rule": "assume",
                    "th": "A ∧ B ⊢ A ∧ B"
                },
                {
                    "args": "conjD2, {B: B}",
                    "id": "S1",
                    "prevs": [
                        "A1"
                    ],
                    "rule": "apply_theorem_for",
                    "th": "A ∧ B ⊢ B"
                },
                {
                    "args": "A ∧ B",
                    "id": "S2",
                    "prevs": [
                        "S1"
                    ],
                    "rule": "implies_intr",
                    "th": "⊢ A ∧ B ⟶ B"
                }
            ],
            "prop": "A & B --> B",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "disjI1",
            "prop": "A --> A | B",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "disjI2",
            "prop": "B --> A | B",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool"
            }
        },
        {
            "name": "disjE",
            "prop": "A | B --> (A --> C) --> (B --> C) --> C",
            "ty": "thm",
            "vars": {
                "A": "bool",
                "B": "bool",
                "C": "bool"
            }
        },
        {
            "name": "negI",
            "prop": "(A --> false) --> ~A",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "negE",
            "prop": "~A --> A --> false",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "trueI",
            "prop": "true",
            "ty": "thm",
            "vars": {}
        },
        {
            "name": "falseE",
            "prop": "false --> A",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "exI",
            "prop": "P a --> ?a::'a. P a",
            "ty": "thm",
            "vars": {
                "P": "'a => bool",
                "a": "'a"
            }
        },
        {
            "name": "exE",
            "prop": "(?a::'a. P a) --> (!a::'a. P a --> C) --> C",
            "ty": "thm",
            "vars": {
                "C": "bool",
                "P": "'a => bool",
                "a": "'a"
            }
        },
        {
            "name": "classical",
            "prop": "A | ~A",
            "ty": "thm",
            "vars": {
                "A": "bool"
            }
        },
        {
            "name": "arg_combination",
            "ty": "macro"
        },
        {
            "name": "fun_combination",
            "ty": "macro"
        },
        {
            "name": "beta_norm",
            "ty": "macro"
        },
        {
            "name": "apply_theorem",
            "ty": "macro"
        },
        {
            "name": "apply_theorem_for",
            "ty": "macro"
        },
        {
            "name": "rewrite_goal",
            "ty": "macro"
        },
        {
            "name": "rewrite_back_goal",
            "ty": "macro"
        },
        {
            "args": [],
            "constrs": [
                {
                    "args": [],
                    "name": "zero",
                    "type": "nat"
                },
                {
                    "args": [
                        "n"
                    ],
                    "name": "Suc",
                    "type": "nat => nat"
                }
            ],
            "name": "nat",
            "ty": "type.ind"
        },
        {
            "ascii_op": "+",
            "name": "plus",
            "rules": [
                {
                    "prop": "0 + n = n",
                    "vars": {
                        "n": "nat"
                    }
                },
                {
                    "prop": "Suc m + n = Suc (m + n)",
                    "vars": {
                        "m": "nat",
                        "n": "nat"
                    }
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat => nat"
        },
        {
            "ascii_op": "*",
            "name": "times",
            "rules": [
                {
                    "prop": "0 * n = 0",
                    "vars": {
                        "n": "nat"
                    }
                },
                {
                    "prop": "Suc m * n = n + m * n",
                    "vars": {
                        "m": "nat",
                        "n": "nat"
                    }
                }
            ],
            "ty": "def.ind",
            "type": "nat => nat => nat"
        },
        {
            "args": [
                "a"
            ],
            "constrs": [
                {
                    "args": [],
                    "name": "nil",
                    "type": "'a list"
                },
                {
                    "args": [
                        "x",
                        "xs"
                    ],
                    "name": "cons",
                    "type": "'a => 'a list => 'a list"
                }
            ],
            "name": "list",
            "ty": "type.ind"
        },
        {
            "ascii_op": "@",
            "name": "append",
            "rules": [
                {
                    "prop": "nil @ xs = xs",
                    "vars": {
                        "xs": "'a list"
                    }
                },
                {
                    "prop": "cons x xs @ ys = cons x (xs @ ys)",
                    "vars": {
                        "x": "'a",
                        "xs": "'a list",
                        "ys": "'a list"
                    }
                }
            ],
            "ty": "def.ind",
            "type": "'a list => 'a list => 'a list"
        },
        {
            "name": "rev",
            "rules": [
                {
                    "prop": "rev nil = nil",
                    "vars": {}
                },
                {
                    "prop": "rev (cons x xs) = rev xs @ cons x nil",
                    "vars": {
                        "x": "'a",
                        "xs": "'a list"
                    }
                }
            ],
            "ty": "def.ind",
            "type": "'a list => 'a list"
        }
    ],
    "imports": [],
    "name": "logic_base"
}